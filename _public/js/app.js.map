{"version":3,"file":"_public\\js\\app.js","sources":["app/app.coffee","app/assets/node_modules/mycroft/mycroft.js","app/assets/node_modules/nedb/benchmarks/commonUtilities.js","app/assets/node_modules/nedb/benchmarks/ensureIndex.js","app/assets/node_modules/nedb/benchmarks/find.js","app/assets/node_modules/nedb/benchmarks/findOne.js","app/assets/node_modules/nedb/benchmarks/findWithIn.js","app/assets/node_modules/nedb/benchmarks/insert.js","app/assets/node_modules/nedb/benchmarks/loadDatabase.js","app/assets/node_modules/nedb/benchmarks/remove.js","app/assets/node_modules/nedb/benchmarks/update.js","app/assets/node_modules/nedb/browser-version/browser-specific/lib/customUtils.js","app/assets/node_modules/nedb/browser-version/browser-specific/lib/persistence.js","app/assets/node_modules/nedb/browser-version/build.js","app/assets/node_modules/nedb/browser-version/out/nedb.js","app/assets/node_modules/nedb/browser-version/out/nedb.min.js","app/assets/node_modules/nedb/browser-version/test/mocha.js","app/assets/node_modules/nedb/browser-version/test/nedb-browser.js","app/assets/node_modules/nedb/index.js","app/assets/node_modules/nedb/lib/customUtils.js","app/assets/node_modules/nedb/lib/datastore.js","app/assets/node_modules/nedb/lib/executor.js","app/assets/node_modules/nedb/lib/indexes.js","app/assets/node_modules/nedb/lib/model.js","app/assets/node_modules/nedb/lib/persistence.js","app/assets/node_modules/nedb/node_modules/async/lib/async.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/index.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/lib/avltree.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/lib/bst.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/lib/customUtils.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/test/avltree.test.js","app/assets/node_modules/nedb/node_modules/binary-search-tree/test/bst.test.js","app/assets/node_modules/nedb/node_modules/mkdirp/examples/pow.js","app/assets/node_modules/nedb/node_modules/mkdirp/index.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/chmod.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/clobber.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/mkdirp.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/perm.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/perm_sync.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/race.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/rel.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/return.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/return_sync.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/root.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/sync.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/umask.js","app/assets/node_modules/nedb/node_modules/mkdirp/test/umask_sync.js","app/assets/node_modules/nedb/node_modules/underscore/index.js","app/assets/node_modules/nedb/node_modules/underscore/underscore-min.js","app/assets/node_modules/nedb/node_modules/underscore/underscore.js","app/assets/node_modules/nedb/test/customUtil.test.js","app/assets/node_modules/nedb/test/db.test.js","app/assets/node_modules/nedb/test/indexes.test.js","app/assets/node_modules/nedb/test/model.test.js","app/assets/node_modules/nedb/test/persistence.test.js","app/assets/node_modules/nedb/test_lac/loadAndCrash.test.js","app/assets/node_modules/uuid/benchmark/benchmark.js","app/assets/node_modules/uuid/misc/compare.js","app/assets/node_modules/uuid/misc/perf.js","app/assets/node_modules/uuid/rng-browser.js","app/assets/node_modules/uuid/rng.js","app/assets/node_modules/uuid/test/test.js","app/assets/node_modules/uuid/uuid.js","app/scripts/controllers.coffee","app/scripts/datastore.coffee"],"names":[],"mappings":"AAAA;;;AAEA,CAFA,CAE4B,CAA5B,EAAM,EAAO,EAAe;;AAQ5B,CAVA,EAUG,GAAH;EAEE,CADA,GAGF,GAAC,KAAD,EAJW,CAIX,EAJW;CAMT,CAEoB,EAFpB,UAEE;CAAkB,CAAc,IAAb,kBAAD;CAClB,CAAe,EAHjB;CAGiB,CAAc,IAAb,eAAD;CACf,CAAiB,EAJnB;CAImB,CAAc,IAAb,iBAAD;CAGjB,KAPF;CAOa,CAAa,IAAZ,CAAD,GAAC;CAPd;CAUkB,IAAlB,YAAiB;CAhBR,EAIX;CAdA,CAUA;A,CCVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCpgLA;AACA;A,CCDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC1vJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzSA;AACA;AACA;AACA;A,CCHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCxuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC37BA;AACA;AACA;A,CCFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCvcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC/hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC3jCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCnhCA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChCA;AACA;A,CCDA;A,CCAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC1sCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CChwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC5tCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC5mBA;AACA;AACA;AACA;AACA;A,CCJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC/BA;AACA;AACA;AACA;AACA;A,CCJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC3LA;CAEA;AAFA;AAIA,CAJA,CAIkC,IAAlC,CAAO,EAAP;EAIE,CADA,GAKF,EANuB,CAMtB,CAAD,CANuB;CAQrB,EAAgC,CAAhC,EAAM,GAA0B,aAAhC;CACS,EAAO,CAAd,CAAqB,CAAf,CAAe,MAArB;CADF,IAAgC;CAAhC,EAKmB,CAAnB,EAAM,GAAN;CALA,CAMkC,EAAlC,EAAM,GAA6B,SAAnC;CACS,EAAc,GAAf,KAAN;CADF,IAAkC;CANlC,CAkBkB,EAAlB,EAAM,EAAN,CAAmB;CACjB,CAAmC,EAAhC,CAA8C,CAAjD,GAAG,EAAkB;CACnB,cAAO;MADT;CAGE,cAAO;OAJO;CAlBlB,IAkBkB;CAlBlB,EAyBiB,CAAjB,EAAM,CAAN;OACE;EAAM,EAAN;EACM,EAAN,MADA;EAGA,MAJe;CAIf,CAAM,EAAN;EACM,EAAN,UADA;OAJe;CAzBjB;CAiCO,EAAc,GAAf,GAAe,EAArB;CACE;GAAU,GAAV;CACA;;;;CACE,GAAG,IAAH;CACE,MAAO;MADT;;SADF;;sBAFmB;CAnCvB,IAmCuB;CAzCA,EAMvB;CA0CA,CAlDA;EAqDA,CAFE,GAEF,EAHsB,CAGrB;CACQ,EAAa,GAAd,IAAN;CAJoB,EAGtB;CAIA,CAzDA;EA4DA,CAFE,GAEF,EAHuB,CAGtB;CAAD,UACE;CAJqB,EAGvB;CAIA,CAhEA;EAmEA,CAFE,GAEF,EAHoB,CAGnB;CAGC;GAAS,CAAT,IAAiB,IAAR;CAAT,EACoB,CAApB,EAAM,GAAc,CAApB;CACE,EAAa,CAAZ,EAAD;CADkB,YAElB;CAHF,IACoB;CADpB,EAKmB,CAAnB,EAAM,GAAN;CACE,EAAa,CAAZ,EAAD;CADiB,YAEjB;CAPF,IAKmB;CAIZ,EAAS,GAAV,GAAW,EAAjB;CACE;GACe,EAAf,OAA6B;CAFf,YAGd;CAfJ,IAYkB;CAfE,EAGpB;CAvEA,CAIA;;AAqFA,CAzFA,EAyFoB,GAAd,GAAe,CAArB;CACE;CADkB,QAElB;CAFkB;;AAIpB,CA7FA,EA6FgB,GAAV,GAAW;CACf;CADc,QAEd;CAFc;A,CC7FhB;;EAAoC,CAAxB,CAAa,GAAb,EAAZ,2CAAY;;AAOZ,CAPA,EAOmB,GAAnB,GAAS;CAAoB,SAAO;CAAP,QACtB;CAAc;CADQ,QAGtB,GAHsB;CAGJ;CAHI,QAItB,CAJsB;CAIN;CAJM;CAMtB,YAAO;CANe,EAAV;;;AASnB,CAhBA,EAgBoB,cAApB;SACE;EAAK,CAAL,MAAM;CAAa,EAA2B,CAA5B,CAAJ,EAAW,EAAqB,GAAT,CAAvB;CAAd,IAAK;CAAL,CACK,CAAL,EAAK,IAAC;CAA4B,CAA6B,CAArB,CAAI,CAAiB,EAA1C,EAAqB,GAAT,CAAZ;CADrB,IACK;CADL,CAEQ,EAAR,KAAS;CAAqB,EAAW,CAAI,KAAJ,CAAxB,EAAY,CAAZ;CAFjB,IAEQ;CAFR,CAGO,EAAP,KAAO;CAAgB,WAAD,CAAZ;CAHV,IAGO;CAHP,CAIO,EAAP,KAAO;CAAgB,IAAb,OAAY,CAAZ;CAJV,IAIO;CALW;;;AAOpB,CAvBA,EAuBwB,kBAAxB;CACE;GAAK,CAAwD,CAAxD;CAAL,CACA,CAAQ,EAAR;CAAQ,CACD,CAAL,EAAK,IAAC;CAAiB,CAAD,CAAa,MAAC,EAAhB;CAA0B,CAAD,CAAuB,EAAzB,CAAyB,GAAC,CAA1B;CACzC;;;AAAK;kBAA6B,mFAA7B;IAAW,EAAL;CAAN;;CAD6D;CAAzB,QAAyB;CAAhD,MAAe;CAD7B,IACD;CAFP;CAKA,QAAO;CANe;;AAQxB,CA/BA,EA+BsB,gBAAtB;CACE;;CACE,EAAO,CAAP,EAAO;CAAP,EACW,CAAX,GAAW,CAAX;CADA,EAEQ,CAAR;CAAQ,CACM,IAAZ,GAAa,CAAb;CAA+B,GAAL;CAAK,CAAa,EAAb,IAAE;CAAF,CAAkC,EAAlC,IAAwB;CAA3C,SAAc;CADpB,MACM;CAHd;CAKA,UAAO;IANT;CAQE,GADI,EACJ;KAAa,aAAb;CACU,IAAR,EAAO,MAAP;MADF;CAGU,IAAR,EAAO,MAAP;KAXJ;GADoB;;A","sourcesContent":["'use strict'\r\n\r\nApp = angular.module('app', [\r\n  'ngCookies'\r\n  'ngResource'\r\n  'ngRoute'\r\n  'app.controllers'\r\n  'partials'\r\n])\r\n\r\nApp.config([\r\n  '$routeProvider'\r\n  '$locationProvider'\r\n\r\n($routeProvider, $locationProvider, config) ->\r\n\r\n  $routeProvider\r\n\r\n    .when('/youtube', {templateUrl: '/partials/youtube.html'})\r\n    .when('/file', {templateUrl: '/partials/file.html'})\r\n    .when('/screen', {templateUrl: '/partials/screen.html'})\r\n\r\n    # Catch all\r\n    .otherwise({redirectTo: '/file'})\r\n\r\n  # Without server side support html5 must be disabled.\r\n  $locationProvider.html5Mode(false)\r\n])\r\n","(function() {\r\n  var _global = this;\r\n\r\nvar tls = require('tls');\r\nvar net = require('net');\r\nvar uuid = require('uuid');\r\nvar fs = require('fs');\r\nvar MYCROFT_PORT = 1847;\r\n\r\nvar Mycroft = function() {\r\n  \r\n  this.new = function(manifest, host, port) {\r\n    var app = new Mycroft();\r\n    app.host = host || 'localhost';\r\n    app.port = port || MYCROFT_PORT;\r\n    app.manifest_loc = manifest || 'app.json';\r\n    app.handlers = {};\r\n  }\r\n\r\n  this.status = 'down';\r\n  this.host = 'localhost';\r\n  this.manifest_loc = 'app.json';\r\n  this.port = MYCROFT_PORT;\r\n  \r\n  this._unconsumed = '';\r\n\r\n  // Parses a received message and returns an array of commands as\r\n  // an Object containing type:String and data:Object.\r\n  // There is not a doubt in my mind that this is not poorly written\r\n  this.parseMessage = function (msg) {\r\n    // Add the message to unconsumed.\r\n    this._unconsumed += msg.toString().trim();\r\n    // Create an array for the newly parsed commands.\r\n    var parsedCommands = [];\r\n    \r\n    while (_unconsumed != '') {\r\n      // Get the message-length to read.\r\n      var verbStart = this._unconsumed.indexOf('\\n');\r\n      var msgLen = parseInt(this._unconsumed.substr(0, verbStart));\r\n      // Cut off the message length header from unconsumed.\r\n      _unconsumed = this._unconsumed.substr(verbStart+1);\r\n      // Figure out how many bytes we have left to consume.\r\n      var bytesLeft = Buffer.byteLength(this._unconsumed, 'utf8');\r\n      // Do not process anything if we do not have enough bytes.\r\n      if (bytesLeft < msgLen) {\r\n        break;\r\n      }\r\n      // Isolate the message we are actually handling.\r\n      var unconsumedBuffer = new Buffer(this._unconsumed);\r\n      msg = unconsumedBuffer.slice(0, msgLen).toString();\r\n      // Store remaining stuff in unconsumed.\r\n      this._unconsumed = unconsumedBuffer.slice(msgLen).toString();\r\n      // Go process this single message.\r\n      console.log('Got message:');\r\n      console.log(msg);\r\n      var type = '';\r\n      var data = {};\r\n      var index = msg.indexOf(' ');\r\n      if (index >= 0) { // If a body was supplied\r\n        type = msg.substr(0, index);\r\n        try {\r\n          var toParse = msg.substr(index);\r\n          data = JSON.parse(toParse);\r\n        }\r\n        catch(err) {\r\n          console.log('Recieved malformed message, responding with MSG_MALFORMED');\r\n          this.sendMessage(\"MSG_MALFORMED \\n\" + err);\r\n          return;\r\n        }\r\n      } else { // No body was supplied\r\n        type = msg;\r\n      }\r\n      \r\n      parsedCommands.push({type: type, data: data});\r\n    }\r\n    return parsedCommands;\r\n  }\r\n\r\n  // If using TLS, appName is assumed to be the name of the keys.\r\n  //process.argv.length === 3 && process.argv[2] === '--no-tls'\r\n  this.connect = function (cert_name) {\r\n    var client = null;\r\n    if (!cert_name) {\r\n      console.log(\"Not using TLS\");\r\n      client = net.connect({port: this.port, host:this.host}, function(err) {\r\n        if (err) {\r\n          console.error('There was an error establishing connection');\r\n        }\r\n      });\r\n    } else {\r\n      console.log(\"Using TLS\");\r\n      var connectOptions = {\r\n        key: fs.readFileSync(cert_name + '.key'),\r\n        cert: fs.readFileSync(cert_name + '.crt'),\r\n        ca: [ fs.readFileSync('ca.crt') ],\r\n        rejectUnauthorized: false,\r\n        port: this.port,\r\n        host: this.host\r\n      };\r\n      client = tls.connect(connectOptions, function(err) {\r\n        if (err) {\r\n          console.error('There was an error in establishing TLS connection');\r\n        }\r\n      });\r\n    }\r\n    console.log('Connected to Mycroft');\r\n    this.cli = client;\r\n    this.cli.on('data', function(msg) {\r\n      parsed = this.parseMessage(msg);\r\n      for(var i = 0; i < parsed.length; i++) {\r\n        this.handle(parsed[i].type, parsed[i].data);\r\n      }\r\n    });\r\n    this.cli.on('end', function(data) {\r\n      this.connectionClosed(data);\r\n    });\r\n  }\r\n  \r\n  this.on = function(name, func) {\r\n    if (!this.handlers[name]) {\r\n      this.handlers[name] = [];\r\n    }\r\n    this.handlers[name] += func;\r\n  }\r\n  \r\n  this.connectionClosed = function(data) {\r\n    if (this.handlers['CONNECTION_CLOSED']) {\r\n      for (var i=0; i<this.handlers[type].length; i++) {\r\n        this.handlers['CONNECTION_CLOSED'][i](data);\r\n      }\r\n    }\r\n    console.log(\"Connection closed.\");\r\n  }\r\n  \r\n  this.handle = function(type, data) {\r\n    if (this.handlers[type]) {\r\n      for (var i=0; i<this.handlers[type].length; i++) {\r\n        this.handlers[type][i](data);\r\n      }\r\n    } else {\r\n      console.log(\"not handling messages:\");\r\n      console.log(type+\": \"+JSON.stringify(data));\r\n    }\r\n  }\r\n\r\n  //Given the path to a JSON manifest, converts that manifest to a string,\r\n  //and precedes it with the type MANIFEST\r\n  this.sendManifest = function (path) {\r\n    var path = path || this.manifest_loc; //use manifest location from constructor if possible\r\n    try {\r\n      fs.readFile(path, 'utf-8', function(err, data) {\r\n        if (err) {\r\n          console.log(\"Error reading manifest:\");\r\n          console.log(err);\r\n        }\r\n        \r\n        var json;\r\n        try {\r\n          json = JSON.parse(data);\r\n        }\r\n        catch(err) {\r\n          console.log(\"Error parsing manifest:\");\r\n          console.log(err);\r\n        }\r\n        \r\n        if (json) {\r\n          console.log('Sending Manifest');\r\n          this.sendMessage('APP_MANIFEST', json);\r\n        }\r\n      })\r\n    }\r\n    catch(err) {\r\n      console.error('Invalid file path');\r\n      return;\r\n    }\r\n  }\r\n\r\n  this.up = function() {\r\n    console.log('Sending App Up');\r\n    this.status = 'up';\r\n    this.sendMessage('APP_UP');\r\n  }\r\n\r\n  this.down = function() {\r\n    console.log('Sending App Down');\r\n    this.status = 'down';\r\n    this.sendMessage('APP_DOWN');\r\n  }\r\n  \r\n  this.in_use = function() {\r\n    console.log('Sending App In Use');\r\n    this.status = 'in use';\r\n    this.sendMessage('APP_IN_USE');\r\n  }\r\n\r\n  this.query = function (ccapability, action, data, instanceId, priority) {\r\n    queryMessage = {\r\n      id: uuid.v4(),\r\n      capability: capability,\r\n      action: action,\r\n      data: data,\r\n      priority: priority,\r\n\r\n    };\r\n    if (typeof(instanceId) != 'undefined') queryMessage.instanceId = instanceId;\r\n\r\n    this.sendMessage('MSG_QUERY', queryMessage);\r\n  }\r\n\r\n  this.sendSuccess = function(id, ret) {\r\n    var querySuccessMessage = {\r\n      id: id,\r\n      ret: ret\r\n    };\r\n\r\n    this.sendMessage('MSG_QUERY_SUCCESS', querySuccessMessage);\r\n  }\r\n\r\n  this.sendFail = function (id, message) {\r\n    var queryFailMessage = {\r\n      id: id,\r\n      message: message\r\n    };\r\n\r\n    this.sendMessage('MSG_QUERY_FAIL', queryFailMessage);\r\n  }\r\n\r\n  //Sends a message to the Mycroft global message board.\r\n  this.broadcast = function(content) {\r\n    message = {\r\n      id: uuid.v4(),\r\n      content: content\r\n    };\r\n    this.sendMessage('MSG_BROADCAST', message);\r\n  }\r\n\r\n  // Checks if the manifest was validated and returns dependencies\r\n  this.checkManifest = function (parsed) {\r\n    if (parsed.type === 'APP_MANIFEST_OK' || parsed.type === 'APP_MANIFEST_FAIL') {\r\n      console.log('Response type: ' +  parsed.type);\r\n      console.log('Response recieved: ' + JSON.stringify(parsed.data));\r\n\r\n      if (parsed.type === 'APP_MANIFEST_OK') {\r\n        console.log('Manifest Validated');\r\n        return parsed.data.dependencies; //THIS WILL ALWAYS BE NIL WITH CURRENT DESIGN\r\n      } else {\r\n        throw 'Invalid application manifest';\r\n      }\r\n    }\r\n  }\r\n\r\n  //Sends a message of specified type. Adds byte length before message.\r\n  //Does not need to specify a message object. (e.g. APP_UP and APP_DOWN)\r\n  this.sendMessage = function (type, message) {\r\n    if (typeof(message) === 'undefined') {\r\n      message = '';\r\n    } else {\r\n      message = JSON.stringify(message);\r\n    }\r\n    var body = (type + ' ' + message).trim();\r\n    var length = Buffer.byteLength(body, 'utf8');\r\n    console.log('Sending Message');\r\n    console.log(length);\r\n    console.log(body);\r\n    if (this.cli) {\r\n      this.cli.write(length + '\\n' + body);\r\n    } else {\r\n      console.log(\"The client connection wasn't established, so the message could not be sent.\");\r\n    }\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n    // Publish as AMD module\r\n    define(function() {return Mycroft;});\r\n  } else if (typeof(module) != 'undefined' && module.exports) {\r\n    // Publish as node.js module\r\n    module.exports = Mycroft;\r\n  } else {\r\n    // Publish as global (in browsers)\r\n    var _previousRoot = _global.Mycroft;\r\n\r\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\r\n    uuid.noConflict = function() {\r\n      _global.Mycroft = _previousRoot;\r\n      return Mycroft;\r\n    };\r\n\r\n    _global.Mycroft = Mycroft;\r\n  }\r\n}).call(this);","/**\r\n * Functions that are used in several benchmark tests\r\n */\r\n\r\nvar customUtils = require('../lib/customUtils')\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , Datastore = require('../lib/datastore')\r\n  , Persistence = require('../lib/persistence')\r\n  , executeAsap   // process.nextTick or setImmediate depending on your Node version\r\n  ;\r\n\r\ntry {\r\n  executeAsap = setImmediate;\r\n} catch (e) {\r\n  executeAsap = process.nextTick;\r\n}\r\n\r\n\r\n/**\r\n * Configure the benchmark\r\n */\r\nmodule.exports.getConfiguration = function (benchDb) {\r\n  var d, n\r\n    , program = require('commander')\r\n    ;\r\n\r\n  program\r\n    .option('-n --number [number]', 'Size of the collection to test on', parseInt)\r\n    .option('-i --with-index', 'Use an index')\r\n    .option('-m --in-memory', 'Test with an in-memory only store')\r\n    .parse(process.argv);\r\n\r\n  n = program.number || 10000;\r\n\r\n  console.log(\"----------------------------\");\r\n  console.log(\"Test with \" + n + \" documents\");\r\n  console.log(program.withIndex ? \"Use an index\" : \"Don't use an index\");\r\n  console.log(program.inMemory ? \"Use an in-memory datastore\" : \"Use a persistent datastore\");\r\n  console.log(\"----------------------------\");\r\n\r\n  d = new Datastore({ filename: benchDb\r\n                    , inMemoryOnly: program.inMemory\r\n                    });\r\n\r\n  return { n: n, d: d, program: program };\r\n};\r\n\r\n\r\n/**\r\n * Ensure the workspace exists and the db datafile is empty\r\n */\r\nmodule.exports.prepareDb = function (filename, cb) {\r\n  Persistence.ensureDirectoryExists(path.dirname(filename), function () {\r\n    fs.exists(filename, function (exists) {\r\n      if (exists) {\r\n        fs.unlink(filename, cb);\r\n      } else { return cb(); }\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Return an array with the numbers from 0 to n-1, in a random order\r\n * Uses Fisher Yates algorithm\r\n * Useful to get fair tests\r\n */\r\nfunction getRandomArray (n) {\r\n  var res = []\r\n    , i, j, temp\r\n    ;\r\n\r\n  for (i = 0; i < n; i += 1) { res[i] = i; }\r\n\r\n  for (i = n - 1; i >= 1; i -= 1) {\r\n    j = Math.floor((i + 1) * Math.random());\r\n    temp = res[i];\r\n    res[i] = res[j];\r\n    res[j] = temp;\r\n  }\r\n\r\n  return res;\r\n};\r\nmodule.exports.getRandomArray = getRandomArray;\r\n\r\n\r\n/**\r\n * Insert a certain number of documents for testing\r\n */\r\nmodule.exports.insertDocs = function (d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step('Begin inserting ' + n + ' docs');\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (insert) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished inserting ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    d.insert({ docNumber: order[i] }, function (err) {\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Find documents with find\r\n */\r\nmodule.exports.findDocs = function (d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step(\"Finding \" + n + \" documents\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (find) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished finding ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    d.find({ docNumber: order[i] }, function (err, docs) {\r\n      if (docs.length !== 1 || docs[0].docNumber !== order[i]) { return cb('One find didnt work'); }\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Find documents with find and the $in operator\r\n */\r\nmodule.exports.findDocsWithIn = function (d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    , ins = [], i, j\r\n    , arraySize = Math.min(10, n)   // The array for $in needs to be smaller than n (inclusive)\r\n    ;\r\n\r\n  // Preparing all the $in arrays, will take some time\r\n  for (i = 0; i < n; i += 1) {\r\n    ins[i] = [];\r\n    \r\n    for (j = 0; j < arraySize; j += 1) {\r\n      ins[i].push((i + j) % n);\r\n    }\r\n  }\r\n      \r\n  profiler.step(\"Finding \" + n + \" documents WITH $IN OPERATOR\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (find with in selector) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished finding ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    d.find({ docNumber: { $in: ins[i] } }, function (err, docs) {\r\n      if (docs.length !== arraySize) { return cb('One find didnt work'); }\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Find documents with findOne\r\n */\r\nmodule.exports.findOneDocs = function (d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step(\"FindingOne \" + n + \" documents\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (findOne) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished finding ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    d.findOne({ docNumber: order[i] }, function (err, doc) {\r\n      if (!doc || doc.docNumber !== order[i]) { return cb('One find didnt work'); }\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Update documents\r\n * options is the same as the options object for update\r\n */\r\nmodule.exports.updateDocs = function (options, d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step(\"Updating \" + n + \" documents\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (update) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished updating ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    // Will not actually modify the document but will take the same time\r\n    d.update({ docNumber: order[i] }, { docNumber: order[i] }, options, function (err, nr) {\r\n      if (err) { return cb(err); }\r\n      if (nr !== 1) { return cb('One update didnt work'); }\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Remove documents\r\n * options is the same as the options object for update\r\n */\r\nmodule.exports.removeDocs = function (options, d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step(\"Removing \" + n + \" documents\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT (1 remove + 1 insert) ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      console.log(\"====== IMPORTANT: Please note that this is the time that was needed to perform \" + n + \" removes and \" + n + \" inserts\");\r\n      console.log(\"====== The extra inserts are needed to keep collection size at \" + n + \" items for the benchmark to make sense\");\r\n      console.log(\"====== Use the insert speed logged above to calculate the actual remove speed, which is higher (should be significantly so if you use indexing)\");\r\n      profiler.step('Finished removing ' + n + ' docs');\r\n      return cb();\r\n    }\r\n\r\n    d.remove({ docNumber: order[i] }, options, function (err, nr) {\r\n      if (err) { return cb(err); }\r\n      if (nr !== 1) { return cb('One remove didnt work'); }\r\n      d.insert({ docNumber: order[i] }, function (err) {   // We need to reinsert the doc so that we keep the collection's size at n\r\n                                                           // So actually we're calculating the average time taken by one insert + one remove\r\n        executeAsap(function () {\r\n          runFrom(i + 1);\r\n        });\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n/**\r\n * Load database\r\n */\r\nmodule.exports.loadDatabase = function (d, n, profiler, cb) {\r\n  var beg = new Date()\r\n    , order = getRandomArray(n)\r\n    ;\r\n\r\n  profiler.step(\"Loading the database \" + n + \" times\");\r\n\r\n  function runFrom(i) {\r\n    if (i === n) {   // Finished\r\n      console.log(\"===== RESULT ===== \" + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + \" ops/s\");\r\n      profiler.step('Finished loading a database' + n + ' times');\r\n      return cb();\r\n    }\r\n\r\n    d.loadDatabase(function (err) {\r\n      executeAsap(function () {\r\n        runFrom(i + 1);\r\n      });\r\n    });\r\n  }\r\n  runFrom(0);\r\n};\r\n\r\n\r\n\r\n\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/insert.bench.db'\r\n  , async = require('async')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('INSERT BENCH')\r\n  , d = new Datastore(benchDb)\r\n  , program = require('commander')\r\n  , n\r\n  ;\r\n\r\nprogram\r\n  .option('-n --number [number]', 'Size of the collection to test on', parseInt)\r\n  .option('-i --with-index', 'Test with an index')\r\n  .parse(process.argv);\r\n\r\nn = program.number || 10000;\r\n\r\nconsole.log(\"----------------------------\");\r\nconsole.log(\"Test with \" + n + \" documents\");\r\nconsole.log(\"----------------------------\");\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, function (cb) {\r\n    var i;\r\n\r\n    profiler.step('Begin calling ensureIndex ' + n + ' times');\r\n\r\n    for (i = 0; i < n; i += 1) {\r\n      d.ensureIndex({ fieldName: 'docNumber' });\r\n      delete d.indexes.docNumber;\r\n    }\r\n\r\n    console.log(\"Average time for one ensureIndex: \" + (profiler.elapsedSinceLastStep() / n) + \"ms\");\r\n    profiler.step('Finished calling ensureIndex ' + n + ' times');\r\n  }\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/find.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('FIND BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) { d.ensureIndex({ fieldName: 'docNumber' }); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, async.apply(commonUtilities.findDocs, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/findOne.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('FINDONE BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) { d.ensureIndex({ fieldName: 'docNumber' }); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, function (cb) { setTimeout(function () {cb();}, 500); }\r\n, async.apply(commonUtilities.findOneDocs, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/find.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('FIND BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) { d.ensureIndex({ fieldName: 'docNumber' }); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, async.apply(commonUtilities.findDocsWithIn, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/insert.bench.db'\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('INSERT BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) {\r\n        d.ensureIndex({ fieldName: 'docNumber' });\r\n        n = 2 * n;   // We will actually insert twice as many documents\r\n                     // because the index is slower when the collection is already\r\n                     // big. So the result given by the algorithm will be a bit worse than\r\n                     // actual performance\r\n      }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/loaddb.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('LOADDB BENCH')\r\n  , d = new Datastore(benchDb)\r\n  , program = require('commander')\r\n  , n\r\n  ;\r\n\r\nprogram\r\n  .option('-n --number [number]', 'Size of the collection to test on', parseInt)\r\n  .option('-i --with-index', 'Test with an index')\r\n  .parse(process.argv);\r\n\r\nn = program.number || 10000;\r\n\r\nconsole.log(\"----------------------------\");\r\nconsole.log(\"Test with \" + n + \" documents\");\r\nconsole.log(program.withIndex ? \"Use an index\" : \"Don't use an index\");\r\nconsole.log(\"----------------------------\");\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(cb);\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, async.apply(commonUtilities.loadDatabase, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/remove.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('REMOVE BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) { d.ensureIndex({ fieldName: 'docNumber' }); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n\r\n// Test with remove only one document\r\n, function (cb) { profiler.step('MULTI: FALSE'); return cb(); }\r\n, async.apply(commonUtilities.removeDocs, { multi: false }, d, n, profiler)\r\n\r\n// Test with multiple documents\r\n, function (cb) { d.remove({}, { multi: true }, function () { return cb(); }); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, function (cb) { profiler.step('MULTI: TRUE'); return cb(); }\r\n, async.apply(commonUtilities.removeDocs, { multi: true }, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","var Datastore = require('../lib/datastore')\r\n  , benchDb = 'workspace/update.bench.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , async = require('async')\r\n  , execTime = require('exec-time')\r\n  , profiler = new execTime('UPDATE BENCH')\r\n  , commonUtilities = require('./commonUtilities')\r\n  , config = commonUtilities.getConfiguration(benchDb)\r\n  , d = config.d\r\n  , n = config.n\r\n  ;\r\n\r\nasync.waterfall([\r\n  async.apply(commonUtilities.prepareDb, benchDb)\r\n, function (cb) {\r\n    d.loadDatabase(function (err) {\r\n      if (err) { return cb(err); }\r\n      if (config.program.withIndex) { d.ensureIndex({ fieldName: 'docNumber' }); }\r\n      cb();\r\n    });\r\n  }\r\n, function (cb) { profiler.beginProfiling(); return cb(); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n\r\n// Test with update only one document\r\n, function (cb) { profiler.step('MULTI: FALSE'); return cb(); }\r\n, async.apply(commonUtilities.updateDocs, { multi: false }, d, n, profiler)\r\n\r\n// Test with multiple documents\r\n, function (cb) { d.remove({}, { multi: true }, function (err) { return cb(); }); }\r\n, async.apply(commonUtilities.insertDocs, d, n, profiler)\r\n, function (cb) { profiler.step('MULTI: TRUE'); return cb(); }\r\n, async.apply(commonUtilities.updateDocs, { multi: true }, d, n, profiler)\r\n], function (err) {\r\n  profiler.step(\"Benchmark finished\");\r\n\r\n  if (err) { return console.log(\"An error was encountered: \", err); }\r\n});\r\n","/**\r\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\r\n */\r\n\r\n/**\r\n * Taken from the crypto-browserify module\r\n * https://github.com/dominictarr/crypto-browserify\r\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\r\n */\r\nfunction randomBytes (size) {\r\n  var bytes = new Array(size);\r\n  var r;\r\n\r\n  for (var i = 0, r; i < size; i++) {\r\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\r\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\n\r\n/**\r\n * Taken from the base64-js module\r\n * https://github.com/beatgammit/base64-js/\r\n */\r\nfunction byteArrayToBase64 (uint8) {\r\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n    , extraBytes = uint8.length % 3   // if we have 1 byte left, pad 2 bytes\r\n    , output = \"\"\r\n    , temp, length, i;\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\r\n  };\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\r\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\r\n    output += tripletToBase64(temp);\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  switch (extraBytes) {\r\n    case 1:\r\n      temp = uint8[uint8.length - 1];\r\n      output += lookup[temp >> 2];\r\n      output += lookup[(temp << 4) & 0x3F];\r\n      output += '==';\r\n      break;\r\n    case 2:\r\n      temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\r\n      output += lookup[temp >> 10];\r\n      output += lookup[(temp >> 4) & 0x3F];\r\n      output += lookup[(temp << 2) & 0x3F];\r\n      output += '=';\r\n      break;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n\r\n/**\r\n * Return a random alphanumerical string of length len\r\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\r\n * (il the base64 conversion yields too many pluses and slashes) but\r\n * that's not an issue here\r\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\r\n * See http://en.wikipedia.org/wiki/Birthday_problem\r\n */\r\nfunction uid (len) {\r\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\r\n}\r\n\r\n\r\n\r\nmodule.exports.uid = uid;\r\n","/**\r\n * Handle every persistence-related task\r\n * The interface Datastore expects to be implemented is\r\n * * Persistence.loadDatabase(callback) and callback has signature err\r\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\r\n *\r\n * Shim for the browser\r\n */\r\n\r\n/**\r\n * Create a new Persistence object for database options.db\r\n * For now, no browser persistence supported, in-memory only mode forced\r\n * @param {Datastore} options.db\r\n */\r\nfunction Persistence (options) {\r\n  this.db = options.db;\r\n  this.db.inMemoryOnly = true;\r\n  this.db.filename = null;\r\n  this.inMemoryOnly = true;\r\n};\r\n\r\n\r\n/**\r\n * No persistence in the browser (for now)\r\n */\r\nPersistence.prototype.persistNewState = function (newDocs, cb) {\r\n  if (cb) { return cb(); }\r\n};\r\n\r\n\r\n/**\r\n * No persistence in the browser (for now)\r\n */\r\nPersistence.prototype.loadDatabase = function (cb) {\r\n  if (cb) { return cb(); }\r\n};\r\n\r\n\r\n// Interface\r\nmodule.exports = Persistence;\r\n","/**\r\n * Build the browser version of nedb\r\n */\r\n\r\nvar fs = require('fs')\r\n  , path = require('path')\r\n  , child_process = require('child_process')\r\n  , toCopy = ['lib', 'node_modules']\r\n  , async, browserify, uglify\r\n  ;\r\n\r\n// Ensuring both node_modules (the source one and build one), src and out directories exist\r\nfunction ensureDirExists (name) {\r\n  try {\r\n    fs.mkdirSync(path.join(__dirname, name));\r\n  } catch (e) {\r\n    if (e.code !== 'EEXIST') {\r\n      console.log(\"Error ensuring that node_modules exists\");\r\n      process.exit(1);\r\n    }\r\n  }\r\n}\r\nensureDirExists('../node_modules');\r\nensureDirExists('node_modules');\r\nensureDirExists('out');\r\nensureDirExists('src');\r\n\r\n\r\n// Installing build dependencies and require them\r\nconsole.log(\"Installing build dependencies\");\r\nchild_process.exec('npm install', { cwd: __dirname }, function (err, stdout, stderr) {\r\n  if (err) { console.log(\"Error reinstalling dependencies\"); process.exit(1); }\r\n\r\n  fs = require('fs-extra');\r\n  async = require('async');\r\n  browserify = require('browserify');\r\n  uglify = require('uglify-js');\r\n\r\n  async.waterfall([\r\n  function (cb) {\r\n    console.log(\"Installing source dependencies if needed\");\r\n\r\n    child_process.exec('npm install', { cwd: path.join(__dirname, '..') }, function (err) { return cb(err); });\r\n  }\r\n  , function (cb) {\r\n    console.log(\"Removing contents of the src directory\");\r\n\r\n    async.eachSeries(fs.readdirSync(path.join(__dirname, 'src')), function (item, _cb) {\r\n      fs.remove(path.join(__dirname, 'src', item), _cb);\r\n    }, cb);\r\n  }\r\n  , function (cb) {\r\n    console.log(\"Copying source files\");\r\n\r\n    async.eachSeries(toCopy, function (item, _cb) {\r\n      fs.copy(path.join(__dirname, '..', item), path.join(__dirname, 'src', item), _cb);\r\n    }, cb);\r\n  }\r\n  , function (cb) {\r\n    console.log(\"Copying browser specific files to replace their server-specific counterparts\");\r\n\r\n    async.eachSeries(fs.readdirSync(path.join(__dirname, 'browser-specific')), function (item, _cb) {\r\n      fs.copy(path.join(__dirname, 'browser-specific', item), path.join(__dirname, 'src', item), _cb);\r\n    }, cb);\r\n  }\r\n  , function (cb) {\r\n    console.log(\"Browserifying the code\");\r\n\r\n    var b = browserify()\r\n      , srcPath = path.join(__dirname, 'src/lib/datastore.js');\r\n\r\n    b.add(srcPath);\r\n    b.bundle({ standalone: 'Nedb' }, function (err, out) {\r\n      if (err) { return cb(err); }\r\n      fs.writeFile(path.join(__dirname, 'out/nedb.js'), out, 'utf8', function (err) {\r\n        if (err) {\r\n          return cb(err);\r\n        } else {\r\n          return cb(null, out);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  , function (out, cb) {\r\n      console.log(\"Creating the minified version\");\r\n\r\n      var compressedCode = uglify.minify(out, { fromString: true });\r\n      fs.writeFile(path.join(__dirname, 'out/nedb.min.js'), compressedCode.code, 'utf8', cb);\r\n  }\r\n  ], function (err) {\r\n    if (err) {\r\n      console.log(\"Error during build\");\r\n      console.log(err);\r\n    } else {\r\n      console.log(\"Build finished with success\");\r\n    }\r\n  });\r\n});\r\n\r\n\r\n\r\n","(function(e){if(\"function\"==typeof bootstrap)bootstrap(\"nedb\",e);else if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else if(\"undefined\"!=typeof ses){if(!ses.ok())return;ses.makeNedb=e}else\"undefined\"!=typeof window?window.Nedb=e():global.Nedb=e()})(function(){var define,ses,bootstrap,module,exports;\nreturn (function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require==\"function\"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error(\"Cannot find module '\"+n+\"'\")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require==\"function\"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\nvar process=require(\"__browserify_process\");if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === 'function')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n},{\"__browserify_process\":3}],2:[function(require,module,exports){\nvar events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\u001b[' + styles[style][0] + 'm' + str +\n             '\\u001b[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && Object.prototype.toString.call(ar) === '[object Array]');\n}\n\n\nfunction isRegExp(re) {\n  typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]';\n}\n\n\nfunction isDate(d) {\n  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{\"events\":1}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],4:[function(require,module,exports){\n/**\r\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\r\n */\r\n\r\n/**\r\n * Taken from the crypto-browserify module\r\n * https://github.com/dominictarr/crypto-browserify\r\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\r\n */\r\nfunction randomBytes (size) {\r\n  var bytes = new Array(size);\r\n  var r;\r\n\r\n  for (var i = 0, r; i < size; i++) {\r\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\r\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\n\r\n/**\r\n * Taken from the base64-js module\r\n * https://github.com/beatgammit/base64-js/\r\n */\r\nfunction byteArrayToBase64 (uint8) {\r\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n    , extraBytes = uint8.length % 3   // if we have 1 byte left, pad 2 bytes\r\n    , output = \"\"\r\n    , temp, length, i;\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\r\n  };\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\r\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\r\n    output += tripletToBase64(temp);\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  switch (extraBytes) {\r\n    case 1:\r\n      temp = uint8[uint8.length - 1];\r\n      output += lookup[temp >> 2];\r\n      output += lookup[(temp << 4) & 0x3F];\r\n      output += '==';\r\n      break;\r\n    case 2:\r\n      temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\r\n      output += lookup[temp >> 10];\r\n      output += lookup[(temp >> 4) & 0x3F];\r\n      output += lookup[(temp << 2) & 0x3F];\r\n      output += '=';\r\n      break;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n\r\n/**\r\n * Return a random alphanumerical string of length len\r\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\r\n * (il the base64 conversion yields too many pluses and slashes) but\r\n * that's not an issue here\r\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\r\n * See http://en.wikipedia.org/wiki/Birthday_problem\r\n */\r\nfunction uid (len) {\r\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\r\n}\r\n\r\n\r\n\r\nmodule.exports.uid = uid;\r\n\n},{}],5:[function(require,module,exports){\nvar customUtils = require('./customUtils')\r\n  , model = require('./model')\r\n  , async = require('async')\r\n  , Executor = require('./executor')\r\n  , Index = require('./indexes')\r\n  , util = require('util')\r\n  , _ = require('underscore')\r\n  , Persistence = require('./persistence')\r\n  ;\r\n\r\n\r\n/**\r\n * Create a new collection\r\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\r\n * @param {Boolean} options.inMemoryOnly Optional, default to false\r\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\r\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\r\n * @param {Boolean} options.autoload Optional, defaults to false\r\n */\r\nfunction Datastore (options) {\r\n  var filename;\r\n\r\n  // Retrocompatibility with v0.6 and before\r\n  if (typeof options === 'string') {\r\n    filename = options;\r\n    this.inMemoryOnly = false;   // Default\r\n  } else {\r\n    options = options || {};\r\n    filename = options.filename;\r\n    this.inMemoryOnly = options.inMemoryOnly || false;\r\n    this.autoload = options.autoload || false;\r\n  }\r\n\r\n  // Determine whether in memory or persistent\r\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\r\n    this.filename = null;\r\n    this.inMemoryOnly = true;\r\n  } else {\r\n    this.filename = filename;\r\n  }\r\n\r\n  // Persistence handling\r\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName });\r\n\r\n  // This new executor is ready if we don't use persistence\r\n  // If we do, it will only be ready once loadDatabase is called\r\n  this.executor = new Executor();\r\n  if (this.inMemoryOnly) { this.executor.ready = true; }\r\n\r\n  // Indexed by field name, dot notation can be used\r\n  // _id is always indexed and since _ids are generated randomly the underlying\r\n  // binary is always well-balanced\r\n  this.indexes = {};\r\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\r\n  \r\n  if (this.autoload) { this.loadDatabase(); }\r\n}\r\n\r\n\r\n/**\r\n * Load the database from the datafile, and trigger the execution of buffered commands if any\r\n */\r\nDatastore.prototype.loadDatabase = function () {\r\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\r\n};\r\n\r\n\r\n/**\r\n * Get an array of all the data in the database\r\n */\r\nDatastore.prototype.getAllData = function () {\r\n  return this.indexes._id.getAll();\r\n};\r\n\r\n\r\n/**\r\n * Reset all currently defined indexes\r\n */\r\nDatastore.prototype.resetIndexes = function (newData) {\r\n  var self = this;\r\n\r\n  Object.keys(this.indexes).forEach(function (i) {\r\n    self.indexes[i].reset(newData);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Ensure an index is kept for this field. Same parameters as lib/indexes\r\n * For now this function is synchronous, we need to test how much time it takes\r\n * We use an async API for consistency with the rest of the code\r\n * @param {String} options.fieldName\r\n * @param {Boolean} options.unique\r\n * @param {Boolean} options.sparse\r\n * @param {Function} cb Optional callback, signature: err\r\n */\r\nDatastore.prototype.ensureIndex = function (options, cb) {\r\n  var callback = cb || function () {};\r\n\r\n  options = options || {};\r\n\r\n  if (!options.fieldName) { return callback({ missingFieldName: true }); }\r\n  if (this.indexes[options.fieldName]) { return callback(null); }\r\n\r\n  this.indexes[options.fieldName] = new Index(options);\r\n\r\n  try {\r\n    this.indexes[options.fieldName].insert(this.getAllData());\r\n  } catch (e) {\r\n    delete this.indexes[options.fieldName];\r\n    return callback(e);\r\n  }\r\n\r\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Remove an index\r\n * @param {String} fieldName\r\n * @param {Function} cb Optional callback, signature: err \r\n */\r\nDatastore.prototype.removeIndex = function (fieldName, cb) {\r\n  var callback = cb || function () {};\r\n  \r\n  delete this.indexes[fieldName];\r\n  \r\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null);\r\n  });  \r\n};\r\n\r\n\r\n/**\r\n * Add one or several document(s) to all indexes\r\n */\r\nDatastore.prototype.addToIndexes = function (doc) {\r\n  var i, failingIndex, error\r\n    , keys = Object.keys(this.indexes)\r\n    ;\r\n\r\n  for (i = 0; i < keys.length; i += 1) {\r\n    try {\r\n      this.indexes[keys[i]].insert(doc);\r\n    } catch (e) {\r\n      failingIndex = i;\r\n      error = e;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error happened, we need to rollback the insert on all other indexes\r\n  if (error) {\r\n    for (i = 0; i < failingIndex; i += 1) {\r\n      this.indexes[keys[i]].remove(doc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove one or several document(s) from all indexes\r\n */\r\nDatastore.prototype.removeFromIndexes = function (doc) {\r\n  var self = this;\r\n\r\n  Object.keys(this.indexes).forEach(function (i) {\r\n    self.indexes[i].remove(doc);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Update one or several documents in all indexes\r\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\r\n * If one update violates a constraint, all changes are rolled back\r\n */\r\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\r\n  var i, failingIndex, error\r\n    , keys = Object.keys(this.indexes)\r\n    ;\r\n\r\n  for (i = 0; i < keys.length; i += 1) {\r\n    try {\r\n      this.indexes[keys[i]].update(oldDoc, newDoc);\r\n    } catch (e) {\r\n      failingIndex = i;\r\n      error = e;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error happened, we need to rollback the update on all other indexes\r\n  if (error) {\r\n    for (i = 0; i < failingIndex; i += 1) {\r\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Return the list of candidates for a given query\r\n * Crude implementation for now, we return the candidates given by the first usable index if any\r\n * We try the following query types, in this order: basic match, $in match, comparison match\r\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\r\n * returns too much data. I may do it in the future.\r\n */\r\nDatastore.prototype.getCandidates = function (query) {\r\n  var indexNames = Object.keys(this.indexes)\r\n    , usableQueryKeys;\r\n\r\n  // For a basic match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]);\r\n  }\r\n\r\n  // For a $in match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (query[k] && query[k].hasOwnProperty('$in')) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in);\r\n  }\r\n\r\n  // For a comparison match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]);\r\n  }\r\n\r\n  // By default, return all the DB data\r\n  return this.getAllData();\r\n};\r\n\r\n\r\n/**\r\n * Insert a new document\r\n * @param {Function} cb Optional callback, signature: err, insertedDoc\r\n *\r\n * @api private Use Datastore.insert which has the same signature\r\n */\r\nDatastore.prototype._insert = function (newDoc, cb) {\r\n  var callback = cb || function () {}\r\n    ;\r\n\r\n  try {\r\n    this._insertInCache(newDoc);\r\n  } catch (e) {\r\n    return callback(e);\r\n  }\r\n\r\n  this.persistence.persistNewState(util.isArray(newDoc) ? newDoc : [newDoc], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null, newDoc);\r\n  });\r\n};\r\n\r\n/**\r\n * Prepare a document (or array of documents) to be inserted in a database\r\n * @api private\r\n */\r\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\r\n  var preparedDoc, self = this;\r\n\r\n  if (util.isArray(newDoc)) {\r\n    preparedDoc = [];\r\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\r\n  } else {\r\n    newDoc._id = customUtils.uid(16);\r\n    preparedDoc = model.deepCopy(newDoc);\r\n    model.checkObject(preparedDoc);\r\n  }\r\n  \r\n  return preparedDoc;\r\n};\r\n\r\n/**\r\n * If newDoc is an array of documents, this will insert all documents in the cache\r\n * @api private\r\n */\r\nDatastore.prototype._insertInCache = function (newDoc) {\r\n  if (util.isArray(newDoc)) {\r\n    this._insertMultipleDocsInCache(newDoc);\r\n  } else {\r\n    this.addToIndexes(this.prepareDocumentForInsertion(newDoc));  \r\n  }\r\n};\r\n\r\n/**\r\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\r\n * inserts and throws the error\r\n * @api private\r\n */\r\nDatastore.prototype._insertMultipleDocsInCache = function (newDocs) {\r\n  var i, failingI, error\r\n    , preparedDocs = this.prepareDocumentForInsertion(newDocs)\r\n    ;\r\n  \r\n  for (i = 0; i < preparedDocs.length; i += 1) {\r\n    try {\r\n      this.addToIndexes(preparedDocs[i]);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.removeFromIndexes(preparedDocs[i]);\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n};\r\n\r\nDatastore.prototype.insert = function () {\r\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\r\n};\r\n\r\n/**\r\n * Count all documents matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use count\r\n */\r\nDatastore.prototype._count = function(query, callback) {\r\n  var res = 0\r\n    , self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        res++;\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, res);\r\n}\r\n\r\nDatastore.prototype.count = function() {\r\n    this.executor.push({this: this, fn: this._count, arguments: arguments });\r\n}\r\n\r\n/**\r\n * Find all documents matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use find\r\n */\r\nDatastore.prototype._find = function (query, callback) {\r\n  var res = []\r\n    , self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        res.push(model.deepCopy(candidates[i]));\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, res);\r\n};\r\n\r\nDatastore.prototype.find = function () {\r\n  this.executor.push({ this: this, fn: this._find, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Find one document matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use findOne\r\n */\r\nDatastore.prototype._findOne = function (query, callback) {\r\n  var self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i, found = null\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        found = model.deepCopy(candidates[i]);\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, found);\r\n};\r\n\r\nDatastore.prototype.findOne = function () {\r\n  this.executor.push({ this: this, fn: this._findOne, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Update all docs matching query\r\n * For now, very naive implementation (recalculating the whole database)\r\n * @param {Object} query\r\n * @param {Object} updateQuery\r\n * @param {Object} options Optional options\r\n *                 options.multi If true, can update multiple documents (defaults to false)\r\n *                 options.upsert If true, document is inserted if the query doesn't match anything\r\n * @param {Function} cb Optional callback, signature: err, numReplaced, upsert (set to true if the update was in fact an upsert)\r\n *\r\n * @api private Use Datastore.update which has the same signature\r\n */\r\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\r\n  var callback\r\n    , self = this\r\n    , numReplaced = 0\r\n    , multi, upsert\r\n    , i\r\n    ;\r\n\r\n  if (typeof options === 'function') { cb = options; options = {}; }\r\n  callback = cb || function () {};\r\n  multi = options.multi !== undefined ? options.multi : false;\r\n  upsert = options.upsert !== undefined ? options.upsert : false;\r\n\r\n  async.waterfall([\r\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\r\n    if (!upsert) { return cb(); }\r\n\r\n    self._findOne(query, function (err, doc) {\r\n      if (err) { return callback(err); }\r\n      if (doc) {\r\n        return cb();\r\n      } else {\r\n        // The upserted document is the query (since for now queries have the same structure as\r\n        // documents), modified by the updateQuery\r\n        return self._insert(model.modify(query, updateQuery), function (err) {\r\n          if (err) { return callback(err); }\r\n          return callback(null, 1, true);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  , function () {   // Perform the update\r\n    var modifiedDoc\r\n\t  , candidates = self.getCandidates(query)\r\n\t  , modifications = []\r\n\t  ;\r\n\r\n\t// Preparing update (if an error is thrown here neither the datafile nor\r\n\t// the in-memory indexes are affected)\r\n    try {\r\n      for (i = 0; i < candidates.length; i += 1) {\r\n        if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\r\n          numReplaced += 1;\r\n          modifiedDoc = model.modify(candidates[i], updateQuery);\r\n          modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\r\n        }\r\n      }\r\n    } catch (err) {\r\n      return callback(err);\r\n    }\r\n\t\r\n\t// Change the docs in memory\r\n\ttry {\r\n      self.updateIndexes(modifications);\r\n\t} catch (err) {\r\n\t  return callback(err);\r\n\t}\r\n\r\n\t// Update the datafile\r\n    self.persistence.persistNewState(_.pluck(modifications, 'newDoc'), function (err) {\r\n      if (err) { return callback(err); }\r\n      return callback(null, numReplaced);\r\n    });\r\n  }\r\n  ]);\r\n};\r\nDatastore.prototype.update = function () {\r\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Remove all docs matching the query\r\n * For now very naive implementation (similar to update)\r\n * @param {Object} query\r\n * @param {Object} options Optional options\r\n *                 options.multi If true, can update multiple documents (defaults to false)\r\n * @param {Function} cb Optional callback, signature: err, numRemoved\r\n *\r\n * @api private Use Datastore.remove which has the same signature\r\n */\r\nDatastore.prototype._remove = function (query, options, cb) {\r\n  var callback\r\n    , self = this\r\n    , numRemoved = 0\r\n    , multi\r\n    , removedDocs = []\r\n    , candidates = this.getCandidates(query)\r\n    ;\r\n\r\n  if (typeof options === 'function') { cb = options; options = {}; }\r\n  callback = cb || function () {};\r\n  multi = options.multi !== undefined ? options.multi : false;\r\n\r\n  try {\r\n    candidates.forEach(function (d) {\r\n      if (model.match(d, query) && (multi || numRemoved === 0)) {\r\n        numRemoved += 1;\r\n        removedDocs.push({ $$deleted: true, _id: d._id });\r\n        self.removeFromIndexes(d);\r\n      }\r\n    });\r\n  } catch (err) { return callback(err); }\r\n\r\n  self.persistence.persistNewState(removedDocs, function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null, numRemoved);\r\n  });\r\n};\r\nDatastore.prototype.remove = function () {\r\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\r\n};\r\n\r\n\r\nmodule.exports = Datastore;\n},{\"./customUtils\":4,\"./executor\":6,\"./indexes\":7,\"./model\":8,\"./persistence\":9,\"async\":10,\"underscore\":15,\"util\":2}],6:[function(require,module,exports){\n/**\r\n * Responsible for sequentially executing actions on the database\r\n */\r\n\r\nvar async = require('async')\r\n  ;\r\n\r\nfunction Executor () {\r\n  this.buffer = [];\r\n  this.ready = false;\r\n\r\n  // This queue will execute all commands, one-by-one in order\r\n  this.queue = async.queue(function (task, cb) {\r\n    var callback\r\n      , lastArg = task.arguments[task.arguments.length - 1]\r\n      , i, newArguments = []\r\n      ;\r\n\r\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\r\n    for (i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\r\n\r\n    // Always tell the queue task is complete. Execute callback if any was given.\r\n    if (typeof lastArg === 'function') {\r\n      callback = function () {\r\n        lastArg.apply(null, arguments);\r\n        cb();\r\n      };\r\n\r\n      newArguments[newArguments.length - 1] = callback;\r\n    } else {\r\n      callback = function () { cb(); };\r\n      newArguments.push(callback);\r\n    }\r\n\r\n\r\n    task.fn.apply(task.this, newArguments);\r\n  }, 1);\r\n}\r\n\r\n\r\n/**\r\n * If executor is ready, queue task (and process it immediately if executor was idle)\r\n * If not, buffer task for later processing\r\n * @param {Object} task\r\n *                 task.this - Object to use as this\r\n *                 task.fn - Function to execute\r\n *                 task.arguments - Array of arguments\r\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\r\n */\r\nExecutor.prototype.push = function (task, forceQueuing) {\r\n  if (this.ready || forceQueuing) {\r\n    this.queue.push(task);\r\n  } else {\r\n    this.buffer.push(task);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Queue all tasks in buffer (in the same order they came in)\r\n * Automatically sets executor as ready\r\n */\r\nExecutor.prototype.processBuffer = function () {\r\n  var i;\r\n  this.ready = true;\r\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\r\n  this.buffer = [];\r\n};\r\n\r\n\r\n\r\n// Interface\r\nmodule.exports = Executor;\r\n\n},{\"async\":10}],7:[function(require,module,exports){\nvar BinarySearchTree = require('binary-search-tree').AVLTree\r\n  , model = require('./model')\r\n  , _ = require('underscore')\r\n  , util = require('util')\r\n  ;\r\n\r\n/**\r\n * Two indexed pointers are equal iif they point to the same place\r\n */\r\nfunction checkValueEquality (a, b) {\r\n  return a === b;\r\n}\r\n\r\n/**\r\n * Type-aware projection\r\n */\r\nfunction projectForUnique (elt) {\r\n  if (elt === null) { return '$null'; }\r\n  if (typeof elt === 'string') { return '$string' + elt; }\r\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\r\n  if (typeof elt === 'number') { return '$number' + elt; }\r\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\r\n  \r\n  return elt;   // Arrays and objects, will check for pointer equality\r\n}\r\n\r\n\r\n/**\r\n * Create a new index\r\n * All methods on an index guarantee that either the whole operation was successful and the index changed\r\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\r\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\r\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\r\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\r\n */\r\nfunction Index (options) {\r\n  this.fieldName = options.fieldName;\r\n  this.unique = options.unique || false;\r\n  this.sparse = options.sparse || false;\r\n\r\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\r\n\r\n  this.reset();   // No data in the beginning\r\n}\r\n\r\n\r\n/**\r\n * Reset an index\r\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\r\n *                                                 If an error is thrown during insertion, the index is not modified\r\n */\r\nIndex.prototype.reset = function (newData) {\r\n  this.tree = new BinarySearchTree(this.treeOptions);\r\n\r\n  if (newData) { this.insert(newData); }\r\n};\r\n\r\n\r\n/**\r\n * Insert a new document in the index\r\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\r\n * O(log(n))\r\n */\r\nIndex.prototype.insert = function (doc) {\r\n  var key, self = this\r\n    , keys, i, failingI, error\r\n    ;\r\n\r\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\r\n\r\n  key = model.getDotValue(doc, this.fieldName);\r\n\r\n  // We don't index documents that don't contain the field if the index is sparse\r\n  if (key === undefined && this.sparse) { return; }\r\n\r\n  if (!util.isArray(key)) {\r\n    this.tree.insert(key, doc);\r\n  } else {\r\n    // If an insert fails due to a unique constraint, roll back all inserts before it\r\n    keys = _.uniq(key, projectForUnique);\r\n\r\n    for (i = 0; i < keys.length; i += 1) {\r\n      try {\r\n        this.tree.insert(keys[i], doc);\r\n      } catch (e) {\r\n        error = e;\r\n        failingI = i;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (error) {\r\n      for (i = 0; i < failingI; i += 1) {\r\n        this.tree.delete(keys[i], doc);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Insert an array of documents in the index\r\n * If a constraint is violated, the changes should be rolled back and an error thrown\r\n *\r\n * @API private\r\n */\r\nIndex.prototype.insertMultipleDocs = function (docs) {\r\n  var i, error, failingI;\r\n\r\n  for (i = 0; i < docs.length; i += 1) {\r\n    try {\r\n      this.insert(docs[i]);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.remove(docs[i]);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove a document from the index\r\n * If an array is passed, we remove all its elements\r\n * The remove operation is safe with regards to the 'unique' constraint\r\n * O(log(n))\r\n */\r\nIndex.prototype.remove = function (doc) {\r\n  var key, self = this;\r\n\r\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\r\n\r\n  key = model.getDotValue(doc, this.fieldName);\r\n\r\n  if (key === undefined && this.sparse) { return; }\r\n\r\n  if (!util.isArray(key)) {\r\n    this.tree.delete(key, doc);\r\n  } else {\r\n    _.uniq(key, projectForUnique).forEach(function (_key) {\r\n      self.tree.delete(_key, doc);\r\n    });\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Update a document in the index\r\n * If a constraint is violated, changes are rolled back and an error thrown\r\n * Naive implementation, still in O(log(n))\r\n */\r\nIndex.prototype.update = function (oldDoc, newDoc) {\r\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\r\n\r\n  this.remove(oldDoc);\r\n\r\n  try {\r\n    this.insert(newDoc);\r\n  } catch (e) {\r\n    this.insert(oldDoc);\r\n    throw e;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Update multiple documents in the index\r\n * If a constraint is violated, the changes need to be rolled back\r\n * and an error thrown\r\n * @param {Array of oldDoc, newDoc pairs} pairs\r\n *\r\n * @API private\r\n */\r\nIndex.prototype.updateMultipleDocs = function (pairs) {\r\n  var i, failingI, error;\r\n\r\n  for (i = 0; i < pairs.length; i += 1) {\r\n    this.remove(pairs[i].oldDoc);\r\n  }\r\n\r\n  for (i = 0; i < pairs.length; i += 1) {\r\n    try {\r\n      this.insert(pairs[i].newDoc);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error was raised, roll back changes in the inverse order\r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.remove(pairs[i].newDoc);\r\n    }\r\n\r\n    for (i = 0; i < pairs.length; i += 1) {\r\n      this.insert(pairs[i].oldDoc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Revert an update\r\n */\r\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\r\n  var revert = [];\r\n\r\n  if (!util.isArray(oldDoc)) {\r\n    this.update(newDoc, oldDoc);\r\n  } else {\r\n    oldDoc.forEach(function (pair) {\r\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\r\n    });\r\n    this.update(revert);\r\n  }\r\n};\r\n\r\n\r\n// Append all elements in toAppend to array\r\nfunction append (array, toAppend) {\r\n  var i;\r\n\r\n  for (i = 0; i < toAppend.length; i += 1) {\r\n    array.push(toAppend[i]);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\r\n * @param {Thing} value Value to match the key against\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getMatching = function (value) {\r\n  var res, self = this;\r\n\r\n  if (!util.isArray(value)) {\r\n    return this.tree.search(value);\r\n  } else {\r\n    res = [];\r\n    value.forEach(function (v) { append(res, self.getMatching(v)); });\r\n    return res;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Get all documents in index whose key is between bounds are they are defined by query\r\n * Documents are sorted by key\r\n * @param {Query} query\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getBetweenBounds = function (query) {\r\n  return this.tree.betweenBounds(query);\r\n};\r\n\r\n\r\n/**\r\n * Get all elements in the index\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getAll = function () {\r\n  var res = [];\r\n\r\n  this.tree.executeOnEveryNode(function (node) {\r\n    var i;\r\n\r\n    for (i = 0; i < node.data.length; i += 1) {\r\n      res.push(node.data[i]);\r\n    }\r\n  });\r\n\r\n  return res;\r\n};\r\n\r\n\r\n\r\n\r\n// Interface\r\nmodule.exports = Index;\r\n\n},{\"./model\":8,\"binary-search-tree\":11,\"underscore\":15,\"util\":2}],8:[function(require,module,exports){\n/**\r\n * Handle models (i.e. docs)\r\n * Serialization/deserialization\r\n * Copying\r\n * Querying, update\r\n */\r\n\r\nvar dateToJSON = function () { return { $$date: this.getTime() }; }\r\n  , originalDateToJSON = Date.prototype.toJSON\r\n  , util = require('util')\r\n  , _ = require('underscore')\r\n  , modifierFunctions = {}\r\n  , lastStepModifierFunctions = {}\r\n  , comparisonFunctions = {}\r\n  , logicalOperators = {}\r\n  , arrayComparisonFunctions = {}\r\n  ;\r\n\r\n\r\n/**\r\n * Check a key, throw an error if the key is non valid\r\n * @param {String} k key\r\n * @param {Model} v value, needed to treat the Date edge case\r\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\r\n * Its serialized-then-deserialized version it will transformed into a Date object\r\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\r\n */\r\nfunction checkKey (k, v) {\r\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {\r\n    throw 'Field names cannot begin with the $ character';\r\n  }\r\n\r\n  if (k.indexOf('.') !== -1) {\r\n    throw 'Field names cannot contain a .';\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Check a DB object and throw an error if it's not valid\r\n * Works by applying the above checkKey function to all fields recursively\r\n */\r\nfunction checkObject (obj) {\r\n  if (util.isArray(obj)) {\r\n    obj.forEach(function (o) {\r\n      checkObject(o);\r\n    });\r\n  }\r\n\r\n  if (typeof obj === 'object' && obj !== null) {\r\n    Object.keys(obj).forEach(function (k) {\r\n      checkKey(k, obj[k]);\r\n      checkObject(obj[k]);\r\n    });\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Serialize an object to be persisted to a one-line string\r\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\r\n * That gives us less freedom but data entered in the database may come from users\r\n * so eval and the like are not safe\r\n * Accepted primitive types: Number, String, Boolean, Date, null\r\n * Accepted secondary types: Objects, Arrays\r\n */\r\nfunction serialize (obj) {\r\n  var res;\r\n\r\n  // Keep track of the fact that this is a Date object\r\n  Date.prototype.toJSON = dateToJSON;\r\n\r\n  res = JSON.stringify(obj, function (k, v) {\r\n    checkKey(k, v);\r\n\r\n    if (typeof v === undefined) { return null; }\r\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }\r\n\r\n    return v;\r\n  });\r\n\r\n  // Return Date to its original state\r\n  Date.prototype.toJSON = originalDateToJSON;\r\n\r\n  return res;\r\n}\r\n\r\n\r\n/**\r\n * From a one-line representation of an object generate by the serialize function\r\n * Return the object itself\r\n */\r\nfunction deserialize (rawData) {\r\n  return JSON.parse(rawData, function (k, v) {\r\n    if (k === '$$date') { return new Date(v); }\r\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }\r\n    if (v && v.$$date) { return v.$$date; }\r\n\r\n    return v;\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Deep copy a DB object\r\n */\r\nfunction deepCopy (obj) {\r\n  var res;\r\n\r\n  if ( typeof obj === 'boolean' ||\r\n       typeof obj === 'number' ||\r\n       typeof obj === 'string' ||\r\n       obj === null ||\r\n       (util.isDate(obj)) ) {\r\n    return obj;\r\n  }\r\n\r\n  if (util.isArray(obj)) {\r\n    res = [];\r\n    obj.forEach(function (o) { res.push(o); });\r\n    return res;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    res = {};\r\n    Object.keys(obj).forEach(function (k) {\r\n      res[k] = deepCopy(obj[k]);\r\n    });\r\n    return res;\r\n  }\r\n\r\n  return undefined;   // For now everything else is undefined. We should probably throw an error instead\r\n}\r\n\r\n\r\n/**\r\n * Tells if an object is a primitive type or a \"real\" object\r\n * Arrays are considered primitive\r\n */\r\nfunction isPrimitiveType (obj) {\r\n  return ( typeof obj === 'boolean' ||\r\n       typeof obj === 'number' ||\r\n       typeof obj === 'string' ||\r\n       obj === null ||\r\n       util.isDate(obj) ||\r\n       util.isArray(obj));\r\n}\r\n\r\n\r\n/**\r\n * Utility functions for comparing things\r\n * Assumes type checking was already done (a and b already have the same type)\r\n * compareNSB works for numbers, strings and booleans\r\n */\r\nfunction compareNSB (a, b) {\r\n  if (a < b) { return -1; }\r\n  if (a > b) { return 1; }\r\n  return 0;\r\n}\r\n\r\nfunction compareArrays (a, b) {\r\n  var i, comp;\r\n\r\n  for (i = 0; i < Math.min(a.length, b.length); i += 1) {\r\n    comp = compareThings(a[i], b[i]);\r\n\r\n    if (comp !== 0) { return comp; }\r\n  }\r\n\r\n  // Common section was identical, longest one wins\r\n  return compareNSB(a.length, b.length);\r\n}\r\n\r\n\r\n/**\r\n * Compare { things U undefined }\r\n * Things are defined as any native types (string, number, boolean, null, date) and objects\r\n * We need to compare with undefined as it will be used in indexes\r\n * In the case of objects and arrays, we deep-compare\r\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\r\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\r\n */\r\nfunction compareThings (a, b) {\r\n  var aKeys, bKeys, comp, i;\r\n\r\n  // undefined\r\n  if (a === undefined) { return b === undefined ? 0 : -1; }\r\n  if (b === undefined) { return a === undefined ? 0 : 1; }\r\n\r\n  // null\r\n  if (a === null) { return b === null ? 0 : -1; }\r\n  if (b === null) { return a === null ? 0 : 1; }\r\n\r\n  // Numbers\r\n  if (typeof a === 'number') { return typeof b === 'number' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }\r\n\r\n  // Strings\r\n  if (typeof a === 'string') { return typeof b === 'string' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'string') { return typeof a === 'string' ? compareNSB(a, b) : 1; }\r\n\r\n  // Booleans\r\n  if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'boolean') { return typeof a === 'boolean' ? compareNSB(a, b) : 1; }\r\n\r\n  // Dates\r\n  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }\r\n  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }\r\n\r\n  // Arrays (first element is most significant and so on)\r\n  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }\r\n  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }\r\n\r\n  // Objects\r\n  aKeys = Object.keys(a).sort();\r\n  bKeys = Object.keys(b).sort();\r\n\r\n  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\r\n    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\r\n\r\n    if (comp !== 0) { return comp; }\r\n  }\r\n\r\n  return compareNSB(aKeys.length, bKeys.length);\r\n}\r\n\r\n\r\n\r\n// ==============================================================\r\n// Updating documents\r\n// ==============================================================\r\n\r\n/**\r\n * The signature of modifier functions is as follows\r\n * Their structure is always the same: recursively follow the dot notation while creating\r\n * the nested documents if needed, then apply the \"last step modifier\"\r\n * @param {Object} obj The model to modify\r\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\r\n * @param {Model} value\r\n */\r\n\r\n/**\r\n * Set a field to a new value\r\n */\r\nlastStepModifierFunctions.$set = function (obj, field, value) {\r\n  obj[field] = value;\r\n};\r\n\r\n\r\n/**\r\n * Unset a field\r\n */\r\nlastStepModifierFunctions.$unset = function (obj, field, value) {\r\n  delete obj[field];\r\n};\r\n\r\n\r\n/**\r\n * Push an element to the end of an array field\r\n */\r\nlastStepModifierFunctions.$push = function (obj, field, value) {\r\n  // Create the array if it doesn't exist\r\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\r\n\r\n  if (!util.isArray(obj[field])) { throw \"Can't $push an element on non-array values\"; }\r\n\r\n  if (value !== null && typeof value === 'object' && value.$each) {\r\n    if (Object.keys(value).length > 1) { throw \"Can't use another field in conjunction with $each\"; }\r\n    if (!util.isArray(value.$each)) { throw \"$each requires an array value\"; }\r\n\r\n    value.$each.forEach(function (v) {\r\n      obj[field].push(v);\r\n    });\r\n  } else {\r\n    obj[field].push(value);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Add an element to an array field only if it is not already in it\r\n * No modification if the element is already in the array\r\n * Note that it doesn't check whether the original array contains duplicates\r\n */\r\nlastStepModifierFunctions.$addToSet = function (obj, field, value) {\r\n  var addToSet = true;\r\n\r\n  // Create the array if it doesn't exist\r\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\r\n\r\n  if (!util.isArray(obj[field])) { throw \"Can't $addToSet an element on non-array values\"; }\r\n\r\n  if (value !== null && typeof value === 'object' && value.$each) {\r\n    if (Object.keys(value).length > 1) { throw \"Can't use another field in conjunction with $each\"; }\r\n    if (!util.isArray(value.$each)) { throw \"$each requires an array value\"; }\r\n\r\n    value.$each.forEach(function (v) {\r\n      lastStepModifierFunctions.$addToSet(obj, field, v);\r\n    });\r\n  } else {\r\n    obj[field].forEach(function (v) {\r\n      if (compareThings(v, value) === 0) { addToSet = false; }\r\n    });\r\n    if (addToSet) { obj[field].push(value); }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove the first or last element of an array\r\n */\r\nlastStepModifierFunctions.$pop = function (obj, field, value) {\r\n  if (!util.isArray(obj[field])) { throw \"Can't $pop an element from non-array values\"; }\r\n  if (typeof value !== 'number') { throw value + \" isn't an integer, can't use it with $pop\"; }\r\n  if (value === 0) { return; }\r\n\r\n  if (value > 0) {\r\n    obj[field] = obj[field].slice(0, obj[field].length - 1);\r\n  } else {\r\n    obj[field] = obj[field].slice(1);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes all instances of a value from an existing array\r\n */\r\nlastStepModifierFunctions.$pull = function (obj, field, value) {\r\n  var arr, i;\r\n  \r\n  if (!util.isArray(obj[field])) { throw \"Can't $pull an element from non-array values\"; }\r\n\r\n  arr = obj[field];\r\n  for (i = arr.length - 1; i >= 0; i -= 1) {\r\n    if (match(arr[i], value)) {\r\n      arr.splice(i, 1);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Increment a numeric field's value\r\n */\r\nlastStepModifierFunctions.$inc = function (obj, field, value) {\r\n  if (typeof value !== 'number') { throw value + \" must be a number\"; }\r\n\r\n  if (typeof obj[field] !== 'number') {\r\n    if (!_.has(obj, field)) {\r\n      obj[field] = value;\r\n    } else {\r\n      throw \"Don't use the $inc modifier on non-number fields\";\r\n    }\r\n  } else {\r\n    obj[field] += value;\r\n  }\r\n};\r\n\r\n// Given its name, create the complete modifier function\r\nfunction createModifierFunction (modifier) {\r\n  return function (obj, field, value) {\r\n    var fieldParts = typeof field === 'string' ? field.split('.') : field;\r\n\r\n    if (fieldParts.length === 1) {\r\n      lastStepModifierFunctions[modifier](obj, field, value);\r\n    } else {\r\n      obj[fieldParts[0]] = obj[fieldParts[0]] || {};\r\n      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);\r\n    }\r\n  };\r\n}\r\n\r\n// Actually create all modifier functions\r\nObject.keys(lastStepModifierFunctions).forEach(function (modifier) {\r\n  modifierFunctions[modifier] = createModifierFunction(modifier);\r\n});\r\n\r\n\r\n/**\r\n * Modify a DB object according to an update query\r\n * For now the updateQuery only replaces the object\r\n */\r\nfunction modify (obj, updateQuery) {\r\n  var keys = Object.keys(updateQuery)\r\n    , firstChars = _.map(keys, function (item) { return item[0]; })\r\n    , dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; })\r\n    , newDoc, modifiers\r\n    ;\r\n\r\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) { throw \"You cannot change a document's _id\"; }\r\n\r\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\r\n    throw \"You cannot mix modifiers and normal fields\";\r\n  }\r\n\r\n  if (dollarFirstChars.length === 0) {\r\n    // Simply replace the object with the update query contents\r\n    newDoc = deepCopy(updateQuery);\r\n    newDoc._id = obj._id;\r\n  } else {\r\n    // Apply modifiers\r\n    modifiers = _.uniq(keys);\r\n    newDoc = deepCopy(obj);\r\n    modifiers.forEach(function (m) {\r\n      var keys;\r\n\r\n      if (!modifierFunctions[m]) { throw \"Unknown modifier \" + m; }\r\n\r\n      try {\r\n        keys = Object.keys(updateQuery[m]);\r\n      } catch (e) {\r\n        throw \"Modifier \" + m + \"'s argument must be an object\";\r\n      }\r\n\r\n      keys.forEach(function (k) {\r\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Check result is valid and return it\r\n  checkObject(newDoc);\r\n  if (obj._id !== newDoc._id) { throw \"You can't change a document's _id\"; }\r\n  return newDoc;\r\n};\r\n\r\n\r\n// ==============================================================\r\n// Finding documents\r\n// ==============================================================\r\n\r\n/**\r\n * Get a value from object with dot notation\r\n * @param {Object} obj\r\n * @param {String} field\r\n */\r\nfunction getDotValue (obj, field) {\r\n  var fieldParts = typeof field === 'string' ? field.split('.') : field\r\n    , i, objs;\r\n\r\n  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match\r\n\r\n  if (fieldParts.length === 0) { return obj; }\r\n\r\n  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }\r\n  \r\n  if (util.isArray(obj[fieldParts[0]])) {\r\n    // If the next field is an integer, return only this item of the array\r\n    i = parseInt(fieldParts[1], 10);\r\n    if (typeof i === 'number' && !isNaN(i)) {\r\n      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))\r\n    }\r\n\r\n    // Return the array of values\r\n    objs = new Array();\r\n    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {\r\n       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));\r\n    }\r\n    return objs;\r\n  } else {\r\n    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Check whether 'things' are equal\r\n * Things are defined as any native types (string, number, boolean, null, date) and objects\r\n * In the case of object, we check deep equality\r\n * Returns true if they are, false otherwise\r\n */\r\nfunction areThingsEqual (a, b) {\r\n  var aKeys , bKeys , i;\r\n\r\n  // Strings, booleans, numbers, null\r\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' ||\r\n      b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') { return a === b; }\r\n\r\n  // Dates\r\n  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime(); }\r\n\r\n  // Arrays (no match since arrays are used as a $in)\r\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\r\n  if (util.isArray(a) || util.isArray(b) || a === undefined || b === undefined) { return false; }\r\n\r\n  // General objects (check for deep equality)\r\n  // a and b should be objects at this point\r\n  try {\r\n    aKeys = Object.keys(a);\r\n    bKeys = Object.keys(b);\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n\r\n  if (aKeys.length !== bKeys.length) { return false; }\r\n  for (i = 0; i < aKeys.length; i += 1) {\r\n    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }\r\n    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Check that two values are comparable\r\n */\r\nfunction areComparable (a, b) {\r\n  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) &&\r\n      typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof a !== typeof b) { return false; }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Arithmetic and comparison operators\r\n * @param {Native value} a Value in the object\r\n * @param {Native value} b Value in the query\r\n */\r\ncomparisonFunctions.$lt = function (a, b) {\r\n  return areComparable(a, b) && a < b;\r\n};\r\n\r\ncomparisonFunctions.$lte = function (a, b) {\r\n  return areComparable(a, b) && a <= b;\r\n};\r\n\r\ncomparisonFunctions.$gt = function (a, b) {\r\n  return areComparable(a, b) && a > b;\r\n};\r\n\r\ncomparisonFunctions.$gte = function (a, b) {\r\n  return areComparable(a, b) && a >= b;\r\n};\r\n\r\ncomparisonFunctions.$ne = function (a, b) {\r\n  if (!a) { return true; }\r\n  return !areThingsEqual(a, b);\r\n};\r\n\r\ncomparisonFunctions.$in = function (a, b) {\r\n  var i;\r\n\r\n  if (!util.isArray(b)) { throw \"$in operator called with a non-array\"; }\r\n\r\n  for (i = 0; i < b.length; i += 1) {\r\n    if (areThingsEqual(a, b[i])) { return true; }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\ncomparisonFunctions.$nin = function (a, b) {\r\n  if (!util.isArray(b)) { throw \"$nin operator called with a non-array\"; }\r\n\r\n  return !comparisonFunctions.$in(a, b);\r\n};\r\n\r\ncomparisonFunctions.$regex = function (a, b) {\r\n  if (!util.isRegExp(b)) { throw \"$regex operator called with non regular expression\"; }\r\n\r\n  if (typeof a !== 'string') {\r\n    return false\r\n  } else {\r\n    return b.test(a);\r\n  }\r\n};\r\n\r\ncomparisonFunctions.$exists = function (value, exists) {\r\n  if (exists || exists === '') {   // This will be true for all values of exists except false, null, undefined and 0\r\n    exists = true;                 // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\r\n  } else {\r\n    exists = false;\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return !exists\r\n  } else {\r\n    return exists;\r\n  }\r\n};\r\n\r\n// Specific to arrays\r\ncomparisonFunctions.$size = function (obj, value) {\r\n    if (!util.isArray(obj)) { return false; }\r\n    if (value % 1 !== 0) { throw \"$size operator called without an integer\"; }\r\n\r\n    return (obj.length == value);\r\n};\r\narrayComparisonFunctions.$size = true;\r\n\r\n\r\n/**\r\n * Match any of the subqueries\r\n * @param {Model} obj\r\n * @param {Array of Queries} query\r\n */\r\nlogicalOperators.$or = function (obj, query) {\r\n  var i;\r\n\r\n  if (!util.isArray(query)) { throw \"$or operator used without an array\"; }\r\n\r\n  for (i = 0; i < query.length; i += 1) {\r\n    if (match(obj, query[i])) { return true; }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Match all of the subqueries\r\n * @param {Model} obj\r\n * @param {Array of Queries} query\r\n */\r\nlogicalOperators.$and = function (obj, query) {\r\n  var i;\r\n\r\n  if (!util.isArray(query)) { throw \"$and operator used without an array\"; }\r\n\r\n  for (i = 0; i < query.length; i += 1) {\r\n    if (!match(obj, query[i])) { return false; }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Inverted match of the query\r\n * @param {Model} obj\r\n * @param {Query} query\r\n */\r\nlogicalOperators.$not = function (obj, query) {\r\n  return !match(obj, query);\r\n};\r\n\r\n\r\n/**\r\n * Tell if a given document matches a query\r\n * @param {Object} obj Document to check\r\n * @param {Object} query\r\n */\r\nfunction match (obj, query) {\r\n  var queryKeys, queryKey, queryValue, i;\r\n\r\n  // Primitive query against a primitive type\r\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\r\n  // But I don't have time for a cleaner implementation now\r\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) {\r\n    return matchQueryPart({ needAKey: obj }, 'needAKey', query);\r\n  }\r\n    \r\n  // Normal query\r\n  queryKeys = Object.keys(query);\r\n  for (i = 0; i < queryKeys.length; i += 1) {\r\n    queryKey = queryKeys[i];\r\n    queryValue = query[queryKey];\r\n  \r\n    if (queryKey[0] === '$') {\r\n      if (!logicalOperators[queryKey]) { throw \"Unknown logical operator \" + queryKey; }\r\n      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }\r\n    } else {\r\n      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Match an object against a specific { key: value } part of a query\r\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\r\n */\r\nfunction matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {\r\n  var objValue = getDotValue(obj, queryKey)\r\n    , i, keys, firstChars, dollarFirstChars;\r\n\r\n  // Check if the value is an array if we don't force a treatment as value\r\n  if (util.isArray(objValue) && !treatObjAsValue) {\r\n    // Check if we are using an array-specific comparison function\r\n    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\r\n      keys = Object.keys(queryValue);      \r\n      for (i = 0; i < keys.length; i += 1) {\r\n        if (arrayComparisonFunctions[keys[i]]) { return matchQueryPart(obj, queryKey, queryValue, true); }\r\n      }\r\n    }\r\n\r\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\r\n    for (i = 0; i < objValue.length; i += 1) {\r\n      if (matchQueryPart({ k: objValue[i] }, 'k', queryValue)) { return true; }   // k here could be any string\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // queryValue is an actual object. Determine whether it contains comparison operators\r\n  // or only normal fields. Mixed objects are not allowed\r\n  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\r\n    keys = Object.keys(queryValue);\r\n    firstChars = _.map(keys, function (item) { return item[0]; });\r\n    dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });\r\n\r\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\r\n      throw \"You cannot mix operators and normal fields\";\r\n    }\r\n\r\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\r\n    if (dollarFirstChars.length > 0) {\r\n      for (i = 0; i < keys.length; i += 1) {\r\n        if (!comparisonFunctions[keys[i]]) { throw \"Unknown comparison function \" + keys[i]; }\r\n\r\n        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) { return false; }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Using regular expressions with basic querying\r\n  if (util.isRegExp(queryValue)) { return comparisonFunctions.$regex(objValue, queryValue); }\r\n\r\n  // queryValue is either a native value or a normal object\r\n  // Basic matching is possible\r\n  if (!areThingsEqual(objValue, queryValue)) { return false; }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n// Interface\r\nmodule.exports.serialize = serialize;\r\nmodule.exports.deserialize = deserialize;\r\nmodule.exports.deepCopy = deepCopy;\r\nmodule.exports.checkObject = checkObject;\r\nmodule.exports.isPrimitiveType = isPrimitiveType;\r\nmodule.exports.modify = modify;\r\nmodule.exports.getDotValue = getDotValue;\r\nmodule.exports.match = match;\r\nmodule.exports.areThingsEqual = areThingsEqual;\r\nmodule.exports.compareThings = compareThings;\r\n\n},{\"underscore\":15,\"util\":2}],9:[function(require,module,exports){\n/**\r\n * Handle every persistence-related task\r\n * The interface Datastore expects to be implemented is\r\n * * Persistence.loadDatabase(callback) and callback has signature err\r\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\r\n *\r\n * Shim for the browser\r\n */\r\n\r\n/**\r\n * Create a new Persistence object for database options.db\r\n * For now, no browser persistence supported, in-memory only mode forced\r\n * @param {Datastore} options.db\r\n */\r\nfunction Persistence (options) {\r\n  this.db = options.db;\r\n  this.db.inMemoryOnly = true;\r\n  this.db.filename = null;\r\n  this.inMemoryOnly = true;\r\n};\r\n\r\n\r\n/**\r\n * No persistence in the browser (for now)\r\n */\r\nPersistence.prototype.persistNewState = function (newDocs, cb) {\r\n  if (cb) { return cb(); }\r\n};\r\n\r\n\r\n/**\r\n * No persistence in the browser (for now)\r\n */\r\nPersistence.prototype.loadDatabase = function (cb) {\r\n  if (cb) { return cb(); }\r\n};\r\n\r\n\r\n// Interface\r\nmodule.exports = Persistence;\r\n\n},{}],10:[function(require,module,exports){\nvar process=require(\"__browserify_process\");/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n},{\"__browserify_process\":3}],11:[function(require,module,exports){\nmodule.exports.BinarySearchTree = require('./lib/bst');\nmodule.exports.AVLTree = require('./lib/avltree');\n\n},{\"./lib/avltree\":12,\"./lib/bst\":13}],12:[function(require,module,exports){\n/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst')\n  , customUtils = require('./customUtils')\n  , util = require('util')\n  , _ = require('underscore')\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw \"Undefined height for node \" + this.left.key; }\n  if (this.right && this.right.height === undefined) { throw \"Undefined height for node \" + this.right.key; }\n  if (this.height === undefined) { throw \"Undefined height for node \" + this.key; }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw \"Height constraint failed for node \" + this.key; }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw 'Tree is unbalanced at node ' + this.key; }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        throw { message: \"Can't insert key \" + key + \", it violates the unique constraint\"\n              , key: key\n              , errorType: 'uniqueViolated'\n              };\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n\n},{\"./bst\":13,\"./customUtils\":14,\"underscore\":15,\"util\":2}],13:[function(require,module,exports){\n/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw 'Tree with root ' + self.key + ' is not a binary search tree';\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw 'Tree with root ' + self.key + ' is not a binary search tree';\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw 'Parent pointer broken for key ' + this.key; }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw 'Parent pointer broken for key ' + this.key; }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw \"The root shouldn't have a parent\"; }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      throw { message: \"Can't insert key \" + key + \", it violates the unique constraint\"\n            , key: key\n            , errorType: 'uniqueViolated'\n            };\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n\n},{\"./customUtils\":14}],14:[function(require,module,exports){\n/**\n * Return an array with the numbers from 0 to n-1, in a random order\n */\nfunction getRandomArray (n) {\n  var res, next;\n\n  if (n === 0) { return []; }\n  if (n === 1) { return [0]; }\n\n  res = getRandomArray(n - 1);\n  next = Math.floor(Math.random() * n);\n  res.splice(next, 0, n - 1);   // Add n-1 at a random position in the array\n\n  return res;\n};\nmodule.exports.getRandomArray = getRandomArray;\n\n\n/*\n * Default compareKeys function will work for numbers, strings and dates\n */\nfunction defaultCompareKeysFunction (a, b) {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n\n  throw { message: \"Couldn't compare elements\", a: a, b: b };\n}\nmodule.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;\n\n\n/**\n * Check whether two values are equal (used in non-unique deletion)\n */\nfunction defaultCheckValueEquality (a, b) {\n  return a === b;\n}\nmodule.exports.defaultCheckValueEquality = defaultCheckValueEquality;\n\n},{}],15:[function(require,module,exports){\n//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n},{}]},{},[5])(5)\n});\n;","!function(t){if(\"function\"==typeof bootstrap)bootstrap(\"nedb\",t);else if(\"object\"==typeof exports)module.exports=t();else if(\"function\"==typeof define&&define.amd)define(t);else if(\"undefined\"!=typeof ses){if(!ses.ok())return;ses.makeNedb=t}else\"undefined\"!=typeof window?window.Nedb=t():global.Nedb=t()}(function(){var t;return function(t,e,n){function r(n,o){if(!e[n]){if(!t[n]){var u=\"function\"==typeof require&&require;if(!o&&u)return u(n,!0);if(i)return i(n,!0);throw new Error(\"Cannot find module '\"+n+\"'\")}var a=e[n]={exports:{}};t[n][0].call(a.exports,function(e){var i=t[n][1][e];return r(i?i:e)},a,a.exports)}return e[n].exports}for(var i=\"function\"==typeof require&&require,o=0;o<n.length;o++)r(n[o]);return r}({1:[function(t,e,n){function r(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0;n<t.length;n++)if(e===t[n])return n;return-1}var i=t(\"__browserify_process\");i.EventEmitter||(i.EventEmitter=function(){});var o=n.EventEmitter=i.EventEmitter,u=\"function\"==typeof Array.isArray?Array.isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)},a=10;o.prototype.setMaxListeners=function(t){this._events||(this._events={}),this._events.maxListeners=t},o.prototype.emit=function(t){if(\"error\"===t&&(!this._events||!this._events.error||u(this._events.error)&&!this._events.error.length))throw arguments[1]instanceof Error?arguments[1]:new Error(\"Uncaught, unspecified 'error' event.\");if(!this._events)return!1;var e=this._events[t];if(!e)return!1;if(\"function\"==typeof e){switch(arguments.length){case 1:e.call(this);break;case 2:e.call(this,arguments[1]);break;case 3:e.call(this,arguments[1],arguments[2]);break;default:var n=Array.prototype.slice.call(arguments,1);e.apply(this,n)}return!0}if(u(e)){for(var n=Array.prototype.slice.call(arguments,1),r=e.slice(),i=0,o=r.length;o>i;i++)r[i].apply(this,n);return!0}return!1},o.prototype.addListener=function(t,e){if(\"function\"!=typeof e)throw new Error(\"addListener only takes instances of Function\");if(this._events||(this._events={}),this.emit(\"newListener\",t,e),this._events[t])if(u(this._events[t])){if(!this._events[t].warned){var n;n=void 0!==this._events.maxListeners?this._events.maxListeners:a,n&&n>0&&this._events[t].length>n&&(this._events[t].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[t].length),console.trace())}this._events[t].push(e)}else this._events[t]=[this._events[t],e];else this._events[t]=e;return this},o.prototype.on=o.prototype.addListener,o.prototype.once=function(t,e){var n=this;return n.on(t,function r(){n.removeListener(t,r),e.apply(this,arguments)}),this},o.prototype.removeListener=function(t,e){if(\"function\"!=typeof e)throw new Error(\"removeListener only takes instances of Function\");if(!this._events||!this._events[t])return this;var n=this._events[t];if(u(n)){var i=r(n,e);if(0>i)return this;n.splice(i,1),0==n.length&&delete this._events[t]}else this._events[t]===e&&delete this._events[t];return this},o.prototype.removeAllListeners=function(t){return 0===arguments.length?(this._events={},this):(t&&this._events&&this._events[t]&&(this._events[t]=null),this)},o.prototype.listeners=function(t){return this._events||(this._events={}),this._events[t]||(this._events[t]=[]),u(this._events[t])||(this._events[t]=[this._events[t]]),this._events[t]},o.listenerCount=function(t,e){var n;return n=t._events&&t._events[e]?\"function\"==typeof t._events[e]?1:t._events[e].length:0}},{__browserify_process:3}],2:[function(t,e,n){function r(t){return Array.isArray(t)||\"object\"==typeof t&&\"[object Array]\"===Object.prototype.toString.call(t)}function i(t){\"object\"==typeof t&&\"[object RegExp]\"===Object.prototype.toString.call(t)}function o(t){return\"object\"==typeof t&&\"[object Date]\"===Object.prototype.toString.call(t)}t(\"events\"),n.isArray=r,n.isDate=function(t){return\"[object Date]\"===Object.prototype.toString.call(t)},n.isRegExp=function(t){return\"[object RegExp]\"===Object.prototype.toString.call(t)},n.print=function(){},n.puts=function(){},n.debug=function(){},n.inspect=function(t,e,s,c){function f(t,s){if(t&&\"function\"==typeof t.inspect&&t!==n&&(!t.constructor||t.constructor.prototype!==t))return t.inspect(s);switch(typeof t){case\"undefined\":return h(\"undefined\",\"undefined\");case\"string\":var c=\"'\"+JSON.stringify(t).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return h(c,\"string\");case\"number\":return h(\"\"+t,\"number\");case\"boolean\":return h(\"\"+t,\"boolean\")}if(null===t)return h(\"null\",\"null\");var p=u(t),y=e?a(t):p;if(\"function\"==typeof t&&0===y.length){if(i(t))return h(\"\"+t,\"regexp\");var d=t.name?\": \"+t.name:\"\";return h(\"[Function\"+d+\"]\",\"special\")}if(o(t)&&0===y.length)return h(t.toUTCString(),\"date\");var g,v,m;if(r(t)?(v=\"Array\",m=[\"[\",\"]\"]):(v=\"Object\",m=[\"{\",\"}\"]),\"function\"==typeof t){var b=t.name?\": \"+t.name:\"\";g=i(t)?\" \"+t:\" [Function\"+b+\"]\"}else g=\"\";if(o(t)&&(g=\" \"+t.toUTCString()),0===y.length)return m[0]+g+m[1];if(0>s)return i(t)?h(\"\"+t,\"regexp\"):h(\"[Object]\",\"special\");l.push(t);var w=y.map(function(e){var n,i;if(t.__lookupGetter__&&(t.__lookupGetter__(e)?i=t.__lookupSetter__(e)?h(\"[Getter/Setter]\",\"special\"):h(\"[Getter]\",\"special\"):t.__lookupSetter__(e)&&(i=h(\"[Setter]\",\"special\"))),p.indexOf(e)<0&&(n=\"[\"+e+\"]\"),i||(l.indexOf(t[e])<0?(i=null===s?f(t[e]):f(t[e],s-1),i.indexOf(\"\\n\")>-1&&(i=r(t)?i.split(\"\\n\").map(function(t){return\"  \"+t}).join(\"\\n\").substr(2):\"\\n\"+i.split(\"\\n\").map(function(t){return\"   \"+t}).join(\"\\n\"))):i=h(\"[Circular]\",\"special\")),\"undefined\"==typeof n){if(\"Array\"===v&&e.match(/^\\d+$/))return i;n=JSON.stringify(\"\"+e),n.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)?(n=n.substr(1,n.length-2),n=h(n,\"name\")):(n=n.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\"),n=h(n,\"string\"))}return n+\": \"+i});l.pop();var k=0,x=w.reduce(function(t,e){return k++,e.indexOf(\"\\n\")>=0&&k++,t+e.length+1},0);return w=x>50?m[0]+(\"\"===g?\"\":g+\"\\n \")+\" \"+w.join(\",\\n  \")+\" \"+m[1]:m[0]+g+\" \"+w.join(\", \")+\" \"+m[1]}var l=[],h=function(t,e){var n={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r={special:\"cyan\",number:\"blue\",\"boolean\":\"yellow\",undefined:\"grey\",\"null\":\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"}[e];return r?\"\u001b[\"+n[r][0]+\"m\"+t+\"\u001b[\"+n[r][1]+\"m\":t};return c||(h=function(t){return t}),f(t,\"undefined\"==typeof s?2:s)},n.log=function(){},n.pump=null;var u=Object.keys||function(t){var e=[];for(var n in t)e.push(n);return e},a=Object.getOwnPropertyNames||function(t){var e=[];for(var n in t)Object.hasOwnProperty.call(t,n)&&e.push(n);return e},s=Object.create||function(t,e){var n;if(null===t)n={__proto__:null};else{if(\"object\"!=typeof t)throw new TypeError(\"typeof prototype[\"+typeof t+\"] != 'object'\");var r=function(){};r.prototype=t,n=new r,n.__proto__=t}return\"undefined\"!=typeof e&&Object.defineProperties&&Object.defineProperties(n,e),n};n.inherits=function(t,e){t.super_=e,t.prototype=s(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})};var c=/%[sdj%]/g;n.format=function(t){if(\"string\"!=typeof t){for(var e=[],r=0;r<arguments.length;r++)e.push(n.inspect(arguments[r]));return e.join(\" \")}for(var r=1,i=arguments,o=i.length,u=String(t).replace(c,function(t){if(\"%%\"===t)return\"%\";if(r>=o)return t;switch(t){case\"%s\":return String(i[r++]);case\"%d\":return Number(i[r++]);case\"%j\":return JSON.stringify(i[r++]);default:return t}}),a=i[r];o>r;a=i[++r])u+=null===a||\"object\"!=typeof a?\" \"+a:\" \"+n.inspect(a);return u}},{events:1}],3:[function(t,e){var n=e.exports={};n.nextTick=function(){var t=\"undefined\"!=typeof window&&window.setImmediate,e=\"undefined\"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener(\"message\",function(t){if(t.source===window&&\"process-tick\"===t.data&&(t.stopPropagation(),n.length>0)){var e=n.shift();e()}},!0),function(t){n.push(t),window.postMessage(\"process-tick\",\"*\")}}return function(t){setTimeout(t,0)}}(),n.title=\"browser\",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error(\"process.binding is not supported\")},n.cwd=function(){return\"/\"},n.chdir=function(){throw new Error(\"process.chdir is not supported\")}},{}],4:[function(t,e){function n(t){for(var e,e,n=new Array(t),r=0;t>r;r++)0==(3&r)&&(e=4294967296*Math.random()),n[r]=255&e>>>((3&r)<<3);return n}function r(t){function e(t){return o[63&t>>18]+o[63&t>>12]+o[63&t>>6]+o[63&t]}var n,r,i,o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",u=t.length%3,a=\"\";for(i=0,r=t.length-u;r>i;i+=3)n=(t[i]<<16)+(t[i+1]<<8)+t[i+2],a+=e(n);switch(u){case 1:n=t[t.length-1],a+=o[n>>2],a+=o[63&n<<4],a+=\"==\";break;case 2:n=(t[t.length-2]<<8)+t[t.length-1],a+=o[n>>10],a+=o[63&n>>4],a+=o[63&n<<2],a+=\"=\"}return a}function i(t){return r(n(Math.ceil(Math.max(8,2*t)))).replace(/[+\\/]/g,\"\").slice(0,t)}e.exports.uid=i},{}],5:[function(t,e){function n(t){var e;\"string\"==typeof t?(e=t,this.inMemoryOnly=!1):(t=t||{},e=t.filename,this.inMemoryOnly=t.inMemoryOnly||!1,this.autoload=t.autoload||!1),e&&\"string\"==typeof e&&0!==e.length?this.filename=e:(this.filename=null,this.inMemoryOnly=!0),this.persistence=new f({db:this,nodeWebkitAppName:t.nodeWebkitAppName}),this.executor=new u,this.inMemoryOnly&&(this.executor.ready=!0),this.indexes={},this.indexes._id=new a({fieldName:\"_id\",unique:!0}),this.autoload&&this.loadDatabase()}var r=t(\"./customUtils\"),i=t(\"./model\"),o=t(\"async\"),u=t(\"./executor\"),a=t(\"./indexes\"),s=t(\"util\"),c=t(\"underscore\"),f=t(\"./persistence\");n.prototype.loadDatabase=function(){this.executor.push({\"this\":this.persistence,fn:this.persistence.loadDatabase,arguments:arguments},!0)},n.prototype.getAllData=function(){return this.indexes._id.getAll()},n.prototype.resetIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].reset(t)})},n.prototype.ensureIndex=function(t,e){var n=e||function(){};if(t=t||{},!t.fieldName)return n({missingFieldName:!0});if(this.indexes[t.fieldName])return n(null);this.indexes[t.fieldName]=new a(t);try{this.indexes[t.fieldName].insert(this.getAllData())}catch(r){return delete this.indexes[t.fieldName],n(r)}this.persistence.persistNewState([{$$indexCreated:t}],function(t){return t?n(t):n(null)})},n.prototype.removeIndex=function(t,e){var n=e||function(){};delete this.indexes[t],this.persistence.persistNewState([{$$indexRemoved:t}],function(t){return t?n(t):n(null)})},n.prototype.addToIndexes=function(t){var e,n,r,i=Object.keys(this.indexes);for(e=0;e<i.length;e+=1)try{this.indexes[i[e]].insert(t)}catch(o){n=e,r=o;break}if(r){for(e=0;n>e;e+=1)this.indexes[i[e]].remove(t);throw r}},n.prototype.removeFromIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].remove(t)})},n.prototype.updateIndexes=function(t,e){var n,r,i,o=Object.keys(this.indexes);for(n=0;n<o.length;n+=1)try{this.indexes[o[n]].update(t,e)}catch(u){r=n,i=u;break}if(i){for(n=0;r>n;n+=1)this.indexes[o[n]].revertUpdate(t,e);throw i}},n.prototype.getCandidates=function(t){var e,n=Object.keys(this.indexes);return e=[],Object.keys(t).forEach(function(n){(\"string\"==typeof t[n]||\"number\"==typeof t[n]||\"boolean\"==typeof t[n]||s.isDate(t[n])||null===t[n])&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getMatching(t[e[0]]):(e=[],Object.keys(t).forEach(function(n){t[n]&&t[n].hasOwnProperty(\"$in\")&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getMatching(t[e[0]].$in):(e=[],Object.keys(t).forEach(function(n){t[n]&&(t[n].hasOwnProperty(\"$lt\")||t[n].hasOwnProperty(\"$lte\")||t[n].hasOwnProperty(\"$gt\")||t[n].hasOwnProperty(\"$gte\"))&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getBetweenBounds(t[e[0]]):this.getAllData()))},n.prototype._insert=function(t,e){var n=e||function(){};try{this._insertInCache(t)}catch(r){return n(r)}this.persistence.persistNewState(s.isArray(t)?t:[t],function(e){return e?n(e):n(null,t)})},n.prototype.prepareDocumentForInsertion=function(t){var e,n=this;return s.isArray(t)?(e=[],t.forEach(function(t){e.push(n.prepareDocumentForInsertion(t))})):(t._id=r.uid(16),e=i.deepCopy(t),i.checkObject(e)),e},n.prototype._insertInCache=function(t){s.isArray(t)?this._insertMultipleDocsInCache(t):this.addToIndexes(this.prepareDocumentForInsertion(t))},n.prototype._insertMultipleDocsInCache=function(t){var e,n,r,i=this.prepareDocumentForInsertion(t);for(e=0;e<i.length;e+=1)try{this.addToIndexes(i[e])}catch(o){r=o,n=e;break}if(r){for(e=0;n>e;e+=1)this.removeFromIndexes(i[e]);throw r}},n.prototype.insert=function(){this.executor.push({\"this\":this,fn:this._insert,arguments:arguments})},n.prototype._count=function(t,e){var n,r=0,o=this.getCandidates(t);try{for(n=0;n<o.length;n+=1)i.match(o[n],t)&&r++}catch(u){return e(u)}return e(null,r)},n.prototype.count=function(){this.executor.push({\"this\":this,fn:this._count,arguments:arguments})},n.prototype._find=function(t,e){var n,r=[],o=this.getCandidates(t);try{for(n=0;n<o.length;n+=1)i.match(o[n],t)&&r.push(i.deepCopy(o[n]))}catch(u){return e(u)}return e(null,r)},n.prototype.find=function(){this.executor.push({\"this\":this,fn:this._find,arguments:arguments})},n.prototype._findOne=function(t,e){var n,r=this.getCandidates(t),o=null;try{for(n=0;n<r.length;n+=1)i.match(r[n],t)&&(o=i.deepCopy(r[n]))}catch(u){return e(u)}return e(null,o)},n.prototype.findOne=function(){this.executor.push({\"this\":this,fn:this._findOne,arguments:arguments})},n.prototype._update=function(t,e,n,r){var u,a,s,f,l=this,h=0;\"function\"==typeof n&&(r=n,n={}),u=r||function(){},a=void 0!==n.multi?n.multi:!1,s=void 0!==n.upsert?n.upsert:!1,o.waterfall([function(n){return s?(l._findOne(t,function(r,o){return r?u(r):o?n():l._insert(i.modify(t,e),function(t){return t?u(t):u(null,1,!0)})}),void 0):n()},function(){var n,r=l.getCandidates(t),o=[];try{for(f=0;f<r.length;f+=1)i.match(r[f],t)&&(a||0===h)&&(h+=1,n=i.modify(r[f],e),o.push({oldDoc:r[f],newDoc:n}))}catch(s){return u(s)}try{l.updateIndexes(o)}catch(s){return u(s)}l.persistence.persistNewState(c.pluck(o,\"newDoc\"),function(t){return t?u(t):u(null,h)})}])},n.prototype.update=function(){this.executor.push({\"this\":this,fn:this._update,arguments:arguments})},n.prototype._remove=function(t,e,n){var r,o,u=this,a=0,s=[],c=this.getCandidates(t);\"function\"==typeof e&&(n=e,e={}),r=n||function(){},o=void 0!==e.multi?e.multi:!1;try{c.forEach(function(e){i.match(e,t)&&(o||0===a)&&(a+=1,s.push({$$deleted:!0,_id:e._id}),u.removeFromIndexes(e))})}catch(f){return r(f)}u.persistence.persistNewState(s,function(t){return t?r(t):r(null,a)})},n.prototype.remove=function(){this.executor.push({\"this\":this,fn:this._remove,arguments:arguments})},e.exports=n},{\"./customUtils\":4,\"./executor\":6,\"./indexes\":7,\"./model\":8,\"./persistence\":9,async:10,underscore:15,util:2}],6:[function(t,e){function n(){this.buffer=[],this.ready=!1,this.queue=r.queue(function(t,e){var n,r,i=t.arguments[t.arguments.length-1],o=[];for(r=0;r<t.arguments.length;r+=1)o.push(t.arguments[r]);\"function\"==typeof i?(n=function(){i.apply(null,arguments),e()},o[o.length-1]=n):(n=function(){e()},o.push(n)),t.fn.apply(t.this,o)},1)}var r=t(\"async\");n.prototype.push=function(t,e){this.ready||e?this.queue.push(t):this.buffer.push(t)},n.prototype.processBuffer=function(){var t;for(this.ready=!0,t=0;t<this.buffer.length;t+=1)this.queue.push(this.buffer[t]);this.buffer=[]},e.exports=n},{async:10}],7:[function(t,e){function n(t,e){return t===e}function r(t){return null===t?\"$null\":\"string\"==typeof t?\"$string\"+t:\"boolean\"==typeof t?\"$boolean\"+t:\"number\"==typeof t?\"$number\"+t:c.isArray(t)?\"$date\"+t.getTime():t}function i(t){this.fieldName=t.fieldName,this.unique=t.unique||!1,this.sparse=t.sparse||!1,this.treeOptions={unique:this.unique,compareKeys:a.compareThings,checkValueEquality:n},this.reset()}function o(t,e){var n;for(n=0;n<e.length;n+=1)t.push(e[n])}var u=t(\"binary-search-tree\").AVLTree,a=t(\"./model\"),s=t(\"underscore\"),c=t(\"util\");i.prototype.reset=function(t){this.tree=new u(this.treeOptions),t&&this.insert(t)},i.prototype.insert=function(t){var e,n,i,o,u;if(c.isArray(t))return this.insertMultipleDocs(t),void 0;if(e=a.getDotValue(t,this.fieldName),void 0!==e||!this.sparse)if(c.isArray(e)){for(n=s.uniq(e,r),i=0;i<n.length;i+=1)try{this.tree.insert(n[i],t)}catch(f){u=f,o=i;break}if(u){for(i=0;o>i;i+=1)this.tree.delete(n[i],t);throw u}}else this.tree.insert(e,t)},i.prototype.insertMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)try{this.insert(t[e])}catch(i){n=i,r=e;break}if(n){for(e=0;r>e;e+=1)this.remove(t[e]);throw n}},i.prototype.remove=function(t){var e,n=this;return c.isArray(t)?(t.forEach(function(t){n.remove(t)}),void 0):(e=a.getDotValue(t,this.fieldName),void 0===e&&this.sparse||(c.isArray(e)?s.uniq(e,r).forEach(function(e){n.tree.delete(e,t)}):this.tree.delete(e,t)),void 0)},i.prototype.update=function(t,e){if(c.isArray(t))return this.updateMultipleDocs(t),void 0;this.remove(t);try{this.insert(e)}catch(n){throw this.insert(t),n}},i.prototype.updateMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)this.remove(t[e].oldDoc);for(e=0;e<t.length;e+=1)try{this.insert(t[e].newDoc)}catch(i){r=i,n=e;break}if(r){for(e=0;n>e;e+=1)this.remove(t[e].newDoc);for(e=0;e<t.length;e+=1)this.insert(t[e].oldDoc);throw r}},i.prototype.revertUpdate=function(t,e){var n=[];c.isArray(t)?(t.forEach(function(t){n.push({oldDoc:t.newDoc,newDoc:t.oldDoc})}),this.update(n)):this.update(e,t)},i.prototype.getMatching=function(t){var e,n=this;return c.isArray(t)?(e=[],t.forEach(function(t){o(e,n.getMatching(t))}),e):this.tree.search(t)},i.prototype.getBetweenBounds=function(t){return this.tree.betweenBounds(t)},i.prototype.getAll=function(){var t=[];return this.tree.executeOnEveryNode(function(e){var n;for(n=0;n<e.data.length;n+=1)t.push(e.data[n])}),t},e.exports=i},{\"./model\":8,\"binary-search-tree\":11,underscore:15,util:2}],8:[function(t,e){function n(t,e){if(!(\"$\"!==t[0]||\"$$date\"===t&&\"number\"==typeof e||\"$$deleted\"===t&&e===!0||\"$$indexCreated\"===t||\"$$indexRemoved\"===t))throw\"Field names cannot begin with the $ character\";if(-1!==t.indexOf(\".\"))throw\"Field names cannot contain a .\"}function r(t){w.isArray(t)&&t.forEach(function(t){r(t)}),\"object\"==typeof t&&null!==t&&Object.keys(t).forEach(function(e){n(e,t[e]),r(t[e])})}function i(t){var e;return Date.prototype.toJSON=m,e=JSON.stringify(t,function(t,e){return n(t,e),void 0===typeof e?null:\"string\"==typeof e||\"number\"==typeof e||\"boolean\"==typeof e||null===e?e:e}),Date.prototype.toJSON=b,e}function o(t){return JSON.parse(t,function(t,e){return\"$$date\"===t?new Date(e):\"string\"==typeof e||\"number\"==typeof e||\"boolean\"==typeof e||null===e?e:e&&e.$$date?e.$$date:e})}function u(t){var e;return\"boolean\"==typeof t||\"number\"==typeof t||\"string\"==typeof t||null===t||w.isDate(t)?t:w.isArray(t)?(e=[],t.forEach(function(t){e.push(t)}),e):\"object\"==typeof t?(e={},Object.keys(t).forEach(function(n){e[n]=u(t[n])}),e):void 0}function a(t){return\"boolean\"==typeof t||\"number\"==typeof t||\"string\"==typeof t||null===t||w.isDate(t)||w.isArray(t)}function s(t,e){return e>t?-1:t>e?1:0}function c(t,e){var n,r;for(n=0;n<Math.min(t.length,e.length);n+=1)if(r=f(t[n],e[n]),0!==r)return r;return s(t.length,e.length)}function f(t,e){var n,r,i,o;if(void 0===t)return void 0===e?0:-1;if(void 0===e)return void 0===t?0:1;if(null===t)return null===e?0:-1;if(null===e)return null===t?0:1;if(\"number\"==typeof t)return\"number\"==typeof e?s(t,e):-1;if(\"number\"==typeof e)return\"number\"==typeof t?s(t,e):1;if(\"string\"==typeof t)return\"string\"==typeof e?s(t,e):-1;if(\"string\"==typeof e)return\"string\"==typeof t?s(t,e):1;if(\"boolean\"==typeof t)return\"boolean\"==typeof e?s(t,e):-1;if(\"boolean\"==typeof e)return\"boolean\"==typeof t?s(t,e):1;if(w.isDate(t))return w.isDate(e)?s(t.getTime(),e.getTime()):-1;if(w.isDate(e))return w.isDate(t)?s(t.getTime(),e.getTime()):1;if(w.isArray(t))return w.isArray(e)?c(t,e):-1;if(w.isArray(e))return w.isArray(t)?c(t,e):1;for(n=Object.keys(t).sort(),r=Object.keys(e).sort(),o=0;o<Math.min(n.length,r.length);o+=1)if(i=f(t[n[o]],e[r[o]]),0!==i)return i;return s(n.length,r.length)}function l(t){return function(e,n,r){var i=\"string\"==typeof n?n.split(\".\"):n;1===i.length?_[t](e,n,r):(e[i[0]]=e[i[0]]||{},x[t](e[i[0]],i.slice(1),r))}}function h(t,e){var n,i,o=Object.keys(e),a=k.map(o,function(t){return t[0]}),s=k.filter(a,function(t){return\"$\"===t});if(-1!==o.indexOf(\"_id\")&&e._id!==t._id)throw\"You cannot change a document's _id\";if(0!==s.length&&s.length!==a.length)throw\"You cannot mix modifiers and normal fields\";if(0===s.length?(n=u(e),n._id=t._id):(i=k.uniq(o),n=u(t),i.forEach(function(t){var r;if(!x[t])throw\"Unknown modifier \"+t;try{r=Object.keys(e[t])}catch(i){throw\"Modifier \"+t+\"'s argument must be an object\"}r.forEach(function(r){x[t](n,r,e[t][r])})})),r(n),t._id!==n._id)throw\"You can't change a document's _id\";return n}function p(t,e){var n,r,i=\"string\"==typeof e?e.split(\".\"):e;if(!t)return void 0;if(0===i.length)return t;if(1===i.length)return t[i[0]];if(w.isArray(t[i[0]])){if(n=parseInt(i[1],10),\"number\"==typeof n&&!isNaN(n))return p(t[i[0]][n],i.slice(2));for(r=new Array,n=0;n<t[i[0]].length;n+=1)r.push(p(t[i[0]][n],i.slice(1)));return r}return p(t[i[0]],i.slice(1))}function y(t,e){var n,r,i;if(null===t||\"string\"==typeof t||\"boolean\"==typeof t||\"number\"==typeof t||null===e||\"string\"==typeof e||\"boolean\"==typeof e||\"number\"==typeof e)return t===e;if(w.isDate(t)||w.isDate(e))return w.isDate(t)&&w.isDate(e)&&t.getTime()===e.getTime();if(w.isArray(t)||w.isArray(e)||void 0===t||void 0===e)return!1;try{n=Object.keys(t),r=Object.keys(e)}catch(o){return!1}if(n.length!==r.length)return!1;for(i=0;i<n.length;i+=1){if(-1===r.indexOf(n[i]))return!1;if(!y(t[n[i]],e[n[i]]))return!1}return!0}function d(t,e){return\"string\"==typeof t||\"number\"==typeof t||w.isDate(t)||\"string\"==typeof e||\"number\"==typeof e||w.isDate(e)?typeof t!=typeof e?!1:!0:!1}function g(t,e){var n,r,i,o;if(a(t)||a(e))return v({needAKey:t},\"needAKey\",e);for(n=Object.keys(e),o=0;o<n.length;o+=1)if(r=n[o],i=e[r],\"$\"===r[0]){if(!A[r])throw\"Unknown logical operator \"+r;if(!A[r](t,i))return!1}else if(!v(t,r,i))return!1;return!0}function v(t,e,n,r){var i,o,u,a,s=p(t,e);if(w.isArray(s)&&!r){if(null!==n&&\"object\"==typeof n&&!w.isRegExp(n))for(o=Object.keys(n),i=0;i<o.length;i+=1)if($[o[i]])return v(t,e,n,!0);for(i=0;i<s.length;i+=1)if(v({k:s[i]},\"k\",n))return!0;return!1}if(null!==n&&\"object\"==typeof n&&!w.isRegExp(n)){if(o=Object.keys(n),u=k.map(o,function(t){return t[0]}),a=k.filter(u,function(t){return\"$\"===t}),0!==a.length&&a.length!==u.length)throw\"You cannot mix operators and normal fields\";if(a.length>0){for(i=0;i<o.length;i+=1){if(!O[o[i]])throw\"Unknown comparison function \"+o[i];if(!O[o[i]](s,n[o[i]]))return!1}return!0}}return w.isRegExp(n)?O.$regex(s,n):y(s,n)?!0:!1}var m=function(){return{$$date:this.getTime()}},b=Date.prototype.toJSON,w=t(\"util\"),k=t(\"underscore\"),x={},_={},O={},A={},$={};_.$set=function(t,e,n){t[e]=n},_.$unset=function(t,e){delete t[e]},_.$push=function(t,e,n){if(t.hasOwnProperty(e)||(t[e]=[]),!w.isArray(t[e]))throw\"Can't $push an element on non-array values\";if(null!==n&&\"object\"==typeof n&&n.$each){if(Object.keys(n).length>1)throw\"Can't use another field in conjunction with $each\";if(!w.isArray(n.$each))throw\"$each requires an array value\";n.$each.forEach(function(n){t[e].push(n)})}else t[e].push(n)},_.$addToSet=function(t,e,n){var r=!0;if(t.hasOwnProperty(e)||(t[e]=[]),!w.isArray(t[e]))throw\"Can't $addToSet an element on non-array values\";if(null!==n&&\"object\"==typeof n&&n.$each){if(Object.keys(n).length>1)throw\"Can't use another field in conjunction with $each\";if(!w.isArray(n.$each))throw\"$each requires an array value\";n.$each.forEach(function(n){_.$addToSet(t,e,n)})}else t[e].forEach(function(t){0===f(t,n)&&(r=!1)}),r&&t[e].push(n)},_.$pop=function(t,e,n){if(!w.isArray(t[e]))throw\"Can't $pop an element from non-array values\";if(\"number\"!=typeof n)throw n+\" isn't an integer, can't use it with $pop\";0!==n&&(t[e]=n>0?t[e].slice(0,t[e].length-1):t[e].slice(1))},_.$pull=function(t,e,n){var r,i;if(!w.isArray(t[e]))throw\"Can't $pull an element from non-array values\";for(r=t[e],i=r.length-1;i>=0;i-=1)g(r[i],n)&&r.splice(i,1)},_.$inc=function(t,e,n){if(\"number\"!=typeof n)throw n+\" must be a number\";if(\"number\"!=typeof t[e]){if(k.has(t,e))throw\"Don't use the $inc modifier on non-number fields\";t[e]=n}else t[e]+=n},Object.keys(_).forEach(function(t){x[t]=l(t)}),O.$lt=function(t,e){return d(t,e)&&e>t},O.$lte=function(t,e){return d(t,e)&&e>=t},O.$gt=function(t,e){return d(t,e)&&t>e},O.$gte=function(t,e){return d(t,e)&&t>=e},O.$ne=function(t,e){return t?!y(t,e):!0},O.$in=function(t,e){var n;if(!w.isArray(e))throw\"$in operator called with a non-array\";for(n=0;n<e.length;n+=1)if(y(t,e[n]))return!0;return!1},O.$nin=function(t,e){if(!w.isArray(e))throw\"$nin operator called with a non-array\";return!O.$in(t,e)},O.$regex=function(t,e){if(!w.isRegExp(e))throw\"$regex operator called with non regular expression\";return\"string\"!=typeof t?!1:e.test(t)},O.$exists=function(t,e){return e=e||\"\"===e?!0:!1,void 0===t?!e:e},O.$size=function(t,e){if(!w.isArray(t))return!1;if(0!==e%1)throw\"$size operator called without an integer\";return t.length==e},$.$size=!0,A.$or=function(t,e){var n;if(!w.isArray(e))throw\"$or operator used without an array\";for(n=0;n<e.length;n+=1)if(g(t,e[n]))return!0;return!1},A.$and=function(t,e){var n;if(!w.isArray(e))throw\"$and operator used without an array\";for(n=0;n<e.length;n+=1)if(!g(t,e[n]))return!1;return!0},A.$not=function(t,e){return!g(t,e)},e.exports.serialize=i,e.exports.deserialize=o,e.exports.deepCopy=u,e.exports.checkObject=r,e.exports.isPrimitiveType=a,e.exports.modify=h,e.exports.getDotValue=p,e.exports.match=g,e.exports.areThingsEqual=y,e.exports.compareThings=f},{underscore:15,util:2}],9:[function(t,e){function n(t){this.db=t.db,this.db.inMemoryOnly=!0,this.db.filename=null,this.inMemoryOnly=!0}n.prototype.persistNewState=function(t,e){return e?e():void 0},n.prototype.loadDatabase=function(t){return t?t():void 0},e.exports=n},{}],10:[function(e,n){var r=e(\"__browserify_process\");!function(){function e(t){var e=!1;return function(){if(e)throw new Error(\"Callback was already called.\");e=!0,t.apply(i,arguments)}}var i,o,u={};i=this,null!=i&&(o=i.async),u.noConflict=function(){return i.async=o,u};var a=function(t,e){if(t.forEach)return t.forEach(e);for(var n=0;n<t.length;n+=1)e(t[n],n,t)},s=function(t,e){if(t.map)return t.map(e);var n=[];return a(t,function(t,r,i){n.push(e(t,r,i))}),n},c=function(t,e,n){return t.reduce?t.reduce(e,n):(a(t,function(t,r,i){n=e(n,t,r,i)}),n)},f=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e};\"undefined\"!=typeof r&&r.nextTick?(u.nextTick=r.nextTick,u.setImmediate=\"undefined\"!=typeof setImmediate?setImmediate:u.nextTick):\"function\"==typeof setImmediate?(u.nextTick=function(t){setImmediate(t)},u.setImmediate=u.nextTick):(u.nextTick=function(t){setTimeout(t,0)},u.setImmediate=u.nextTick),u.each=function(t,n,r){if(r=r||function(){},!t.length)return r();var i=0;a(t,function(o){n(o,e(function(e){e?(r(e),r=function(){}):(i+=1,i>=t.length&&r(null))}))})},u.forEach=u.each,u.eachSeries=function(t,e,n){if(n=n||function(){},!t.length)return n();var r=0,i=function(){e(t[r],function(e){e?(n(e),n=function(){}):(r+=1,r>=t.length?n(null):i())})};i()},u.forEachSeries=u.eachSeries,u.eachLimit=function(t,e,n,r){var i=l(e);i.apply(null,[t,n,r])},u.forEachLimit=u.eachLimit;var l=function(t){return function(e,n,r){if(r=r||function(){},!e.length||0>=t)return r();var i=0,o=0,u=0;!function a(){if(i>=e.length)return r();for(;t>u&&o<e.length;)o+=1,u+=1,n(e[o-1],function(t){t?(r(t),r=function(){}):(i+=1,u-=1,i>=e.length?r():a())})}()}},h=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[u.each].concat(e))}},p=function(t,e){return function(){var n=Array.prototype.slice.call(arguments);return e.apply(null,[l(t)].concat(n))}},y=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[u.eachSeries].concat(e))}},d=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n,r){i[t.index]=r,e(n)})},function(t){r(t,i)})};u.map=h(d),u.mapSeries=y(d),u.mapLimit=function(t,e,n,r){return g(e)(t,n,r)};var g=function(t){return p(t,d)};u.reduce=function(t,e,n,r){u.eachSeries(t,function(t,r){n(e,t,function(t,n){e=n,r(t)})},function(t){r(t,e)})},u.inject=u.reduce,u.foldl=u.reduce,u.reduceRight=function(t,e,n,r){var i=s(t,function(t){return t}).reverse();u.reduce(i,e,n,r)},u.foldr=u.reduceRight;var v=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n&&i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};u.filter=h(v),u.filterSeries=y(v),u.select=u.filter,u.selectSeries=u.filterSeries;var m=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n||i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};u.reject=h(m),u.rejectSeries=y(m);var b=function(t,e,n,r){t(e,function(t,e){n(t,function(n){n?(r(t),r=function(){}):e()})},function(){r()})};u.detect=h(b),u.detectSeries=y(b),u.some=function(t,e,n){u.each(t,function(t,r){e(t,function(t){t&&(n(!0),n=function(){}),r()})},function(){n(!1)})},u.any=u.some,u.every=function(t,e,n){u.each(t,function(t,r){e(t,function(t){t||(n(!1),n=function(){}),r()})},function(){n(!0)})},u.all=u.every,u.sortBy=function(t,e,n){u.map(t,function(t,n){e(t,function(e,r){e?n(e):n(null,{value:t,criteria:r})})},function(t,e){if(t)return n(t);var r=function(t,e){var n=t.criteria,r=e.criteria;return r>n?-1:n>r?1:0};n(null,s(e.sort(r),function(t){return t.value}))})},u.auto=function(t,e){e=e||function(){};var n=f(t);if(!n.length)return e(null);var r={},i=[],o=function(t){i.unshift(t)},s=function(t){for(var e=0;e<i.length;e+=1)if(i[e]===t)return i.splice(e,1),void 0},l=function(){a(i.slice(0),function(t){t()})};o(function(){f(r).length===n.length&&(e(null,r),e=function(){})}),a(n,function(n){var i=t[n]instanceof Function?[t[n]]:t[n],h=function(t){var i=Array.prototype.slice.call(arguments,1);if(i.length<=1&&(i=i[0]),t){var o={};a(f(r),function(t){o[t]=r[t]}),o[n]=i,e(t,o),e=function(){}}else r[n]=i,u.setImmediate(l)},p=i.slice(0,Math.abs(i.length-1))||[],y=function(){return c(p,function(t,e){return t&&r.hasOwnProperty(e)},!0)&&!r.hasOwnProperty(n)};if(y())i[i.length-1](h,r);else{var d=function(){y()&&(s(d),i[i.length-1](h,r))};o(d)}})},u.waterfall=function(t,e){if(e=e||function(){},t.constructor!==Array){var n=new Error(\"First argument to waterfall must be an array of functions\");return e(n)}if(!t.length)return e();var r=function(t){return function(n){if(n)e.apply(null,arguments),e=function(){};else{var i=Array.prototype.slice.call(arguments,1),o=t.next();o?i.push(r(o)):i.push(e),u.setImmediate(function(){t.apply(null,i)})}}};r(u.iterator(t))()};var w=function(t,e,n){if(n=n||function(){},e.constructor===Array)t.map(e,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},n);else{var r={};t.each(f(e),function(t,n){e[t](function(e){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),r[t]=i,n(e)})},function(t){n(t,r)})}};u.parallel=function(t,e){w({map:u.map,each:u.each},t,e)},u.parallelLimit=function(t,e,n){w({map:g(e),each:l(e)},t,n)},u.series=function(t,e){if(e=e||function(){},t.constructor===Array)u.mapSeries(t,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},e);else{var n={};u.eachSeries(f(t),function(e,r){t[e](function(t){var i=Array.prototype.slice.call(arguments,1);\ni.length<=1&&(i=i[0]),n[e]=i,r(t)})},function(t){e(t,n)})}},u.iterator=function(t){var e=function(n){var r=function(){return t.length&&t[n].apply(null,arguments),r.next()};return r.next=function(){return n<t.length-1?e(n+1):null},r};return e(0)},u.apply=function(t){var e=Array.prototype.slice.call(arguments,1);return function(){return t.apply(null,e.concat(Array.prototype.slice.call(arguments)))}};var k=function(t,e,n,r){var i=[];t(e,function(t,e){n(t,function(t,n){i=i.concat(n||[]),e(t)})},function(t){r(t,i)})};u.concat=h(k),u.concatSeries=y(k),u.whilst=function(t,e,n){t()?e(function(r){return r?n(r):(u.whilst(t,e,n),void 0)}):n()},u.doWhilst=function(t,e,n){t(function(r){return r?n(r):(e()?u.doWhilst(t,e,n):n(),void 0)})},u.until=function(t,e,n){t()?n():e(function(r){return r?n(r):(u.until(t,e,n),void 0)})},u.doUntil=function(t,e,n){t(function(r){return r?n(r):(e()?n():u.doUntil(t,e,n),void 0)})},u.queue=function(t,n){function r(t,e,r,i){e.constructor!==Array&&(e=[e]),a(e,function(e){var o={data:e,callback:\"function\"==typeof i?i:null};r?t.tasks.unshift(o):t.tasks.push(o),t.saturated&&t.tasks.length===n&&t.saturated(),u.setImmediate(t.process)})}void 0===n&&(n=1);var i=0,o={tasks:[],concurrency:n,saturated:null,empty:null,drain:null,push:function(t,e){r(o,t,!1,e)},unshift:function(t,e){r(o,t,!0,e)},process:function(){if(i<o.concurrency&&o.tasks.length){var n=o.tasks.shift();o.empty&&0===o.tasks.length&&o.empty(),i+=1;var r=function(){i-=1,n.callback&&n.callback.apply(n,arguments),o.drain&&0===o.tasks.length+i&&o.drain(),o.process()},u=e(r);t(n.data,u)}},length:function(){return o.tasks.length},running:function(){return i}};return o},u.cargo=function(t,e){var n=!1,r=[],i={tasks:r,payload:e,saturated:null,empty:null,drain:null,push:function(t,n){t.constructor!==Array&&(t=[t]),a(t,function(t){r.push({data:t,callback:\"function\"==typeof n?n:null}),i.saturated&&r.length===e&&i.saturated()}),u.setImmediate(i.process)},process:function o(){if(!n){if(0===r.length)return i.drain&&i.drain(),void 0;var u=\"number\"==typeof e?r.splice(0,e):r.splice(0),c=s(u,function(t){return t.data});i.empty&&i.empty(),n=!0,t(c,function(){n=!1;var t=arguments;a(u,function(e){e.callback&&e.callback.apply(null,t)}),o()})}},length:function(){return r.length},running:function(){return n}};return i};var x=function(t){return function(e){var n=Array.prototype.slice.call(arguments,1);e.apply(null,n.concat([function(e){var n=Array.prototype.slice.call(arguments,1);\"undefined\"!=typeof console&&(e?console.error&&console.error(e):console[t]&&a(n,function(e){console[t](e)}))}]))}};u.log=x(\"log\"),u.dir=x(\"dir\"),u.memoize=function(t,e){var n={},r={};e=e||function(t){return t};var i=function(){var i=Array.prototype.slice.call(arguments),o=i.pop(),u=e.apply(null,i);u in n?o.apply(null,n[u]):u in r?r[u].push(o):(r[u]=[o],t.apply(null,i.concat([function(){n[u]=arguments;var t=r[u];delete r[u];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,arguments)}])))};return i.memo=n,i.unmemoized=t,i},u.unmemoize=function(t){return function(){return(t.unmemoized||t).apply(null,arguments)}},u.times=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return u.map(r,e,n)},u.timesSeries=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return u.mapSeries(r,e,n)},u.compose=function(){var t=Array.prototype.reverse.call(arguments);return function(){var e=this,n=Array.prototype.slice.call(arguments),r=n.pop();u.reduce(t,n,function(t,n,r){n.apply(e,t.concat([function(){var t=arguments[0],e=Array.prototype.slice.call(arguments,1);r(t,e)}]))},function(t,n){r.apply(e,[t].concat(n))})}};var _=function(t,e){var n=function(){var n=this,r=Array.prototype.slice.call(arguments),i=r.pop();return t(e,function(t,e){t.apply(n,r.concat([e]))},i)};if(arguments.length>2){var r=Array.prototype.slice.call(arguments,2);return n.apply(this,r)}return n};u.applyEach=h(_),u.applyEachSeries=y(_),u.forever=function(t,e){function n(r){if(r){if(e)return e(r);throw r}t(n)}n()},\"undefined\"!=typeof t&&t.amd?t([],function(){return u}):\"undefined\"!=typeof n&&n.exports?n.exports=u:i.async=u}()},{__browserify_process:3}],11:[function(t,e){e.exports.BinarySearchTree=t(\"./lib/bst\"),e.exports.AVLTree=t(\"./lib/avltree\")},{\"./lib/avltree\":12,\"./lib/bst\":13}],12:[function(t,e){function n(t){this.tree=new r(t)}function r(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty(\"key\")&&(this.key=t.key),this.data=t.hasOwnProperty(\"value\")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||o.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||o.defaultCheckValueEquality}var i=t(\"./bst\"),o=t(\"./customUtils\"),u=t(\"util\");t(\"underscore\"),u.inherits(r,i),n._AVLTree=r,r.prototype.checkHeightCorrect=function(){var t,e;if(this.hasOwnProperty(\"key\")){if(this.left&&void 0===this.left.height)throw\"Undefined height for node \"+this.left.key;if(this.right&&void 0===this.right.height)throw\"Undefined height for node \"+this.right.key;if(void 0===this.height)throw\"Undefined height for node \"+this.key;if(t=this.left?this.left.height:0,e=this.right?this.right.height:0,this.height!==1+Math.max(t,e))throw\"Height constraint failed for node \"+this.key;this.left&&this.left.checkHeightCorrect(),this.right&&this.right.checkHeightCorrect()}},r.prototype.balanceFactor=function(){var t=this.left?this.left.height:0,e=this.right?this.right.height:0;return t-e},r.prototype.checkBalanceFactors=function(){if(Math.abs(this.balanceFactor())>1)throw\"Tree is unbalanced at node \"+this.key;this.left&&this.left.checkBalanceFactors(),this.right&&this.right.checkBalanceFactors()},r.prototype.checkIsAVLT=function(){r.super_.prototype.checkIsBST.call(this),this.checkHeightCorrect(),this.checkBalanceFactors()},n.prototype.checkIsAVLT=function(){this.tree.checkIsAVLT()},r.prototype.rightRotation=function(){var t,e,n,r,i=this,o=this.left;return o?(t=o.right,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.right=i,i.parent=o,i.left=t,t&&(t.parent=i),e=o.left?o.left.height:0,n=t?t.height:0,r=i.right?i.right.height:0,i.height=Math.max(n,r)+1,o.height=Math.max(e,i.height)+1,o):this},r.prototype.leftRotation=function(){var t,e,n,r,i=this,o=this.right;return o?(t=o.left,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.left=i,i.parent=o,i.right=t,t&&(t.parent=i),e=i.left?i.left.height:0,n=t?t.height:0,r=o.right?o.right.height:0,i.height=Math.max(e,n)+1,o.height=Math.max(r,i.height)+1,o):this},r.prototype.rightTooSmall=function(){return this.balanceFactor()<=1?this:(this.left.balanceFactor()<0&&this.left.leftRotation(),this.rightRotation())},r.prototype.leftTooSmall=function(){return this.balanceFactor()>=-1?this:(this.right.balanceFactor()>0&&this.right.rightRotation(),this.leftRotation())},r.prototype.rebalanceAlongPath=function(t){var e,n,r=this;if(!this.hasOwnProperty(\"key\"))return delete this.height,this;for(n=t.length-1;n>=0;n-=1)t[n].height=1+Math.max(t[n].left?t[n].left.height:0,t[n].right?t[n].right.height:0),t[n].balanceFactor()>1&&(e=t[n].rightTooSmall(),0===n&&(r=e)),t[n].balanceFactor()<-1&&(e=t[n].leftTooSmall(),0===n&&(r=e));return r},r.prototype.insert=function(t,e){var n=[],r=this;if(!this.hasOwnProperty(\"key\"))return this.key=t,this.data.push(e),this.height=1,this;for(;;){if(0===r.compareKeys(r.key,t)){if(r.unique)throw{message:\"Can't insert key \"+t+\", it violates the unique constraint\",key:t,errorType:\"uniqueViolated\"};return r.data.push(e),this}if(n.push(r),r.compareKeys(t,r.key)<0){if(!r.left){n.push(r.createLeftChild({key:t,value:e}));break}r=r.left}else{if(!r.right){n.push(r.createRightChild({key:t,value:e}));break}r=r.right}}return this.rebalanceAlongPath(n)},n.prototype.insert=function(t,e){var n=this.tree.insert(t,e);n&&(this.tree=n)},r.prototype.delete=function(t,e){var n,r=[],i=this,o=[];if(!this.hasOwnProperty(\"key\"))return this;for(;;){if(0===i.compareKeys(t,i.key))break;if(o.push(i),i.compareKeys(t,i.key)<0){if(!i.left)return this;i=i.left}else{if(!i.right)return this;i=i.right}}if(i.data.length>1&&e)return i.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,this;if(!i.left&&!i.right)return i===this?(delete i.key,i.data=[],delete i.height,this):(i.parent.left===i?i.parent.left=null:i.parent.right=null,this.rebalanceAlongPath(o));if(!i.left||!i.right)return n=i.left?i.left:i.right,i===this?(n.parent=null,n):(i.parent.left===i?(i.parent.left=n,n.parent=i.parent):(i.parent.right=n,n.parent=i.parent),this.rebalanceAlongPath(o));if(o.push(i),n=i.left,!n.right)return i.key=n.key,i.data=n.data,i.left=n.left,n.left&&(n.left.parent=i),this.rebalanceAlongPath(o);for(;;){if(!n.right)break;o.push(n),n=n.right}return i.key=n.key,i.data=n.data,n.parent.right=n.left,n.left&&(n.left.parent=n.parent),this.rebalanceAlongPath(o)},n.prototype.delete=function(t,e){var n=this.tree.delete(t,e);n&&(this.tree=n)},[\"getNumberOfKeys\",\"search\",\"betweenBounds\",\"prettyPrint\",\"executeOnEveryNode\"].forEach(function(t){n.prototype[t]=function(){return this.tree[t].apply(this.tree,arguments)}}),e.exports=n},{\"./bst\":13,\"./customUtils\":14,underscore:15,util:2}],13:[function(t,e){function n(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty(\"key\")&&(this.key=t.key),this.data=t.hasOwnProperty(\"value\")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||i.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||i.defaultCheckValueEquality}function r(t,e){var n;for(n=0;n<e.length;n+=1)t.push(e[n])}var i=t(\"./customUtils\");n.prototype.getMaxKeyDescendant=function(){return this.right?this.right.getMaxKeyDescendant():this},n.prototype.getMaxKey=function(){return this.getMaxKeyDescendant().key},n.prototype.getMinKeyDescendant=function(){return this.left?this.left.getMinKeyDescendant():this},n.prototype.getMinKey=function(){return this.getMinKeyDescendant().key},n.prototype.checkAllNodesFullfillCondition=function(t){this.hasOwnProperty(\"key\")&&(t(this.key,this.data),this.left&&this.left.checkAllNodesFullfillCondition(t),this.right&&this.right.checkAllNodesFullfillCondition(t))},n.prototype.checkNodeOrdering=function(){var t=this;this.hasOwnProperty(\"key\")&&(this.left&&(this.left.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)>=0)throw\"Tree with root \"+t.key+\" is not a binary search tree\"}),this.left.checkNodeOrdering()),this.right&&(this.right.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)<=0)throw\"Tree with root \"+t.key+\" is not a binary search tree\"}),this.right.checkNodeOrdering()))},n.prototype.checkInternalPointers=function(){if(this.left){if(this.left.parent!==this)throw\"Parent pointer broken for key \"+this.key;this.left.checkInternalPointers()}if(this.right){if(this.right.parent!==this)throw\"Parent pointer broken for key \"+this.key;this.right.checkInternalPointers()}},n.prototype.checkIsBST=function(){if(this.checkNodeOrdering(),this.checkInternalPointers(),this.parent)throw\"The root shouldn't have a parent\"},n.prototype.getNumberOfKeys=function(){var t;return this.hasOwnProperty(\"key\")?(t=1,this.left&&(t+=this.left.getNumberOfKeys()),this.right&&(t+=this.right.getNumberOfKeys()),t):0},n.prototype.createSimilar=function(t){return t=t||{},t.unique=this.unique,t.compareKeys=this.compareKeys,t.checkValueEquality=this.checkValueEquality,new this.constructor(t)},n.prototype.createLeftChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.left=e,e},n.prototype.createRightChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.right=e,e},n.prototype.insert=function(t,e){if(!this.hasOwnProperty(\"key\"))return this.key=t,this.data.push(e),void 0;if(0===this.compareKeys(this.key,t)){if(this.unique)throw{message:\"Can't insert key \"+t+\", it violates the unique constraint\",key:t,errorType:\"uniqueViolated\"};return this.data.push(e),void 0}this.compareKeys(t,this.key)<0?this.left?this.left.insert(t,e):this.createLeftChild({key:t,value:e}):this.right?this.right.insert(t,e):this.createRightChild({key:t,value:e})},n.prototype.search=function(t){return this.hasOwnProperty(\"key\")?0===this.compareKeys(this.key,t)?this.data:this.compareKeys(t,this.key)<0?this.left?this.left.search(t):[]:this.right?this.right.search(t):[]:[]},n.prototype.getLowerBoundMatcher=function(t){var e=this;return t.hasOwnProperty(\"$gt\")||t.hasOwnProperty(\"$gte\")?t.hasOwnProperty(\"$gt\")&&t.hasOwnProperty(\"$gte\")?0===e.compareKeys(t.$gte,t.$gt)?function(n){return e.compareKeys(n,t.$gt)>0}:e.compareKeys(t.$gte,t.$gt)>0?function(n){return e.compareKeys(n,t.$gte)>=0}:function(n){return e.compareKeys(n,t.$gt)>0}:t.hasOwnProperty(\"$gt\")?function(n){return e.compareKeys(n,t.$gt)>0}:function(n){return e.compareKeys(n,t.$gte)>=0}:function(){return!0}},n.prototype.getUpperBoundMatcher=function(t){var e=this;return t.hasOwnProperty(\"$lt\")||t.hasOwnProperty(\"$lte\")?t.hasOwnProperty(\"$lt\")&&t.hasOwnProperty(\"$lte\")?0===e.compareKeys(t.$lte,t.$lt)?function(n){return e.compareKeys(n,t.$lt)<0}:e.compareKeys(t.$lte,t.$lt)<0?function(n){return e.compareKeys(n,t.$lte)<=0}:function(n){return e.compareKeys(n,t.$lt)<0}:t.hasOwnProperty(\"$lt\")?function(n){return e.compareKeys(n,t.$lt)<0}:function(n){return e.compareKeys(n,t.$lte)<=0}:function(){return!0}},n.prototype.betweenBounds=function(t,e,n){var i=[];return this.hasOwnProperty(\"key\")?(e=e||this.getLowerBoundMatcher(t),n=n||this.getUpperBoundMatcher(t),e(this.key)&&this.left&&r(i,this.left.betweenBounds(t,e,n)),e(this.key)&&n(this.key)&&r(i,this.data),n(this.key)&&this.right&&r(i,this.right.betweenBounds(t,e,n)),i):[]},n.prototype.deleteIfLeaf=function(){return this.left||this.right?!1:this.parent?(this.parent.left===this?this.parent.left=null:this.parent.right=null,!0):(delete this.key,this.data=[],!0)},n.prototype.deleteIfOnlyOneChild=function(){var t;return this.left&&!this.right&&(t=this.left),!this.left&&this.right&&(t=this.right),t?this.parent?(this.parent.left===this?(this.parent.left=t,t.parent=this.parent):(this.parent.right=t,t.parent=this.parent),!0):(this.key=t.key,this.data=t.data,this.left=null,t.left&&(this.left=t.left,t.left.parent=this),this.right=null,t.right&&(this.right=t.right,t.right.parent=this),!0):!1},n.prototype.delete=function(t,e){var n,r=[],i=this;if(this.hasOwnProperty(\"key\")){if(this.compareKeys(t,this.key)<0)return this.left&&this.left.delete(t,e),void 0;if(this.compareKeys(t,this.key)>0)return this.right&&this.right.delete(t,e),void 0;if(0!==!this.compareKeys(t,this.key))return this.data.length>1&&e?(this.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,void 0):(this.deleteIfLeaf()||this.deleteIfOnlyOneChild()||(Math.random()>=.5?(n=this.left.getMaxKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.left=n.left,n.left&&(n.left.parent=n.parent)):(n.parent.right=n.left,n.left&&(n.left.parent=n.parent))):(n=this.right.getMinKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.right=n.right,n.right&&(n.right.parent=n.parent)):(n.parent.left=n.right,n.right&&(n.right.parent=n.parent)))),void 0)}},n.prototype.executeOnEveryNode=function(t){this.left&&this.left.executeOnEveryNode(t),t(this),this.right&&this.right.executeOnEveryNode(t)},n.prototype.prettyPrint=function(t,e){e=e||\"\",console.log(e+\"* \"+this.key),t&&console.log(e+\"* \"+this.data),(this.left||this.right)&&(this.left?this.left.prettyPrint(t,e+\"  \"):console.log(e+\"  *\"),this.right?this.right.prettyPrint(t,e+\"  \"):console.log(e+\"  *\"))},e.exports=n},{\"./customUtils\":14}],14:[function(t,e){function n(t){var e,r;return 0===t?[]:1===t?[0]:(e=n(t-1),r=Math.floor(Math.random()*t),e.splice(r,0,t-1),e)}function r(t,e){if(e>t)return-1;if(t>e)return 1;if(t===e)return 0;throw{message:\"Couldn't compare elements\",a:t,b:e}}function i(t,e){return t===e}e.exports.getRandomArray=n,e.exports.defaultCompareKeysFunction=r,e.exports.defaultCheckValueEquality=i},{}],15:[function(t,e,n){!function(){var t=this,r=t._,i={},o=Array.prototype,u=Object.prototype,a=Function.prototype,s=o.push,c=o.slice,f=o.concat,l=u.toString,h=u.hasOwnProperty,p=o.forEach,y=o.map,d=o.reduce,g=o.reduceRight,v=o.filter,m=o.every,b=o.some,w=o.indexOf,k=o.lastIndexOf,x=Array.isArray,_=Object.keys,O=a.bind,A=function(t){return t instanceof A?t:this instanceof A?(this._wrapped=t,void 0):new A(t)};\"undefined\"!=typeof n?(\"undefined\"!=typeof e&&e.exports&&(n=e.exports=A),n._=A):t._=A,A.VERSION=\"1.4.4\";var $=A.each=A.forEach=function(t,e,n){if(null!=t)if(p&&t.forEach===p)t.forEach(e,n);else if(t.length===+t.length){for(var r=0,o=t.length;o>r;r++)if(e.call(n,t[r],r,t)===i)return}else for(var u in t)if(A.has(t,u)&&e.call(n,t[u],u,t)===i)return};A.map=A.collect=function(t,e,n){var r=[];return null==t?r:y&&t.map===y?t.map(e,n):($(t,function(t,i,o){r[r.length]=e.call(n,t,i,o)}),r)};var j=\"Reduce of empty array with no initial value\";A.reduce=A.foldl=A.inject=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),d&&t.reduce===d)return r&&(e=A.bind(e,r)),i?t.reduce(e,n):t.reduce(e);if($(t,function(t,o,u){i?n=e.call(r,n,t,o,u):(n=t,i=!0)}),!i)throw new TypeError(j);return n},A.reduceRight=A.foldr=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),g&&t.reduceRight===g)return r&&(e=A.bind(e,r)),i?t.reduceRight(e,n):t.reduceRight(e);var o=t.length;if(o!==+o){var u=A.keys(t);o=u.length}if($(t,function(a,s,c){s=u?u[--o]:--o,i?n=e.call(r,n,t[s],s,c):(n=t[s],i=!0)}),!i)throw new TypeError(j);return n},A.find=A.detect=function(t,e,n){var r;return E(t,function(t,i,o){return e.call(n,t,i,o)?(r=t,!0):void 0}),r},A.filter=A.select=function(t,e,n){var r=[];return null==t?r:v&&t.filter===v?t.filter(e,n):($(t,function(t,i,o){e.call(n,t,i,o)&&(r[r.length]=t)}),r)},A.reject=function(t,e,n){return A.filter(t,function(t,r,i){return!e.call(n,t,r,i)},n)},A.every=A.all=function(t,e,n){e||(e=A.identity);var r=!0;return null==t?r:m&&t.every===m?t.every(e,n):($(t,function(t,o,u){return(r=r&&e.call(n,t,o,u))?void 0:i}),!!r)};var E=A.some=A.any=function(t,e,n){e||(e=A.identity);var r=!1;return null==t?r:b&&t.some===b?t.some(e,n):($(t,function(t,o,u){return r||(r=e.call(n,t,o,u))?i:void 0}),!!r)};A.contains=A.include=function(t,e){return null==t?!1:w&&t.indexOf===w?-1!=t.indexOf(e):E(t,function(t){return t===e})},A.invoke=function(t,e){var n=c.call(arguments,2),r=A.isFunction(e);return A.map(t,function(t){return(r?e:t[e]).apply(t,n)})},A.pluck=function(t,e){return A.map(t,function(t){return t[e]})},A.where=function(t,e,n){return A.isEmpty(e)?n?null:[]:A[n?\"find\":\"filter\"](t,function(t){for(var n in e)if(e[n]!==t[n])return!1;return!0})},A.findWhere=function(t,e){return A.where(t,e,!0)},A.max=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.max.apply(Math,t);if(!e&&A.isEmpty(t))return-1/0;var r={computed:-1/0,value:-1/0};return $(t,function(t,i,o){var u=e?e.call(n,t,i,o):t;u>=r.computed&&(r={value:t,computed:u})}),r.value},A.min=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.min.apply(Math,t);if(!e&&A.isEmpty(t))return 1/0;var r={computed:1/0,value:1/0};return $(t,function(t,i,o){var u=e?e.call(n,t,i,o):t;u<r.computed&&(r={value:t,computed:u})}),r.value},A.shuffle=function(t){var e,n=0,r=[];return $(t,function(t){e=A.random(n++),r[n-1]=r[e],r[e]=t}),r};var S=function(t){return A.isFunction(t)?t:function(e){return e[t]}};A.sortBy=function(t,e,n){var r=S(e);return A.pluck(A.map(t,function(t,e,i){return{value:t,index:e,criteria:r.call(n,t,e,i)}}).sort(function(t,e){var n=t.criteria,r=e.criteria;if(n!==r){if(n>r||void 0===n)return 1;if(r>n||void 0===r)return-1}return t.index<e.index?-1:1}),\"value\")};var D=function(t,e,n,r){var i={},o=S(e||A.identity);return $(t,function(e,u){var a=o.call(n,e,u,t);r(i,a,e)}),i};A.groupBy=function(t,e,n){return D(t,e,n,function(t,e,n){(A.has(t,e)?t[e]:t[e]=[]).push(n)})},A.countBy=function(t,e,n){return D(t,e,n,function(t,e){A.has(t,e)||(t[e]=0),t[e]++})},A.sortedIndex=function(t,e,n,r){n=null==n?A.identity:S(n);for(var i=n.call(r,e),o=0,u=t.length;u>o;){var a=o+u>>>1;n.call(r,t[a])<i?o=a+1:u=a}return o},A.toArray=function(t){return t?A.isArray(t)?c.call(t):t.length===+t.length?A.map(t,A.identity):A.values(t):[]},A.size=function(t){return null==t?0:t.length===+t.length?t.length:A.keys(t).length},A.first=A.head=A.take=function(t,e,n){return null==t?void 0:null==e||n?t[0]:c.call(t,0,e)},A.initial=function(t,e,n){return c.call(t,0,t.length-(null==e||n?1:e))},A.last=function(t,e,n){return null==t?void 0:null==e||n?t[t.length-1]:c.call(t,Math.max(t.length-e,0))},A.rest=A.tail=A.drop=function(t,e,n){return c.call(t,null==e||n?1:e)},A.compact=function(t){return A.filter(t,A.identity)};var M=function(t,e,n){return $(t,function(t){A.isArray(t)?e?s.apply(n,t):M(t,e,n):n.push(t)}),n};A.flatten=function(t,e){return M(t,e,[])},A.without=function(t){return A.difference(t,c.call(arguments,1))},A.uniq=A.unique=function(t,e,n,r){A.isFunction(e)&&(r=n,n=e,e=!1);var i=n?A.map(t,n,r):t,o=[],u=[];return $(i,function(n,r){(e?r&&u[u.length-1]===n:A.contains(u,n))||(u.push(n),o.push(t[r]))}),o},A.union=function(){return A.uniq(f.apply(o,arguments))},A.intersection=function(t){var e=c.call(arguments,1);return A.filter(A.uniq(t),function(t){return A.every(e,function(e){return A.indexOf(e,t)>=0})})},A.difference=function(t){var e=f.apply(o,c.call(arguments,1));return A.filter(t,function(t){return!A.contains(e,t)})},A.zip=function(){for(var t=c.call(arguments),e=A.max(A.pluck(t,\"length\")),n=new Array(e),r=0;e>r;r++)n[r]=A.pluck(t,\"\"+r);return n},A.object=function(t,e){if(null==t)return{};for(var n={},r=0,i=t.length;i>r;r++)e?n[t[r]]=e[r]:n[t[r][0]]=t[r][1];return n},A.indexOf=function(t,e,n){if(null==t)return-1;var r=0,i=t.length;if(n){if(\"number\"!=typeof n)return r=A.sortedIndex(t,e),t[r]===e?r:-1;r=0>n?Math.max(0,i+n):n}if(w&&t.indexOf===w)return t.indexOf(e,n);for(;i>r;r++)if(t[r]===e)return r;return-1},A.lastIndexOf=function(t,e,n){if(null==t)return-1;var r=null!=n;if(k&&t.lastIndexOf===k)return r?t.lastIndexOf(e,n):t.lastIndexOf(e);for(var i=r?n:t.length;i--;)if(t[i]===e)return i;return-1},A.range=function(t,e,n){arguments.length<=1&&(e=t||0,t=0),n=arguments[2]||1;for(var r=Math.max(Math.ceil((e-t)/n),0),i=0,o=new Array(r);r>i;)o[i++]=t,t+=n;return o},A.bind=function(t,e){if(t.bind===O&&O)return O.apply(t,c.call(arguments,1));var n=c.call(arguments,2);return function(){return t.apply(e,n.concat(c.call(arguments)))}},A.partial=function(t){var e=c.call(arguments,1);return function(){return t.apply(this,e.concat(c.call(arguments)))}},A.bindAll=function(t){var e=c.call(arguments,1);return 0===e.length&&(e=A.functions(t)),$(e,function(e){t[e]=A.bind(t[e],t)}),t},A.memoize=function(t,e){var n={};return e||(e=A.identity),function(){var r=e.apply(this,arguments);return A.has(n,r)?n[r]:n[r]=t.apply(this,arguments)}},A.delay=function(t,e){var n=c.call(arguments,2);return setTimeout(function(){return t.apply(null,n)},e)},A.defer=function(t){return A.delay.apply(A,[t,1].concat(c.call(arguments,1)))},A.throttle=function(t,e){var n,r,i,o,u=0,a=function(){u=new Date,i=null,o=t.apply(n,r)};return function(){var s=new Date,c=e-(s-u);return n=this,r=arguments,0>=c?(clearTimeout(i),i=null,u=s,o=t.apply(n,r)):i||(i=setTimeout(a,c)),o}},A.debounce=function(t,e,n){var r,i;return function(){var o=this,u=arguments,a=function(){r=null,n||(i=t.apply(o,u))},s=n&&!r;return clearTimeout(r),r=setTimeout(a,e),s&&(i=t.apply(o,u)),i}},A.once=function(t){var e,n=!1;return function(){return n?e:(n=!0,e=t.apply(this,arguments),t=null,e)}},A.wrap=function(t,e){return function(){var n=[t];return s.apply(n,arguments),e.apply(this,n)}},A.compose=function(){var t=arguments;return function(){for(var e=arguments,n=t.length-1;n>=0;n--)e=[t[n].apply(this,e)];return e[0]}},A.after=function(t,e){return 0>=t?e():function(){return--t<1?e.apply(this,arguments):void 0}},A.keys=_||function(t){if(t!==Object(t))throw new TypeError(\"Invalid object\");var e=[];for(var n in t)A.has(t,n)&&(e[e.length]=n);return e},A.values=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push(t[n]);return e},A.pairs=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push([n,t[n]]);return e},A.invert=function(t){var e={};for(var n in t)A.has(t,n)&&(e[t[n]]=n);return e},A.functions=A.methods=function(t){var e=[];for(var n in t)A.isFunction(t[n])&&e.push(n);return e.sort()},A.extend=function(t){return $(c.call(arguments,1),function(e){if(e)for(var n in e)t[n]=e[n]}),t},A.pick=function(t){var e={},n=f.apply(o,c.call(arguments,1));return $(n,function(n){n in t&&(e[n]=t[n])}),e},A.omit=function(t){var e={},n=f.apply(o,c.call(arguments,1));for(var r in t)A.contains(n,r)||(e[r]=t[r]);return e},A.defaults=function(t){return $(c.call(arguments,1),function(e){if(e)for(var n in e)null==t[n]&&(t[n]=e[n])}),t},A.clone=function(t){return A.isObject(t)?A.isArray(t)?t.slice():A.extend({},t):t},A.tap=function(t,e){return e(t),t};var N=function(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;if(null==t||null==e)return t===e;t instanceof A&&(t=t._wrapped),e instanceof A&&(e=e._wrapped);var i=l.call(t);if(i!=l.call(e))return!1;switch(i){case\"[object String]\":return t==String(e);case\"[object Number]\":return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case\"[object Date]\":case\"[object Boolean]\":return+t==+e;case\"[object RegExp]\":return t.source==e.source&&t.global==e.global&&t.multiline==e.multiline&&t.ignoreCase==e.ignoreCase}if(\"object\"!=typeof t||\"object\"!=typeof e)return!1;for(var o=n.length;o--;)if(n[o]==t)return r[o]==e;n.push(t),r.push(e);var u=0,a=!0;if(\"[object Array]\"==i){if(u=t.length,a=u==e.length)for(;u--&&(a=N(t[u],e[u],n,r)););}else{var s=t.constructor,c=e.constructor;if(s!==c&&!(A.isFunction(s)&&s instanceof s&&A.isFunction(c)&&c instanceof c))return!1;for(var f in t)if(A.has(t,f)&&(u++,!(a=A.has(e,f)&&N(t[f],e[f],n,r))))break;if(a){for(f in e)if(A.has(e,f)&&!u--)break;a=!u}}return n.pop(),r.pop(),a};A.isEqual=function(t,e){return N(t,e,[],[])},A.isEmpty=function(t){if(null==t)return!0;if(A.isArray(t)||A.isString(t))return 0===t.length;for(var e in t)if(A.has(t,e))return!1;return!0},A.isElement=function(t){return!(!t||1!==t.nodeType)},A.isArray=x||function(t){return\"[object Array]\"==l.call(t)},A.isObject=function(t){return t===Object(t)},$([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\"],function(t){A[\"is\"+t]=function(e){return l.call(e)==\"[object \"+t+\"]\"}}),A.isArguments(arguments)||(A.isArguments=function(t){return!(!t||!A.has(t,\"callee\"))}),\"function\"!=typeof/./&&(A.isFunction=function(t){return\"function\"==typeof t}),A.isFinite=function(t){return isFinite(t)&&!isNaN(parseFloat(t))},A.isNaN=function(t){return A.isNumber(t)&&t!=+t},A.isBoolean=function(t){return t===!0||t===!1||\"[object Boolean]\"==l.call(t)},A.isNull=function(t){return null===t},A.isUndefined=function(t){return void 0===t},A.has=function(t,e){return h.call(t,e)},A.noConflict=function(){return t._=r,this},A.identity=function(t){return t},A.times=function(t,e,n){for(var r=Array(t),i=0;t>i;i++)r[i]=e.call(n,i);return r},A.random=function(t,e){return null==e&&(e=t,t=0),t+Math.floor(Math.random()*(e-t+1))};var T={escape:{\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\",\"/\":\"&#x2F;\"}};T.unescape=A.invert(T.escape);var C={escape:new RegExp(\"[\"+A.keys(T.escape).join(\"\")+\"]\",\"g\"),unescape:new RegExp(\"(\"+A.keys(T.unescape).join(\"|\")+\")\",\"g\")};A.each([\"escape\",\"unescape\"],function(t){A[t]=function(e){return null==e?\"\":(\"\"+e).replace(C[t],function(e){return T[t][e]})}}),A.result=function(t,e){if(null==t)return null;var n=t[e];return A.isFunction(n)?n.call(t):n},A.mixin=function(t){$(A.functions(t),function(e){var n=A[e]=t[e];A.prototype[e]=function(){var t=[this._wrapped];return s.apply(t,arguments),F.call(this,n.apply(A,t))}})};var P=0;A.uniqueId=function(t){var e=++P+\"\";return t?t+e:e},A.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var I=/(.)^/,K={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"\t\":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},q=/\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;A.template=function(t,e,n){var r;n=A.defaults({},n,A.templateSettings);var i=new RegExp([(n.escape||I).source,(n.interpolate||I).source,(n.evaluate||I).source].join(\"|\")+\"|$\",\"g\"),o=0,u=\"__p+='\";t.replace(i,function(e,n,r,i,a){return u+=t.slice(o,a).replace(q,function(t){return\"\\\\\"+K[t]}),n&&(u+=\"'+\\n((__t=(\"+n+\"))==null?'':_.escape(__t))+\\n'\"),r&&(u+=\"'+\\n((__t=(\"+r+\"))==null?'':__t)+\\n'\"),i&&(u+=\"';\\n\"+i+\"\\n__p+='\"),o=a+e.length,e}),u+=\"';\\n\",n.variable||(u=\"with(obj||{}){\\n\"+u+\"}\\n\"),u=\"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\"+u+\"return __p;\\n\";try{r=new Function(n.variable||\"obj\",\"_\",u)}catch(a){throw a.source=u,a}if(e)return r(e,A);var s=function(t){return r.call(this,t,A)};return s.source=\"function(\"+(n.variable||\"obj\")+\"){\\n\"+u+\"}\",s},A.chain=function(t){return A(t).chain()};var F=function(t){return this._chain?A(t).chain():t};A.mixin(A),$([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(t){var e=o[t];A.prototype[t]=function(){var n=this._wrapped;return e.apply(n,arguments),\"shift\"!=t&&\"splice\"!=t||0!==n.length||delete n[0],F.call(this,n)}}),$([\"concat\",\"join\",\"slice\"],function(t){var e=o[t];A.prototype[t]=function(){return F.call(this,e.apply(this._wrapped,arguments))}}),A.extend(A.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}.call(this)},{}]},{},[5])(5)});",";(function(){\r\n\r\n\r\n// CommonJS require()\r\n\r\nfunction require(p){\r\n    var path = require.resolve(p)\r\n      , mod = require.modules[path];\r\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\r\n    if (!mod.exports) {\r\n      mod.exports = {};\r\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\r\n    }\r\n    return mod.exports;\r\n  }\r\n\r\nrequire.modules = {};\r\n\r\nrequire.resolve = function (path){\r\n    var orig = path\r\n      , reg = path + '.js'\r\n      , index = path + '/index.js';\r\n    return require.modules[reg] && reg\r\n      || require.modules[index] && index\r\n      || orig;\r\n  };\r\n\r\nrequire.register = function (path, fn){\r\n    require.modules[path] = fn;\r\n  };\r\n\r\nrequire.relative = function (parent) {\r\n    return function(p){\r\n      if ('.' != p.charAt(0)) return require(p);\r\n      \r\n      var path = parent.split('/')\r\n        , segs = p.split('/');\r\n      path.pop();\r\n      \r\n      for (var i = 0; i < segs.length; i++) {\r\n        var seg = segs[i];\r\n        if ('..' == seg) path.pop();\r\n        else if ('.' != seg) path.push(seg);\r\n      }\r\n\r\n      return require(path.join('/'));\r\n    };\r\n  };\r\n\r\n\r\nrequire.register(\"browser/debug.js\", function(module, exports, require){\r\n\r\nmodule.exports = function(type){\r\n  return function(){\r\n    \r\n  }\r\n};\r\n}); // module: browser/debug.js\r\n\r\nrequire.register(\"browser/diff.js\", function(module, exports, require){\r\n\r\n}); // module: browser/diff.js\r\n\r\nrequire.register(\"browser/events.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nexports.EventEmitter = EventEmitter;\r\n\r\n/**\r\n * Check if `obj` is an array.\r\n */\r\n\r\nfunction isArray(obj) {\r\n  return '[object Array]' == {}.toString.call(obj);\r\n}\r\n\r\n/**\r\n * Event emitter constructor.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction EventEmitter(){};\r\n\r\n/**\r\n * Adds a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.on = function (name, fn) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = fn;\r\n  } else if (isArray(this.$events[name])) {\r\n    this.$events[name].push(fn);\r\n  } else {\r\n    this.$events[name] = [this.$events[name], fn];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n/**\r\n * Adds a volatile listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.once = function (name, fn) {\r\n  var self = this;\r\n\r\n  function on () {\r\n    self.removeListener(name, on);\r\n    fn.apply(this, arguments);\r\n  };\r\n\r\n  on.listener = fn;\r\n  this.on(name, on);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeListener = function (name, fn) {\r\n  if (this.$events && this.$events[name]) {\r\n    var list = this.$events[name];\r\n\r\n    if (isArray(list)) {\r\n      var pos = -1;\r\n\r\n      for (var i = 0, l = list.length; i < l; i++) {\r\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n          pos = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (pos < 0) {\r\n        return this;\r\n      }\r\n\r\n      list.splice(pos, 1);\r\n\r\n      if (!list.length) {\r\n        delete this.$events[name];\r\n      }\r\n    } else if (list === fn || (list.listener && list.listener === fn)) {\r\n      delete this.$events[name];\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes all listeners for an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeAllListeners = function (name) {\r\n  if (name === undefined) {\r\n    this.$events = {};\r\n    return this;\r\n  }\r\n\r\n  if (this.$events && this.$events[name]) {\r\n    this.$events[name] = null;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Gets all listeners for a certain event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.listeners = function (name) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = [];\r\n  }\r\n\r\n  if (!isArray(this.$events[name])) {\r\n    this.$events[name] = [this.$events[name]];\r\n  }\r\n\r\n  return this.$events[name];\r\n};\r\n\r\n/**\r\n * Emits an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.emit = function (name) {\r\n  if (!this.$events) {\r\n    return false;\r\n  }\r\n\r\n  var handler = this.$events[name];\r\n\r\n  if (!handler) {\r\n    return false;\r\n  }\r\n\r\n  var args = [].slice.call(arguments, 1);\r\n\r\n  if ('function' == typeof handler) {\r\n    handler.apply(this, args);\r\n  } else if (isArray(handler)) {\r\n    var listeners = handler.slice();\r\n\r\n    for (var i = 0, l = listeners.length; i < l; i++) {\r\n      listeners[i].apply(this, args);\r\n    }\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n}); // module: browser/events.js\r\n\r\nrequire.register(\"browser/fs.js\", function(module, exports, require){\r\n\r\n}); // module: browser/fs.js\r\n\r\nrequire.register(\"browser/path.js\", function(module, exports, require){\r\n\r\n}); // module: browser/path.js\r\n\r\nrequire.register(\"browser/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nmodule.exports = Progress;\r\n\r\n/**\r\n * Initialize a new `Progress` indicator.\r\n */\r\n\r\nfunction Progress() {\r\n  this.percent = 0;\r\n  this.size(0);\r\n  this.fontSize(11);\r\n  this.font('helvetica, arial, sans-serif');\r\n}\r\n\r\n/**\r\n * Set progress size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.size = function(n){\r\n  this._size = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set text to `str`.\r\n *\r\n * @param {String} str\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.text = function(str){\r\n  this._text = str;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.fontSize = function(n){\r\n  this._fontSize = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font `family`.\r\n *\r\n * @param {String} family\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.font = function(family){\r\n  this._font = family;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Update percentage to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.update = function(n){\r\n  this.percent = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Draw on `ctx`.\r\n *\r\n * @param {CanvasRenderingContext2d} ctx\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.draw = function(ctx){\r\n  var percent = Math.min(this.percent, 100)\r\n    , size = this._size\r\n    , half = size / 2\r\n    , x = half\r\n    , y = half\r\n    , rad = half - 1\r\n    , fontSize = this._fontSize;\r\n\r\n  ctx.font = fontSize + 'px ' + this._font;\r\n\r\n  var angle = Math.PI * 2 * (percent / 100);\r\n  ctx.clearRect(0, 0, size, size);\r\n\r\n  // outer circle\r\n  ctx.strokeStyle = '#9f9f9f';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad, 0, angle, false);\r\n  ctx.stroke();\r\n\r\n  // inner circle\r\n  ctx.strokeStyle = '#eee';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad - 1, 0, angle, true);\r\n  ctx.stroke();\r\n\r\n  // text\r\n  var text = this._text || (percent | 0) + '%'\r\n    , w = ctx.measureText(text).width;\r\n\r\n  ctx.fillText(\r\n      text\r\n    , x - w / 2 + 1\r\n    , y + fontSize / 2 - 1);\r\n\r\n  return this;\r\n};\r\n\r\n}); // module: browser/progress.js\r\n\r\nrequire.register(\"browser/tty.js\", function(module, exports, require){\r\n\r\nexports.isatty = function(){\r\n  return true;\r\n};\r\n\r\nexports.getWindowSize = function(){\r\n  return [window.innerHeight, window.innerWidth];\r\n};\r\n}); // module: browser/tty.js\r\n\r\nrequire.register(\"context.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Context`.\r\n */\r\n\r\nmodule.exports = Context;\r\n\r\n/**\r\n * Initialize a new `Context`.\r\n *\r\n * @api private\r\n */\r\n\r\nfunction Context(){}\r\n\r\n/**\r\n * Set or get the context `Runnable` to `runnable`.\r\n *\r\n * @param {Runnable} runnable\r\n * @return {Context}\r\n * @api private\r\n */\r\n\r\nContext.prototype.runnable = function(runnable){\r\n  if (0 == arguments.length) return this._runnable;\r\n  this.test = this._runnable = runnable;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test timeout `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.timeout = function(ms){\r\n  this.runnable().timeout(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test slowness threshold `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.slow = function(ms){\r\n  this.runnable().slow(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Inspect the context void of `._runnable`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nContext.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_runnable' == key) return;\r\n    if ('test' == key) return;\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n}); // module: context.js\r\n\r\nrequire.register(\"hook.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Hook`.\r\n */\r\n\r\nmodule.exports = Hook;\r\n\r\n/**\r\n * Initialize a new `Hook` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Hook(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.type = 'hook';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nHook.prototype = new Runnable;\r\nHook.prototype.constructor = Hook;\r\n\r\n\r\n/**\r\n * Get or set the test `err`.\r\n *\r\n * @param {Error} err\r\n * @return {Error}\r\n * @api public\r\n */\r\n\r\nHook.prototype.error = function(err){\r\n  if (0 == arguments.length) {\r\n    var err = this._error;\r\n    this._error = null;\r\n    return err;\r\n  }\r\n\r\n  this._error = err;\r\n};\r\n\r\n\r\n}); // module: hook.js\r\n\r\nrequire.register(\"interfaces/bdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * BDD-style interface:\r\n * \r\n *      describe('Array', function(){\r\n *        describe('#indexOf()', function(){\r\n *          it('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          it('should return the index when present', function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n * \r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n  \r\n    context.describe = context.context = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn();\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Pending describe.\r\n     */\r\n\r\n    context.xdescribe =\r\n    context.xcontext =\r\n    context.describe.skip = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suite.pending = true;\r\n      suites.unshift(suite);\r\n      fn();\r\n      suites.shift();\r\n    };\r\n\r\n    /**\r\n     * Exclusive suite.\r\n     */\r\n\r\n    context.describe.only = function(title, fn){\r\n      var suite = context.describe(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.it = context.specify = function(title, fn){\r\n      var suite = suites[0];\r\n      if (suite.pending) var fn = null;\r\n      var test = new Test(title, fn);\r\n      suite.addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.it.only = function(title, fn){\r\n      var test = context.it(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.xit =\r\n    context.xspecify =\r\n    context.it.skip = function(title){\r\n      context.it(title);\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/bdd.js\r\n\r\nrequire.register(\"interfaces/exports.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n * \r\n *     exports.Array = {\r\n *       '#indexOf()': {\r\n *         'should return -1 when the value is not present': function(){\r\n *           \r\n *         },\r\n *\r\n *         'should return the correct index when the value is present': function(){\r\n *           \r\n *         }\r\n *       }\r\n *     };\r\n * \r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('require', visit);\r\n\r\n  function visit(obj) {\r\n    var suite;\r\n    for (var key in obj) {\r\n      if ('function' == typeof obj[key]) {\r\n        var fn = obj[key];\r\n        switch (key) {\r\n          case 'before':\r\n            suites[0].beforeAll(fn);\r\n            break;\r\n          case 'after':\r\n            suites[0].afterAll(fn);\r\n            break;\r\n          case 'beforeEach':\r\n            suites[0].beforeEach(fn);\r\n            break;\r\n          case 'afterEach':\r\n            suites[0].afterEach(fn);\r\n            break;\r\n          default:\r\n            suites[0].addTest(new Test(key, fn));\r\n        }\r\n      } else {\r\n        var suite = Suite.create(suites[0], key);\r\n        suites.unshift(suite);\r\n        visit(obj[key]);\r\n        suites.shift();\r\n      }\r\n    }\r\n  }\r\n};\r\n}); // module: interfaces/exports.js\r\n\r\nrequire.register(\"interfaces/index.js\", function(module, exports, require){\r\n\r\nexports.bdd = require('./bdd');\r\nexports.tdd = require('./tdd');\r\nexports.qunit = require('./qunit');\r\nexports.exports = require('./exports');\r\n\r\n}); // module: interfaces/index.js\r\n\r\nrequire.register(\"interfaces/qunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * QUnit-style interface:\r\n * \r\n *     suite('Array');\r\n *     \r\n *     test('#length', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.length == 3);\r\n *     });\r\n *     \r\n *     test('#indexOf()', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.indexOf(1) == 0);\r\n *       ok(arr.indexOf(2) == 1);\r\n *       ok(arr.indexOf(3) == 2);\r\n *     });\r\n *     \r\n *     suite('String');\r\n *     \r\n *     test('#length', function(){\r\n *       ok('foo'.length == 3);\r\n *     });\r\n * \r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`.\r\n     */\r\n  \r\n    context.suite = function(title){\r\n      if (suites.length > 1) suites.shift();\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      suites[0].addTest(new Test(title, fn));\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/qunit.js\r\n\r\nrequire.register(\"interfaces/tdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *      suite('Array', function(){\r\n *        suite('#indexOf()', function(){\r\n *          suiteSetup(function(){\r\n *\r\n *          });\r\n *          \r\n *          test('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          test('should return the index when present', function(){\r\n *\r\n *          });\r\n *\r\n *          suiteTeardown(function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.setup = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.teardown = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before the suite.\r\n     */\r\n\r\n    context.suiteSetup = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after the suite.\r\n     */\r\n\r\n    context.suiteTeardown = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.suite = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn();\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.suite.only = function(title, fn){\r\n      var suite = context.suite(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      var test = new Test(title, fn);\r\n      suites[0].addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.test.only = function(title, fn){\r\n      var test = context.test(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/tdd.js\r\n\r\nrequire.register(\"mocha.js\", function(module, exports, require){\r\n/*!\r\n * mocha\r\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar path = require('browser/path')\r\n  , utils = require('./utils');\r\n\r\n/**\r\n * Expose `Mocha`.\r\n */\r\n\r\nexports = module.exports = Mocha;\r\n\r\n/**\r\n * Expose internals.\r\n */\r\n\r\nexports.utils = utils;\r\nexports.interfaces = require('./interfaces');\r\nexports.reporters = require('./reporters');\r\nexports.Runnable = require('./runnable');\r\nexports.Context = require('./context');\r\nexports.Runner = require('./runner');\r\nexports.Suite = require('./suite');\r\nexports.Hook = require('./hook');\r\nexports.Test = require('./test');\r\n\r\n/**\r\n * Return image `name` path.\r\n *\r\n * @param {String} name\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction image(name) {\r\n  return __dirname + '/../images/' + name + '.png';\r\n}\r\n\r\n/**\r\n * Setup mocha with `options`.\r\n *\r\n * Options:\r\n *\r\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\r\n *   - `reporter` reporter instance, defaults to `mocha.reporters.Dot`\r\n *   - `globals` array of accepted globals\r\n *   - `timeout` timeout in milliseconds\r\n *   - `slow` milliseconds to wait before considering a test slow\r\n *   - `ignoreLeaks` ignore global leaks\r\n *   - `grep` string or regexp to filter tests with\r\n *\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Mocha(options) {\r\n  options = options || {};\r\n  this.files = [];\r\n  this.options = options;\r\n  this.grep(options.grep);\r\n  this.suite = new exports.Suite('', new exports.Context);\r\n  this.ui(options.ui);\r\n  this.reporter(options.reporter);\r\n  if (options.timeout) this.timeout(options.timeout);\r\n  if (options.slow) this.slow(options.slow);\r\n}\r\n\r\n/**\r\n * Add test `file`.\r\n *\r\n * @param {String} file\r\n * @api public\r\n */\r\n\r\nMocha.prototype.addFile = function(file){\r\n  this.files.push(file);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set reporter to `reporter`, defaults to \"dot\".\r\n *\r\n * @param {String|Function} reporter name of a reporter or a reporter constructor\r\n * @api public\r\n */\r\n\r\nMocha.prototype.reporter = function(reporter){\r\n  if ('function' == typeof reporter) {\r\n    this._reporter = reporter;\r\n  } else {\r\n    reporter = reporter || 'dot';\r\n    try {\r\n      this._reporter = require('./reporters/' + reporter);\r\n    } catch (err) {\r\n      this._reporter = require(reporter);\r\n    }\r\n    if (!this._reporter) throw new Error('invalid reporter \"' + reporter + '\"');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test UI `name`, defaults to \"bdd\".\r\n *\r\n * @param {String} bdd\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ui = function(name){\r\n  name = name || 'bdd';\r\n  this._ui = exports.interfaces[name];\r\n  if (!this._ui) throw new Error('invalid interface \"' + name + '\"');\r\n  this._ui = this._ui(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Load registered files.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype.loadFiles = function(fn){\r\n  var self = this;\r\n  var suite = this.suite;\r\n  var pending = this.files.length;\r\n  this.files.forEach(function(file){\r\n    file = path.resolve(file);\r\n    suite.emit('pre-require', global, file, self);\r\n    suite.emit('require', require(file), file, self);\r\n    suite.emit('post-require', global, file, self);\r\n    --pending || (fn && fn());\r\n  });\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype._growl = function(runner, reporter) {\r\n  var notify = require('growl');\r\n\r\n  runner.on('end', function(){\r\n    var stats = reporter.stats;\r\n    if (stats.failures) {\r\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\r\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\r\n    } else {\r\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\r\n          name: 'mocha'\r\n        , title: 'Passed'\r\n        , image: image('ok')\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Add regexp to grep, if `re` is a string it is escaped.\r\n *\r\n * @param {RegExp|String} re\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.grep = function(re){\r\n  this.options.grep = 'string' == typeof re\r\n    ? new RegExp(utils.escapeRegexp(re))\r\n    : re;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Invert `.grep()` matches.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.invert = function(){\r\n  this.options.invert = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore global leaks.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ignoreLeaks = function(){\r\n  this.options.ignoreLeaks = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable global leak checking.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.checkLeaks = function(){\r\n  this.options.ignoreLeaks = false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.growl = function(){\r\n  this.options.growl = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore `globals` array or string.\r\n *\r\n * @param {Array|String} globals\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.globals = function(globals){\r\n  this.options.globals = (this.options.globals || []).concat(globals);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the timeout in milliseconds.\r\n *\r\n * @param {Number} timeout\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.timeout = function(timeout){\r\n  this.suite.timeout(timeout);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slowness threshold in milliseconds.\r\n *\r\n * @param {Number} slow\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.slow = function(slow){\r\n  this.suite.slow(slow);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run tests and invoke `fn()` when complete.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.run = function(fn){\r\n  if (this.files.length) this.loadFiles();\r\n  var suite = this.suite;\r\n  var options = this.options;\r\n  var runner = new exports.Runner(suite);\r\n  var reporter = new this._reporter(runner);\r\n  runner.ignoreLeaks = options.ignoreLeaks;\r\n  if (options.grep) runner.grep(options.grep, options.invert);\r\n  if (options.globals) runner.globals(options.globals);\r\n  if (options.growl) this._growl(runner, reporter);\r\n  return runner.run(fn);\r\n};\r\n\r\n}); // module: mocha.js\r\n\r\nrequire.register(\"ms.js\", function(module, exports, require){\r\n\r\n/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * @param {String|Number} val\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val){\r\n  if ('string' == typeof val) return parse(val);\r\n  return format(val);\r\n}\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  var m = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\r\n  if (!m) return;\r\n  var n = parseFloat(m[1]);\r\n  var type = (m[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'y':\r\n      return n * 31557600000;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * 86400000;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'h':\r\n      return n * 3600000;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'm':\r\n      return n * 60000;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 's':\r\n      return n * 1000;\r\n    case 'ms':\r\n      return n;\r\n  }\r\n}\r\n\r\n/**\r\n * Format the given `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nfunction format(ms) {\r\n  if (ms == d) return (ms / d) + ' day';\r\n  if (ms > d) return (ms / d) + ' days';\r\n  if (ms == h) return (ms / h) + ' hour';\r\n  if (ms > h) return (ms / h) + ' hours';\r\n  if (ms == m) return (ms / m) + ' minute';\r\n  if (ms > m) return (ms / m) + ' minutes';\r\n  if (ms == s) return (ms / s) + ' second';\r\n  if (ms > s) return (ms / s) + ' seconds';\r\n  return ms + ' ms';\r\n}\r\n}); // module: ms.js\r\n\r\nrequire.register(\"reporters/base.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar tty = require('browser/tty')\r\n  , diff = require('browser/diff')\r\n  , ms = require('../ms');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Check if both stdio streams are associated with a tty.\r\n */\r\n\r\nvar isatty = tty.isatty(1) && tty.isatty(2);\r\n\r\n/**\r\n * Expose `Base`.\r\n */\r\n\r\nexports = module.exports = Base;\r\n\r\n/**\r\n * Enable coloring by default.\r\n */\r\n\r\nexports.useColors = isatty;\r\n\r\n/**\r\n * Default color map.\r\n */\r\n\r\nexports.colors = {\r\n    'pass': 90\r\n  , 'fail': 31\r\n  , 'bright pass': 92\r\n  , 'bright fail': 91\r\n  , 'bright yellow': 93\r\n  , 'pending': 36\r\n  , 'suite': 0\r\n  , 'error title': 0\r\n  , 'error message': 31\r\n  , 'error stack': 90\r\n  , 'checkmark': 32\r\n  , 'fast': 90\r\n  , 'medium': 33\r\n  , 'slow': 31\r\n  , 'green': 32\r\n  , 'light': 90\r\n  , 'diff gutter': 90\r\n  , 'diff added': 42\r\n  , 'diff removed': 41\r\n};\r\n\r\n/**\r\n * Color `str` with the given `type`,\r\n * allowing colors to be disabled,\r\n * as well as user-defined color\r\n * schemes.\r\n *\r\n * @param {String} type\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nvar color = exports.color = function(type, str) {\r\n  if (!exports.useColors) return str;\r\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Expose term window size, with some\r\n * defaults for when stderr is not a tty.\r\n */\r\n\r\nexports.window = {\r\n  width: isatty\r\n    ? process.stdout.getWindowSize\r\n      ? process.stdout.getWindowSize(1)[0]\r\n      : tty.getWindowSize()[1]\r\n    : 75\r\n};\r\n\r\n/**\r\n * Expose some basic cursor interactions\r\n * that are common among reporters.\r\n */\r\n\r\nexports.cursor = {\r\n  hide: function(){\r\n    process.stdout.write('\\u001b[?25l');\r\n  },\r\n\r\n  show: function(){\r\n    process.stdout.write('\\u001b[?25h');\r\n  },\r\n\r\n  deleteLine: function(){\r\n    process.stdout.write('\\u001b[2K');\r\n  },\r\n\r\n  beginningOfLine: function(){\r\n    process.stdout.write('\\u001b[0G');\r\n  },\r\n\r\n  CR: function(){\r\n    exports.cursor.deleteLine();\r\n    exports.cursor.beginningOfLine();\r\n  }\r\n};\r\n\r\n/**\r\n * Outut the given `failures` as a list.\r\n *\r\n * @param {Array} failures\r\n * @api public\r\n */\r\n\r\nexports.list = function(failures){\r\n  console.error();\r\n  failures.forEach(function(test, i){\r\n    // format\r\n    var fmt = color('error title', '  %s) %s:\\n')\r\n      + color('error message', '     %s')\r\n      + color('error stack', '\\n%s\\n');\r\n\r\n    // msg\r\n    var err = test.err\r\n      , message = err.message || ''\r\n      , stack = err.stack || message\r\n      , index = stack.indexOf(message) + message.length\r\n      , msg = stack.slice(0, index)\r\n      , actual = err.actual\r\n      , expected = err.expected;\r\n\r\n    // actual / expected diff\r\n    if ('string' == typeof actual && 'string' == typeof expected) {\r\n      var len = Math.max(actual.length, expected.length);\r\n\r\n      if (len < 20) msg = errorDiff(err, 'Chars');\r\n      else msg = errorDiff(err, 'Words');\r\n\r\n      // linenos\r\n      var lines = msg.split('\\n');\r\n      if (lines.length > 4) {\r\n        var width = String(lines.length).length;\r\n        msg = lines.map(function(str, i){\r\n          return pad(++i, width) + ' |' + ' ' + str;\r\n        }).join('\\n');\r\n      }\r\n\r\n      // legend\r\n      msg = '\\n'\r\n        + color('diff removed', 'actual')\r\n        + ' '\r\n        + color('diff added', 'expected')\r\n        + '\\n\\n'\r\n        + msg\r\n        + '\\n';\r\n\r\n      // indent\r\n      msg = msg.replace(/^/gm, '      ');\r\n\r\n      fmt = color('error title', '  %s) %s:\\n%s')\r\n        + color('error stack', '\\n%s\\n');\r\n    }\r\n\r\n    // indent stack trace without msg\r\n    stack = stack.slice(index ? index + 1 : index)\r\n      .replace(/^/gm, '  ');\r\n\r\n    console.error(fmt, (i + 1), test.fullTitle(), msg, stack);\r\n  });\r\n};\r\n\r\n/**\r\n * Initialize a new `Base` reporter.\r\n *\r\n * All other reporters generally\r\n * inherit from this reporter, providing\r\n * stats such as test duration, number\r\n * of tests passed / failed etc.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Base(runner) {\r\n  var self = this\r\n    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }\r\n    , failures = this.failures = [];\r\n\r\n  if (!runner) return;\r\n  this.runner = runner;\r\n\r\n  runner.on('start', function(){\r\n    stats.start = new Date;\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    stats.suites = stats.suites || 0;\r\n    suite.root || stats.suites++;\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    stats.tests = stats.tests || 0;\r\n    stats.tests++;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    stats.passes = stats.passes || 0;\r\n\r\n    var medium = test.slow() / 2;\r\n    test.speed = test.duration > test.slow()\r\n      ? 'slow'\r\n      : test.duration > medium\r\n        ? 'medium'\r\n        : 'fast';\r\n\r\n    stats.passes++;\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    stats.failures = stats.failures || 0;\r\n    stats.failures++;\r\n    test.err = err;\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    stats.end = new Date;\r\n    stats.duration = new Date - stats.start;\r\n  });\r\n\r\n  runner.on('pending', function(){\r\n    stats.pending++;\r\n  });\r\n}\r\n\r\n/**\r\n * Output common epilogue used by many of\r\n * the bundled reporters.\r\n *\r\n * @api public\r\n */\r\n\r\nBase.prototype.epilogue = function(){\r\n  var stats = this.stats\r\n    , fmt\r\n    , tests;\r\n\r\n  console.log();\r\n\r\n  function pluralize(n) {\r\n    return 1 == n ? 'test' : 'tests';\r\n  }\r\n\r\n  // failure\r\n  if (stats.failures) {\r\n    fmt = color('bright fail', '  ')\r\n      + color('fail', ' %d of %d %s failed')\r\n      + color('light', ':')\r\n\r\n    console.error(fmt,\r\n      stats.failures,\r\n      this.runner.total,\r\n      pluralize(this.runner.total));\r\n\r\n    Base.list(this.failures);\r\n    console.error();\r\n    return;\r\n  }\r\n\r\n  // pass\r\n  fmt = color('bright pass', '  ')\r\n    + color('green', ' %d %s complete')\r\n    + color('light', ' (%s)');\r\n\r\n  console.log(fmt,\r\n    stats.tests || 0,\r\n    pluralize(stats.tests),\r\n    ms(stats.duration));\r\n\r\n  // pending\r\n  if (stats.pending) {\r\n    fmt = color('pending', '  ')\r\n      + color('pending', ' %d %s pending');\r\n\r\n    console.log(fmt, stats.pending, pluralize(stats.pending));\r\n  }\r\n\r\n  console.log();\r\n};\r\n\r\n/**\r\n * Pad the given `str` to `len`.\r\n *\r\n * @param {String} str\r\n * @param {String} len\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction pad(str, len) {\r\n  str = String(str);\r\n  return Array(len - str.length + 1).join(' ') + str;\r\n}\r\n\r\n/**\r\n * Return a character diff for `err`.\r\n *\r\n * @param {Error} err\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction errorDiff(err, type) {\r\n  return diff['diff' + type](err.actual, err.expected).map(function(str){\r\n    str.value = str.value\r\n      .replace(/\\t/g, '<tab>')\r\n      .replace(/\\r/g, '<CR>')\r\n      .replace(/\\n/g, '<LF>\\n');\r\n    if (str.added) return colorLines('diff added', str.value);\r\n    if (str.removed) return colorLines('diff removed', str.value);\r\n    return str.value;\r\n  }).join('');\r\n}\r\n\r\n/**\r\n * Color lines for `str`, using the color `name`.\r\n *\r\n * @param {String} name\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction colorLines(name, str) {\r\n  return str.split('\\n').map(function(str){\r\n    return color(name, str);\r\n  }).join('\\n');\r\n}\r\n\r\n}); // module: reporters/base.js\r\n\r\nrequire.register(\"reporters/doc.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = Doc;\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Doc(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , indents = 2;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ');\r\n  }\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n    ++indents;\r\n    console.log('%s<section class=\"suite\">', indent());\r\n    ++indents;\r\n    console.log('%s<h1>%s</h1>', indent(), suite.title);\r\n    console.log('%s<dl>', indent());\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    console.log('%s</dl>', indent());\r\n    --indents;\r\n    console.log('%s</section>', indent());\r\n    --indents;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log('%s  <dt>%s</dt>', indent(), test.title);\r\n    var code = utils.escape(utils.clean(test.fn.toString()));\r\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\r\n  });\r\n}\r\n\r\n}); // module: reporters/doc.js\r\n\r\nrequire.register(\"reporters/dot.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = Dot;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Dot(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , c = ''\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    process.stdout.write('\\n  ');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    process.stdout.write(color('pending', c));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    if ('slow' == test.speed) {\r\n      process.stdout.write(color('bright yellow', c));\r\n    } else {\r\n      process.stdout.write(color(test.speed, c));\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    process.stdout.write(color('fail', c));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nDot.prototype = new Base;\r\nDot.prototype.constructor = Dot;\r\n\r\n}); // module: reporters/dot.js\r\n\r\nrequire.register(\"reporters/html-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar JSONCov = require('./json-cov')\r\n  , fs = require('browser/fs');\r\n\r\n/**\r\n * Expose `HTMLCov`.\r\n */\r\n\r\nexports = module.exports = HTMLCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTMLCov(runner) {\r\n  var jade = require('jade')\r\n    , file = __dirname + '/templates/coverage.jade'\r\n    , str = fs.readFileSync(file, 'utf8')\r\n    , fn = jade.compile(str, { filename: file })\r\n    , self = this;\r\n\r\n  JSONCov.call(this, runner, false);\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(fn({\r\n        cov: self.cov\r\n      , coverageClass: coverageClass\r\n    }));\r\n  });\r\n}\r\n\r\n/**\r\n * Return coverage class for `n`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction coverageClass(n) {\r\n  if (n >= 75) return 'high';\r\n  if (n >= 50) return 'medium';\r\n  if (n >= 25) return 'low';\r\n  return 'terrible';\r\n}\r\n}); // module: reporters/html-cov.js\r\n\r\nrequire.register(\"reporters/html.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , Progress = require('../browser/progress')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = HTML;\r\n\r\n/**\r\n * Stats template.\r\n */\r\n\r\nvar statsTemplate = '<ul id=\"stats\">'\r\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\r\n  + '<li class=\"passes\"><a href=\"#\">passes:</a> <em>0</em></li>'\r\n  + '<li class=\"failures\"><a href=\"#\">failures:</a> <em>0</em></li>'\r\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\r\n  + '</ul>';\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTML(runner, root) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , stat = fragment(statsTemplate)\r\n    , items = stat.getElementsByTagName('li')\r\n    , passes = items[1].getElementsByTagName('em')[0]\r\n    , passesLink = items[1].getElementsByTagName('a')[0]\r\n    , failures = items[2].getElementsByTagName('em')[0]\r\n    , failuresLink = items[2].getElementsByTagName('a')[0]\r\n    , duration = items[3].getElementsByTagName('em')[0]\r\n    , canvas = stat.getElementsByTagName('canvas')[0]\r\n    , report = fragment('<ul id=\"report\"></ul>')\r\n    , stack = [report]\r\n    , progress\r\n    , ctx\r\n\r\n  root = root || document.getElementById('mocha');\r\n\r\n  if (canvas.getContext) {\r\n    var ratio = window.devicePixelRatio || 1;\r\n    canvas.style.width = canvas.width;\r\n    canvas.style.height = canvas.height;\r\n    canvas.width *= ratio;\r\n    canvas.height *= ratio;\r\n    ctx = canvas.getContext('2d');\r\n    ctx.scale(ratio, ratio);\r\n    progress = new Progress;\r\n  }\r\n\r\n  if (!root) return error('#mocha div missing, add it to your document');\r\n\r\n  // pass toggle\r\n  on(passesLink, 'click', function () {\r\n    var className = /pass/.test(report.className) ? '' : ' pass';\r\n    report.className = report.className.replace(/fail|pass/g, '') + className;\r\n  });\r\n\r\n  // failure toggle\r\n  on(failuresLink, 'click', function () {\r\n    var className = /fail/.test(report.className) ? '' : ' fail';\r\n    report.className = report.className.replace(/fail|pass/g, '') + className;\r\n  });\r\n\r\n  root.appendChild(stat);\r\n  root.appendChild(report);\r\n\r\n  if (progress) progress.size(40);\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n\r\n    // suite\r\n    var url = '?grep=' + encodeURIComponent(suite.fullTitle());\r\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\r\n\r\n    // container\r\n    stack[0].appendChild(el);\r\n    stack.unshift(document.createElement('ul'));\r\n    el.appendChild(stack[0]);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    stack.shift();\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if ('hook' == test.type || err.uncaught) runner.emit('test end', test);\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    window.scrollTo(0, document.body.scrollHeight);\r\n\r\n    // TODO: add to stats\r\n    var percent = stats.tests / total * 100 | 0;\r\n    if (progress) progress.update(percent).draw(ctx);\r\n\r\n    // update stats\r\n    var ms = new Date - stats.start;\r\n    text(passes, stats.passes);\r\n    text(failures, stats.failures);\r\n    text(duration, (ms / 1000).toFixed(2));\r\n\r\n    // test\r\n    if ('passed' == test.state) {\r\n      var el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span></h2></li>', test.speed, test.title, test.duration);\r\n    } else if (test.pending) {\r\n      var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\r\n    } else {\r\n      var el = fragment('<li class=\"test fail\"><h2>%e</h2></li>', test.title);\r\n      var str = test.err.stack || test.err.toString();\r\n\r\n      // FF / Opera do not add the message\r\n      if (!~str.indexOf(test.err.message)) {\r\n        str = test.err.message + '\\n' + str;\r\n      }\r\n\r\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\r\n      // check for the result of the stringifying.\r\n      if ('[object Error]' == str) str = test.err.message;\r\n\r\n      // Safari doesn't give you a stack. Let's at least provide a source line.\r\n      if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {\r\n        str += \"\\n(\" + test.err.sourceURL + \":\" + test.err.line + \")\";\r\n      }\r\n\r\n      el.appendChild(fragment('<pre class=\"error\">%e</pre>', str));\r\n    }\r\n\r\n    // toggle code\r\n    // TODO: defer\r\n    if (!test.pending) {\r\n      var h2 = el.getElementsByTagName('h2')[0];\r\n\r\n      on(h2, 'click', function(){\r\n        pre.style.display = 'none' == pre.style.display\r\n          ? 'inline-block'\r\n          : 'none';\r\n      });\r\n\r\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\r\n      el.appendChild(pre);\r\n      pre.style.display = 'none';\r\n    }\r\n\r\n    stack[0].appendChild(el);\r\n  });\r\n}\r\n\r\n/**\r\n * Display error `msg`.\r\n */\r\n\r\nfunction error(msg) {\r\n  document.body.appendChild(fragment('<div id=\"error\">%s</div>', msg));\r\n}\r\n\r\n/**\r\n * Return a DOM fragment from `html`.\r\n */\r\n\r\nfunction fragment(html) {\r\n  var args = arguments\r\n    , div = document.createElement('div')\r\n    , i = 1;\r\n\r\n  div.innerHTML = html.replace(/%([se])/g, function(_, type){\r\n    switch (type) {\r\n      case 's': return String(args[i++]);\r\n      case 'e': return escape(args[i++]);\r\n    }\r\n  });\r\n\r\n  return div.firstChild;\r\n}\r\n\r\n/**\r\n * Set `el` text to `str`.\r\n */\r\n\r\nfunction text(el, str) {\r\n  if (el.textContent) {\r\n    el.textContent = str;\r\n  } else {\r\n    el.innerText = str;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen on `event` with callback `fn`.\r\n */\r\n\r\nfunction on(el, event, fn) {\r\n  if (el.addEventListener) {\r\n    el.addEventListener(event, fn, false);\r\n  } else {\r\n    el.attachEvent('on' + event, fn);\r\n  }\r\n}\r\n\r\n}); // module: reporters/html.js\r\n\r\nrequire.register(\"reporters/index.js\", function(module, exports, require){\r\n\r\nexports.Base = require('./base');\r\nexports.Dot = require('./dot');\r\nexports.Doc = require('./doc');\r\nexports.TAP = require('./tap');\r\nexports.JSON = require('./json');\r\nexports.HTML = require('./html');\r\nexports.List = require('./list');\r\nexports.Min = require('./min');\r\nexports.Spec = require('./spec');\r\nexports.Nyan = require('./nyan');\r\nexports.XUnit = require('./xunit');\r\nexports.Markdown = require('./markdown');\r\nexports.Progress = require('./progress');\r\nexports.Landing = require('./landing');\r\nexports.JSONCov = require('./json-cov');\r\nexports.HTMLCov = require('./html-cov');\r\nexports.JSONStream = require('./json-stream');\r\nexports.Teamcity = require('./teamcity');\r\n\r\n}); // module: reporters/index.js\r\n\r\nrequire.register(\"reporters/json-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `JSONCov`.\r\n */\r\n\r\nexports = module.exports = JSONCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Boolean} output\r\n * @api public\r\n */\r\n\r\nfunction JSONCov(runner, output) {\r\n  var self = this\r\n    , output = 1 == arguments.length ? true : output;\r\n\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var cov = global._$jscoverage || {};\r\n    var result = self.cov = map(cov);\r\n    result.stats = self.stats;\r\n    result.tests = tests.map(clean);\r\n    result.failures = failures.map(clean);\r\n    result.passes = passes.map(clean);\r\n    if (!output) return;\r\n    process.stdout.write(JSON.stringify(result, null, 2 ));\r\n  });\r\n}\r\n\r\n/**\r\n * Map jscoverage data to a JSON structure\r\n * suitable for reporting.\r\n *\r\n * @param {Object} cov\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction map(cov) {\r\n  var ret = {\r\n      instrumentation: 'node-jscoverage'\r\n    , sloc: 0\r\n    , hits: 0\r\n    , misses: 0\r\n    , coverage: 0\r\n    , files: []\r\n  };\r\n\r\n  for (var filename in cov) {\r\n    var data = coverage(filename, cov[filename]);\r\n    ret.files.push(data);\r\n    ret.hits += data.hits;\r\n    ret.misses += data.misses;\r\n    ret.sloc += data.sloc;\r\n  }\r\n\r\n  if (ret.sloc > 0) {\r\n    ret.coverage = (ret.hits / ret.sloc) * 100;\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Map jscoverage data for a single source file\r\n * to a JSON structure suitable for reporting.\r\n *\r\n * @param {String} filename name of the source file\r\n * @param {Object} data jscoverage coverage data\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction coverage(filename, data) {\r\n  var ret = {\r\n    filename: filename,\r\n    coverage: 0,\r\n    hits: 0,\r\n    misses: 0,\r\n    sloc: 0,\r\n    source: {}\r\n  };\r\n\r\n  data.source.forEach(function(line, num){\r\n    num++;\r\n\r\n    if (data[num] === 0) {\r\n      ret.misses++;\r\n      ret.sloc++;\r\n    } else if (data[num] !== undefined) {\r\n      ret.hits++;\r\n      ret.sloc++;\r\n    }\r\n\r\n    ret.source[num] = {\r\n        source: line\r\n      , coverage: data[num] === undefined\r\n        ? ''\r\n        : data[num]\r\n    };\r\n  });\r\n\r\n  ret.coverage = ret.hits / ret.sloc * 100;\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n\r\n}); // module: reporters/json-cov.js\r\n\r\nrequire.register(\"reporters/json-stream.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total;\r\n\r\n  runner.on('start', function(){\r\n    console.log(JSON.stringify(['start', { total: total }]));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log(JSON.stringify(['pass', clean(test)]));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    console.log(JSON.stringify(['fail', clean(test)]));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(JSON.stringify(['end', self.stats]));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json-stream.js\r\n\r\nrequire.register(\"reporters/json.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `JSON`.\r\n */\r\n\r\nexports = module.exports = JSONReporter;\r\n\r\n/**\r\n * Initialize a new `JSON` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction JSONReporter(runner) {\r\n  var self = this;\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var obj = {\r\n        stats: self.stats\r\n      , tests: tests.map(clean)\r\n      , failures: failures.map(clean)\r\n      , passes: passes.map(clean)\r\n    };\r\n\r\n    process.stdout.write(JSON.stringify(obj, null, 2));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json.js\r\n\r\nrequire.register(\"reporters/landing.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Landing`.\r\n */\r\n\r\nexports = module.exports = Landing;\r\n\r\n/**\r\n * Airplane color.\r\n */\r\n\r\nBase.colors.plane = 0;\r\n\r\n/**\r\n * Airplane crash color.\r\n */\r\n\r\nBase.colors['plane crash'] = 31;\r\n\r\n/**\r\n * Runway color.\r\n */\r\n\r\nBase.colors.runway = 90;\r\n\r\n/**\r\n * Initialize a new `Landing` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Landing(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , total = runner.total\r\n    , stream = process.stdout\r\n    , plane = color('plane', '')\r\n    , crashed = -1\r\n    , n = 0;\r\n\r\n  function runway() {\r\n    var buf = Array(width).join('-');\r\n    return '  ' + color('runway', buf);\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    stream.write('\\n  ');\r\n    cursor.hide();\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    // check if the plane crashed\r\n    var col = -1 == crashed\r\n      ? width * ++n / total | 0\r\n      : crashed;\r\n\r\n    // show the crash\r\n    if ('failed' == test.state) {\r\n      plane = color('plane crash', '');\r\n      crashed = col;\r\n    }\r\n\r\n    // render landing strip\r\n    stream.write('\\u001b[4F\\n\\n');\r\n    stream.write(runway());\r\n    stream.write('\\n  ');\r\n    stream.write(color('runway', Array(col).join('')));\r\n    stream.write(plane)\r\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\r\n    stream.write(runway());\r\n    stream.write('\\u001b[0m');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nLanding.prototype = new Base;\r\nLanding.prototype.constructor = Landing;\r\n\r\n}); // module: reporters/landing.js\r\n\r\nrequire.register(\"reporters/list.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = color('checkmark', '  -')\r\n      + color('pending', ' %s');\r\n    console.log(fmt, test.fullTitle());\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var fmt = color('checkmark', '  ')\r\n      + color('pass', ' %s: ')\r\n      + color(test.speed, '%dms');\r\n    cursor.CR();\r\n    console.log(fmt, test.fullTitle(), test.duration);\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nList.prototype = new Base;\r\nList.prototype.constructor = List;\r\n\r\n\r\n}); // module: reporters/list.js\r\n\r\nrequire.register(\"reporters/markdown.js\", function(module, exports, require){\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Markdown`.\r\n */\r\n\r\nexports = module.exports = Markdown;\r\n\r\n/**\r\n * Initialize a new `Markdown` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Markdown(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , level = 0\r\n    , buf = '';\r\n\r\n  function title(str) {\r\n    return Array(level).join('#') + ' ' + str;\r\n  }\r\n\r\n  function indent() {\r\n    return Array(level).join('  ');\r\n  }\r\n\r\n  function mapTOC(suite, obj) {\r\n    var ret = obj;\r\n    obj = obj[suite.title] = obj[suite.title] || { suite: suite };\r\n    suite.suites.forEach(function(suite){\r\n      mapTOC(suite, obj);\r\n    });\r\n    return ret;\r\n  }\r\n\r\n  function stringifyTOC(obj, level) {\r\n    ++level;\r\n    var buf = '';\r\n    var link;\r\n    for (var key in obj) {\r\n      if ('suite' == key) continue;\r\n      if (key) link = ' - [' + key + '](#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\r\n      if (key) buf += Array(level).join('  ') + link;\r\n      buf += stringifyTOC(obj[key], level);\r\n    }\r\n    --level;\r\n    return buf;\r\n  }\r\n\r\n  function generateTOC(suite) {\r\n    var obj = mapTOC(suite, {});\r\n    return stringifyTOC(obj, 0);\r\n  }\r\n\r\n  generateTOC(runner.suite);\r\n\r\n  runner.on('suite', function(suite){\r\n    ++level;\r\n    var slug = utils.slug(suite.fullTitle());\r\n    buf += '<a name=\"' + slug + '\" />' + '\\n';\r\n    buf += title(suite.title) + '\\n';\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --level;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var code = utils.clean(test.fn.toString());\r\n    buf += test.title + '.\\n';\r\n    buf += '\\n```js\\n';\r\n    buf += code + '\\n';\r\n    buf += '```\\n\\n';\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write('# TOC\\n');\r\n    process.stdout.write(generateTOC(runner.suite));\r\n    process.stdout.write(buf);\r\n  });\r\n}\r\n}); // module: reporters/markdown.js\r\n\r\nrequire.register(\"reporters/min.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Min`.\r\n */\r\n\r\nexports = module.exports = Min;\r\n\r\n/**\r\n * Initialize a new `Min` minimal test reporter (best used with --watch).\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Min(runner) {\r\n  Base.call(this, runner);\r\n  \r\n  runner.on('start', function(){\r\n    // clear screen\r\n    process.stdout.write('\\u001b[2J');\r\n    // set cursor position\r\n    process.stdout.write('\\u001b[1;3H');\r\n  });\r\n\r\n  runner.on('end', this.epilogue.bind(this));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nMin.prototype = new Base;\r\nMin.prototype.constructor = Min;\r\n\r\n}); // module: reporters/min.js\r\n\r\nrequire.register(\"reporters/nyan.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = NyanCat;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction NyanCat(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , rainbowColors = this.rainbowColors = self.generateColors()\r\n    , colorIndex = this.colorIndex = 0\r\n    , numerOfLines = this.numberOfLines = 4\r\n    , trajectories = this.trajectories = [[], [], [], []]\r\n    , nyanCatWidth = this.nyanCatWidth = 11\r\n    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)\r\n    , scoreboardWidth = this.scoreboardWidth = 5\r\n    , tick = this.tick = 0\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    Base.cursor.hide();\r\n    self.draw('start');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    self.draw('pending');\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    self.draw('pass');\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    self.draw('fail');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    Base.cursor.show();\r\n    for (var i = 0; i < self.numberOfLines; i++) write('\\n');\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Draw the nyan cat with runner `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.draw = function(status){\r\n  this.appendRainbow();\r\n  this.drawScoreboard();\r\n  this.drawRainbow();\r\n  this.drawNyanCat(status);\r\n  this.tick = !this.tick;\r\n};\r\n\r\n/**\r\n * Draw the \"scoreboard\" showing the number\r\n * of passes, failures and pending tests.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawScoreboard = function(){\r\n  var stats = this.stats;\r\n  var colors = Base.colors;\r\n\r\n  function draw(color, n) {\r\n    write(' ');\r\n    write('\\u001b[' + color + 'm' + n + '\\u001b[0m');\r\n    write('\\n');\r\n  }\r\n\r\n  draw(colors.green, stats.passes);\r\n  draw(colors.fail, stats.failures);\r\n  draw(colors.pending, stats.pending);\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Append the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.appendRainbow = function(){\r\n  var segment = this.tick ? '_' : '-';\r\n  var rainbowified = this.rainbowify(segment);\r\n\r\n  for (var index = 0; index < this.numberOfLines; index++) {\r\n    var trajectory = this.trajectories[index];\r\n    if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();\r\n    trajectory.push(rainbowified);\r\n  }\r\n};\r\n\r\n/**\r\n * Draw the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawRainbow = function(){\r\n  var self = this;\r\n\r\n  this.trajectories.forEach(function(line, index) {\r\n    write('\\u001b[' + self.scoreboardWidth + 'C');\r\n    write(line.join(''));\r\n    write('\\n');\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Draw the nyan cat with `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawNyanCat = function(status) {\r\n  var self = this;\r\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\r\n\r\n  [0, 1, 2, 3].forEach(function(index) {\r\n    write('\\u001b[' + startWidth + 'C');\r\n\r\n    switch (index) {\r\n      case 0:\r\n        write('_,------,');\r\n        write('\\n');\r\n        break;\r\n      case 1:\r\n        var padding = self.tick ? '  ' : '   ';\r\n        write('_|' + padding + '/\\\\_/\\\\ ');\r\n        write('\\n');\r\n        break;\r\n      case 2:\r\n        var padding = self.tick ? '_' : '__';\r\n        var tail = self.tick ? '~' : '^';\r\n        var face;\r\n        switch (status) {\r\n          case 'pass':\r\n            face = '( ^ .^)';\r\n            break;\r\n          case 'fail':\r\n            face = '( o .o)';\r\n            break;\r\n          default:\r\n            face = '( - .-)';\r\n        }\r\n        write(tail + '|' + padding + face + ' ');\r\n        write('\\n');\r\n        break;\r\n      case 3:\r\n        var padding = self.tick ? ' ' : '  ';\r\n        write(padding + '\"\"  \"\" ');\r\n        write('\\n');\r\n        break;\r\n    }\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Move cursor up `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorUp = function(n) {\r\n  write('\\u001b[' + n + 'A');\r\n};\r\n\r\n/**\r\n * Move cursor down `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorDown = function(n) {\r\n  write('\\u001b[' + n + 'B');\r\n};\r\n\r\n/**\r\n * Generate rainbow colors.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.generateColors = function(){\r\n  var colors = [];\r\n\r\n  for (var i = 0; i < (6 * 7); i++) {\r\n    var pi3 = Math.floor(Math.PI / 3);\r\n    var n = (i * (1.0 / 6));\r\n    var r = Math.floor(3 * Math.sin(n) + 3);\r\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\r\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\r\n    colors.push(36 * r + 6 * g + b + 16);\r\n  }\r\n\r\n  return colors;\r\n};\r\n\r\n/**\r\n * Apply rainbow to the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.rainbowify = function(str){\r\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\r\n  this.colorIndex += 1;\r\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Stdout helper.\r\n */\r\n\r\nfunction write(string) {\r\n  process.stdout.write(string);\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nNyanCat.prototype = new Base;\r\nNyanCat.prototype.constructor = NyanCat;\r\n\r\n\r\n}); // module: reporters/nyan.js\r\n\r\nrequire.register(\"reporters/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nexports = module.exports = Progress;\r\n\r\n/**\r\n * General progress bar color.\r\n */\r\n\r\nBase.colors.progress = 90;\r\n\r\n/**\r\n * Initialize a new `Progress` bar test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Progress(runner, options) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , options = options || {}\r\n    , stats = this.stats\r\n    , width = Base.window.width * .50 | 0\r\n    , total = runner.total\r\n    , complete = 0\r\n    , max = Math.max;\r\n\r\n  // default chars\r\n  options.open = options.open || '[';\r\n  options.complete = options.complete || '';\r\n  options.incomplete = options.incomplete || '';\r\n  options.close = options.close || ']';\r\n  options.verbose = false;\r\n\r\n  // tests started\r\n  runner.on('start', function(){\r\n    console.log();\r\n    cursor.hide();\r\n  });\r\n\r\n  // tests complete\r\n  runner.on('test end', function(){\r\n    complete++;\r\n    var incomplete = total - complete\r\n      , percent = complete / total\r\n      , n = width * percent | 0\r\n      , i = width - n;\r\n\r\n    cursor.CR();\r\n    process.stdout.write('\\u001b[J');\r\n    process.stdout.write(color('progress', '  ' + options.open));\r\n    process.stdout.write(Array(n).join(options.complete));\r\n    process.stdout.write(Array(i).join(options.incomplete));\r\n    process.stdout.write(color('progress', options.close));\r\n    if (options.verbose) {\r\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\r\n    }\r\n  });\r\n\r\n  // tests are complete, output some stats\r\n  // and the failures if any\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nProgress.prototype = new Base;\r\nProgress.prototype.constructor = Progress;\r\n\r\n\r\n}); // module: reporters/progress.js\r\n\r\nrequire.register(\"reporters/spec.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Spec`.\r\n */\r\n\r\nexports = module.exports = Spec;\r\n\r\n/**\r\n * Initialize a new `Spec` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Spec(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , indents = 0\r\n    , n = 0;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ')\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    ++indents;\r\n    console.log(color('suite', '%s%s'), indent(), suite.title);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --indents;\r\n    if (1 == indents) console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(indent() + color('pass', '   ' + test.title + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = indent() + color('pending', '  - %s');\r\n    console.log(fmt, test.title);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if ('fast' == test.speed) {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ')\r\n        + color('pass', ' %s ');\r\n      cursor.CR();\r\n      console.log(fmt, test.title);\r\n    } else {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ')\r\n        + color('pass', ' %s ')\r\n        + color(test.speed, '(%dms)');\r\n      cursor.CR();\r\n      console.log(fmt, test.title, test.duration);\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nSpec.prototype = new Base;\r\nSpec.prototype.constructor = Spec;\r\n\r\n\r\n}); // module: reporters/spec.js\r\n\r\nrequire.register(\"reporters/tap.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `TAP`.\r\n */\r\n\r\nexports = module.exports = TAP;\r\n\r\n/**\r\n * Initialize a new `TAP` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction TAP(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 1;\r\n\r\n  runner.on('start', function(){\r\n    var total = runner.grepTotal(runner.suite);\r\n    console.log('%d..%d', 1, total);\r\n  });\r\n\r\n  runner.on('test end', function(){\r\n    ++n;\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    console.log('ok %d %s # SKIP -', n, title(test));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log('ok %d %s', n, title(test));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    console.log('not ok %d %s', n, title(test));\r\n    console.log(err.stack.replace(/^/gm, '  '));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a TAP-safe title of `test`\r\n *\r\n * @param {Object} test\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction title(test) {\r\n  return test.fullTitle().replace(/#/g, '');\r\n}\r\n\r\n}); // module: reporters/tap.js\r\n\r\nrequire.register(\"reporters/teamcity.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Teamcity`.\r\n */\r\n\r\nexports = module.exports = Teamcity;\r\n\r\n/**\r\n * Initialize a new `Teamcity` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Teamcity(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats;\r\n\r\n  runner.on('start', function() {\r\n    console.log(\"##teamcity[testSuiteStarted name='mocha.suite']\");\r\n  });\r\n\r\n  runner.on('test', function(test) {\r\n    console.log(\"##teamcity[testStarted name='\" + escape(test.fullTitle()) + \"']\");\r\n  });\r\n\r\n  runner.on('fail', function(test, err) {\r\n    console.log(\"##teamcity[testFailed name='\" + escape(test.fullTitle()) + \"' message='\" + escape(err.message) + \"']\");\r\n  });\r\n\r\n  runner.on('pending', function(test) {\r\n    console.log(\"##teamcity[testIgnored name='\" + escape(test.fullTitle()) + \"' message='pending']\");\r\n  });\r\n\r\n  runner.on('test end', function(test) {\r\n    console.log(\"##teamcity[testFinished name='\" + escape(test.fullTitle()) + \"' duration='\" + test.duration + \"']\");\r\n  });\r\n\r\n  runner.on('end', function() {\r\n    console.log(\"##teamcity[testSuiteFinished name='mocha.suite' duration='\" + stats.duration + \"']\");\r\n  });\r\n}\r\n\r\n/**\r\n * Escape the given `str`.\r\n */\r\n\r\nfunction escape(str) {\r\n  return str\r\n    .replace(/\\|/g, \"||\")\r\n    .replace(/\\n/g, \"|n\")\r\n    .replace(/\\r/g, \"|r\")\r\n    .replace(/\\[/g, \"|[\")\r\n    .replace(/\\]/g, \"|]\")\r\n    .replace(/\\u0085/g, \"|x\")\r\n    .replace(/\\u2028/g, \"|l\")\r\n    .replace(/\\u2029/g, \"|p\")\r\n    .replace(/'/g, \"|'\");\r\n}\r\n\r\n}); // module: reporters/teamcity.js\r\n\r\nrequire.register(\"reporters/xunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `XUnit`.\r\n */\r\n\r\nexports = module.exports = XUnit;\r\n\r\n/**\r\n * Initialize a new `XUnit` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction XUnit(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats\r\n    , tests = []\r\n    , self = this;\r\n\r\n  runner.on('pass', function(test){\r\n    tests.push(test);\r\n  });\r\n  \r\n  runner.on('fail', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log(tag('testsuite', {\r\n        name: 'Mocha Tests'\r\n      , tests: stats.tests\r\n      , failures: stats.failures\r\n      , errors: stats.failures\r\n      , skip: stats.tests - stats.failures - stats.passes\r\n      , timestamp: (new Date).toUTCString()\r\n      , time: stats.duration / 1000\r\n    }, false));\r\n\r\n    tests.forEach(test);\r\n    console.log('</testsuite>');    \r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nXUnit.prototype = new Base;\r\nXUnit.prototype.constructor = XUnit;\r\n\r\n\r\n/**\r\n * Output tag for the given `test.`\r\n */\r\n\r\nfunction test(test) {\r\n  var attrs = {\r\n      classname: test.parent.fullTitle()\r\n    , name: test.title\r\n    , time: test.duration / 1000\r\n  };\r\n\r\n  if ('failed' == test.state) {\r\n    var err = test.err;\r\n    attrs.message = escape(err.message);\r\n    console.log(tag('testcase', attrs, false, tag('failure', attrs, false, cdata(err.stack))));\r\n  } else if (test.pending) {\r\n    console.log(tag('testcase', attrs, false, tag('skipped', {}, true)));\r\n  } else {\r\n    console.log(tag('testcase', attrs, true) );\r\n  }\r\n}\r\n\r\n/**\r\n * HTML tag helper.\r\n */\r\n\r\nfunction tag(name, attrs, close, content) {\r\n  var end = close ? '/>' : '>'\r\n    , pairs = []\r\n    , tag;\r\n\r\n  for (var key in attrs) {\r\n    pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\r\n  }\r\n\r\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\r\n  if (content) tag += content + '</' + name + end;\r\n  return tag;\r\n}\r\n\r\n/**\r\n * Return cdata escaped CDATA `str`.\r\n */\r\n\r\nfunction cdata(str) {\r\n  return '<![CDATA[' + escape(str) + ']]>';\r\n}\r\n\r\n}); // module: reporters/xunit.js\r\n\r\nrequire.register(\"runnable.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runnable');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `Runnable`.\r\n */\r\n\r\nmodule.exports = Runnable;\r\n\r\n/**\r\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Runnable(title, fn) {\r\n  this.title = title;\r\n  this.fn = fn;\r\n  this.async = fn && fn.length;\r\n  this.sync = ! this.async;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this.timedOut = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nRunnable.prototype = new EventEmitter;\r\nRunnable.prototype.constructor = Runnable;\r\n\r\n\r\n/**\r\n * Set & get timeout `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  debug('timeout %d', ms);\r\n  this._timeout = ms;\r\n  if (this.timer) this.resetTimeout();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set & get slow `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  debug('timeout %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nRunnable.prototype.fullTitle = function(){\r\n  return this.parent.fullTitle() + ' ' + this.title;\r\n};\r\n\r\n/**\r\n * Clear the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.clearTimeout = function(){\r\n  clearTimeout(this.timer);\r\n};\r\n\r\n/**\r\n * Inspect the runnable void of private properties.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_' == key[0]) return;\r\n    if ('parent' == key) return '#<Suite>';\r\n    if ('ctx' == key) return '#<Context>';\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n/**\r\n * Reset the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.resetTimeout = function(){\r\n  var self = this\r\n    , ms = this.timeout();\r\n\r\n  this.clearTimeout();\r\n  if (ms) {\r\n    this.timer = setTimeout(function(){\r\n      self.callback(new Error('timeout of ' + ms + 'ms exceeded'));\r\n      self.timedOut = true;\r\n    }, ms);\r\n  }\r\n};\r\n\r\n/**\r\n * Run the test and invoke `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.run = function(fn){\r\n  var self = this\r\n    , ms = this.timeout()\r\n    , start = new Date\r\n    , ctx = this.ctx\r\n    , finished\r\n    , emitted;\r\n\r\n  if (ctx) ctx.runnable(this);\r\n\r\n  // timeout\r\n  if (this.async) {\r\n    if (ms) {\r\n      this.timer = setTimeout(function(){\r\n        done(new Error('timeout of ' + ms + 'ms exceeded'));\r\n        self.timedOut = true;\r\n      }, ms);\r\n    }\r\n  }\r\n\r\n  // called multiple times\r\n  function multiple(err) {\r\n    if (emitted) return;\r\n    emitted = true;\r\n    self.emit('error', err || new Error('done() called multiple times'));\r\n  }\r\n\r\n  // finished\r\n  function done(err) {\r\n    if (self.timedOut) return;\r\n    if (finished) return multiple(err);\r\n    self.clearTimeout();\r\n    self.duration = new Date - start;\r\n    finished = true;\r\n    fn(err);\r\n  }\r\n\r\n  // for .resetTimeout()\r\n  this.callback = done;\r\n\r\n  // async\r\n  if (this.async) {\r\n    try {\r\n      this.fn.call(ctx, function(err){\r\n        if (err instanceof Error) return done(err);\r\n        if (null != err) return done(new Error('done() invoked with non-Error: ' + err));\r\n        done();\r\n      });\r\n    } catch (err) {\r\n      done(err);\r\n    }\r\n    return;\r\n  }\r\n  \r\n  // sync\r\n  try {\r\n    if (!this.pending) this.fn.call(ctx);\r\n    this.duration = new Date - start;\r\n    fn();\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n}); // module: runnable.js\r\n\r\nrequire.register(\"runner.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runner')\r\n  , Test = require('./test')\r\n  , utils = require('./utils')\r\n  , filter = utils.filter\r\n  , keys = utils.keys\r\n  , noop = function(){};\r\n\r\n/**\r\n * Expose `Runner`.\r\n */\r\n\r\nmodule.exports = Runner;\r\n\r\n/**\r\n * Initialize a `Runner` for the given `suite`.\r\n *\r\n * Events:\r\n *\r\n *   - `start`  execution started\r\n *   - `end`  execution complete\r\n *   - `suite`  (suite) test suite execution started\r\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\r\n *   - `test`  (test) test execution started\r\n *   - `test end`  (test) test completed\r\n *   - `hook`  (hook) hook execution started\r\n *   - `hook end`  (hook) hook complete\r\n *   - `pass`  (test) test passed\r\n *   - `fail`  (test, err) test failed\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Runner(suite) {\r\n  var self = this;\r\n  this._globals = [];\r\n  this.suite = suite;\r\n  this.total = suite.total();\r\n  this.failures = 0;\r\n  this.on('test end', function(test){ self.checkGlobals(test); });\r\n  this.on('hook end', function(hook){ self.checkGlobals(hook); });\r\n  this.grep(/.*/);\r\n  this.globals(utils.keys(global).concat(['errno']));\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nRunner.prototype = new EventEmitter;\r\nRunner.prototype.constructor = Runner;\r\n\r\n\r\n/**\r\n * Run tests with full titles matching `re`. Updates runner.total\r\n * with number of tests matched.\r\n *\r\n * @param {RegExp} re\r\n * @param {Boolean} invert\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grep = function(re, invert){\r\n  debug('grep %s', re);\r\n  this._grep = re;\r\n  this._invert = invert;\r\n  this.total = this.grepTotal(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the number of tests matching the grep search for the\r\n * given suite.\r\n *\r\n * @param {Suite} suite\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grepTotal = function(suite) {\r\n  var self = this;\r\n  var total = 0;\r\n\r\n  suite.eachTest(function(test){\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (match) total++;\r\n  });\r\n\r\n  return total;\r\n};\r\n\r\n/**\r\n * Allow the given `arr` of globals.\r\n *\r\n * @param {Array} arr\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.globals = function(arr){\r\n  if (0 == arguments.length) return this._globals;\r\n  debug('globals %j', arr);\r\n  utils.forEach(arr, function(arr){\r\n    this._globals.push(arr);\r\n  }, this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Check for global variable leaks.\r\n *\r\n * @api private\r\n */\r\n\r\nRunner.prototype.checkGlobals = function(test){\r\n  if (this.ignoreLeaks) return;\r\n  var leaks = filterLeaks(this._globals);\r\n\r\n  this._globals = this._globals.concat(leaks);\r\n\r\n  if (leaks.length > 1) {\r\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\r\n  } else if (leaks.length) {\r\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\r\n  }\r\n};\r\n\r\n/**\r\n * Fail the given `test`.\r\n *\r\n * @param {Test} test\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.fail = function(test, err){\r\n  ++this.failures;\r\n  test.state = 'failed';\r\n  if ('string' == typeof err) {\r\n    err = new Error('the string \"' + err + '\" was thrown, throw an Error :)');\r\n  }\r\n  this.emit('fail', test, err);\r\n};\r\n\r\n/**\r\n * Fail the given `hook` with `err`.\r\n *\r\n * Hook failures (currently) hard-end due\r\n * to that fact that a failing hook will\r\n * surely cause subsequent tests to fail,\r\n * causing jumbled reporting.\r\n *\r\n * @param {Hook} hook\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.failHook = function(hook, err){\r\n  this.fail(hook, err);\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run hook `name` callbacks and then invoke `fn()`.\r\n *\r\n * @param {String} name\r\n * @param {Function} function\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hook = function(name, fn){\r\n  var suite = this.suite\r\n    , hooks = suite['_' + name]\r\n    , self = this\r\n    , timer;\r\n\r\n  function next(i) {\r\n    var hook = hooks[i];\r\n    if (!hook) return fn();\r\n    self.currentRunnable = hook;\r\n\r\n    self.emit('hook', hook);\r\n\r\n    hook.on('error', function(err){\r\n      self.failHook(hook, err);\r\n    });\r\n\r\n    hook.run(function(err){\r\n      hook.removeAllListeners('error');\r\n      var testError = hook.error();\r\n      if (testError) self.fail(self.test, testError);\r\n      if (err) return self.failHook(hook, err);\r\n      self.emit('hook end', hook);\r\n      next(++i);\r\n    });\r\n  }\r\n\r\n  process.nextTick(function(){\r\n    next(0);\r\n  });\r\n};\r\n\r\n/**\r\n * Run hook `name` for the given array of `suites`\r\n * in order, and callback `fn(err)`.\r\n *\r\n * @param {String} name\r\n * @param {Array} suites\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hooks = function(name, suites, fn){\r\n  var self = this\r\n    , orig = this.suite;\r\n\r\n  function next(suite) {\r\n    self.suite = suite;\r\n\r\n    if (!suite) {\r\n      self.suite = orig;\r\n      return fn();\r\n    }\r\n\r\n    self.hook(name, function(err){\r\n      if (err) {\r\n        self.suite = orig;\r\n        return fn(err);\r\n      }\r\n\r\n      next(suites.pop());\r\n    });\r\n  }\r\n\r\n  next(suites.pop());\r\n};\r\n\r\n/**\r\n * Run hooks from the top level down.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookUp = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents()).reverse();\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Run hooks from the bottom up.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookDown = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents());\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Return an array of parent Suites from\r\n * closest to furthest.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nRunner.prototype.parents = function(){\r\n  var suite = this.suite\r\n    , suites = [];\r\n  while (suite = suite.parent) suites.push(suite);\r\n  return suites;\r\n};\r\n\r\n/**\r\n * Run the current test and callback `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTest = function(fn){\r\n  var test = this.test\r\n    , self = this;\r\n\r\n  try {\r\n    test.on('error', function(err){\r\n      self.fail(test, err);\r\n    });\r\n    test.run(fn);\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n/**\r\n * Run tests in the given `suite` and invoke\r\n * the callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTests = function(suite, fn){\r\n  var self = this\r\n    , tests = suite.tests\r\n    , test;\r\n\r\n  function next(err) {\r\n    // if we bail after first err\r\n    if (self.failures && suite._bail) return fn();\r\n\r\n    // next test\r\n    test = tests.shift();\r\n\r\n    // all done\r\n    if (!test) return fn();\r\n\r\n    // grep\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (!match) return next();\r\n\r\n    // pending\r\n    if (test.pending) {\r\n      self.emit('pending', test);\r\n      self.emit('test end', test);\r\n      return next();\r\n    }\r\n\r\n    // execute test and hook(s)\r\n    self.emit('test', self.test = test);\r\n    self.hookDown('beforeEach', function(){\r\n      self.currentRunnable = self.test;\r\n      self.runTest(function(err){\r\n        test = self.test;\r\n\r\n        if (err) {\r\n          self.fail(test, err);\r\n          self.emit('test end', test);\r\n          return self.hookUp('afterEach', next);\r\n        }\r\n\r\n        test.state = 'passed';\r\n        self.emit('pass', test);\r\n        self.emit('test end', test);\r\n        self.hookUp('afterEach', next);\r\n      });\r\n    });\r\n  }\r\n\r\n  this.next = next;\r\n  next();\r\n};\r\n\r\n/**\r\n * Run the given `suite` and invoke the\r\n * callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runSuite = function(suite, fn){\r\n  var total = this.grepTotal(suite)\r\n    , self = this\r\n    , i = 0;\r\n\r\n  debug('run suite %s', suite.fullTitle());\r\n\r\n  if (!total) return fn();\r\n\r\n  this.emit('suite', this.suite = suite);\r\n\r\n  function next() {\r\n    var curr = suite.suites[i++];\r\n    if (!curr) return done();\r\n    self.runSuite(curr, next);\r\n  }\r\n\r\n  function done() {\r\n    self.suite = suite;\r\n    self.hook('afterAll', function(){\r\n      self.emit('suite end', suite);\r\n      fn();\r\n    });\r\n  }\r\n\r\n  this.hook('beforeAll', function(){\r\n    self.runTests(suite, next);\r\n  });\r\n};\r\n\r\n/**\r\n * Handle uncaught exceptions.\r\n *\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.uncaught = function(err){\r\n  debug('uncaught exception %s', err.message);\r\n  var runnable = this.currentRunnable;\r\n  if (!runnable || 'failed' == runnable.state) return;\r\n  runnable.clearTimeout();\r\n  err.uncaught = true;\r\n  this.fail(runnable, err);\r\n\r\n  // recover from test\r\n  if ('test' == runnable.type) {\r\n    this.emit('test end', runnable);\r\n    this.hookUp('afterEach', this.next);\r\n    return;\r\n  }\r\n\r\n  // bail on hooks\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run the root suite and invoke `fn(failures)`\r\n * on completion.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.run = function(fn){\r\n  var self = this\r\n    , fn = fn || function(){};\r\n\r\n  debug('start');\r\n\r\n  // uncaught callback\r\n  function uncaught(err) {\r\n    self.uncaught(err);\r\n  }\r\n\r\n  // callback\r\n  this.on('end', function(){\r\n    debug('end');\r\n    process.removeListener('uncaughtException', uncaught);\r\n    fn(self.failures);\r\n  });\r\n\r\n  // run suites\r\n  this.emit('start');\r\n  this.runSuite(this.suite, function(){\r\n    debug('finished running');\r\n    self.emit('end');\r\n  });\r\n\r\n  // uncaught exception\r\n  process.on('uncaughtException', uncaught);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Filter leaks with the given globals flagged as `ok`.\r\n *\r\n * @param {Array} ok\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nfunction filterLeaks(ok) {\r\n  return filter(keys(global), function(key){\r\n    var matched = filter(ok, function(ok){\r\n      if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);\r\n      return key == ok;\r\n    });\r\n    return matched.length == 0 && (!global.navigator || 'onerror' !== key);\r\n  });\r\n}\r\n\r\n}); // module: runner.js\r\n\r\nrequire.register(\"suite.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:suite')\r\n  , milliseconds = require('./ms')\r\n  , utils = require('./utils')\r\n  , Hook = require('./hook');\r\n\r\n/**\r\n * Expose `Suite`.\r\n */\r\n\r\nexports = module.exports = Suite;\r\n\r\n/**\r\n * Create a new `Suite` with the given `title`\r\n * and parent `Suite`. When a suite with the\r\n * same title is already present, that suite\r\n * is returned to provide nicer reporter\r\n * and more flexible meta-testing.\r\n *\r\n * @param {Suite} parent\r\n * @param {String} title\r\n * @return {Suite}\r\n * @api public\r\n */\r\n\r\nexports.create = function(parent, title){\r\n  var suite = new Suite(title, parent.ctx);\r\n  suite.parent = parent;\r\n  if (parent.pending) suite.pending = true;\r\n  title = suite.fullTitle();\r\n  parent.addSuite(suite);\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Initialize a new `Suite` with the given\r\n * `title` and `ctx`.\r\n *\r\n * @param {String} title\r\n * @param {Context} ctx\r\n * @api private\r\n */\r\n\r\nfunction Suite(title, ctx) {\r\n  this.title = title;\r\n  this.ctx = ctx;\r\n  this.suites = [];\r\n  this.tests = [];\r\n  this.pending = false;\r\n  this._beforeEach = [];\r\n  this._beforeAll = [];\r\n  this._afterEach = [];\r\n  this._afterAll = [];\r\n  this.root = !title;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this._bail = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nSuite.prototype = new EventEmitter;\r\nSuite.prototype.constructor = Suite;\r\n\r\n\r\n/**\r\n * Return a clone of this `Suite`.\r\n *\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.clone = function(){\r\n  var suite = new Suite(this.title);\r\n  debug('clone');\r\n  suite.ctx = this.ctx;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Set timeout `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._timeout = parseInt(ms, 10);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slow `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('slow %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets whether to bail after first error.\r\n *\r\n * @parma {Boolean} bail\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.bail = function(bail){\r\n  if (0 == arguments.length) return this._bail;\r\n  debug('bail %s', bail);\r\n  this._bail = bail;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeAll.push(hook);\r\n  this.emit('beforeAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterAll.push(hook);\r\n  this.emit('afterAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeEach.push(hook);\r\n  this.emit('beforeEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterEach.push(hook);\r\n  this.emit('afterEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a test `suite`.\r\n *\r\n * @param {Suite} suite\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addSuite = function(suite){\r\n  suite.parent = this;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  this.suites.push(suite);\r\n  this.emit('suite', suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a `test` to this suite.\r\n *\r\n * @param {Test} test\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addTest = function(test){\r\n  test.parent = this;\r\n  test.timeout(this.timeout());\r\n  test.slow(this.slow());\r\n  test.ctx = this.ctx;\r\n  this.tests.push(test);\r\n  this.emit('test', test);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.fullTitle = function(){\r\n  if (this.parent) {\r\n    var full = this.parent.fullTitle();\r\n    if (full) return full + ' ' + this.title;\r\n  }\r\n  return this.title;\r\n};\r\n\r\n/**\r\n * Return the total number of tests.\r\n *\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.total = function(){\r\n  return utils.reduce(this.suites, function(sum, suite){\r\n    return sum + suite.total();\r\n  }, 0) + this.tests.length;\r\n};\r\n\r\n/**\r\n * Iterates through each suite recursively to find\r\n * all tests. Applies a function in the format\r\n * `fn(test)`.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.eachTest = function(fn){\r\n  utils.forEach(this.tests, fn);\r\n  utils.forEach(this.suites, function(suite){\r\n    suite.eachTest(fn);\r\n  });\r\n  return this;\r\n};\r\n\r\n}); // module: suite.js\r\n\r\nrequire.register(\"test.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Test`.\r\n */\r\n\r\nmodule.exports = Test;\r\n\r\n/**\r\n * Initialize a new `Test` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Test(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.pending = !fn;\r\n  this.type = 'test';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nTest.prototype = new Runnable;\r\nTest.prototype.constructor = Test;\r\n\r\n\r\n}); // module: test.js\r\n\r\nrequire.register(\"utils.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar fs = require('browser/fs')\r\n  , path = require('browser/path')\r\n  , join = path.join\r\n  , debug = require('browser/debug')('mocha:watch');\r\n\r\n/**\r\n * Ignored directories.\r\n */\r\n\r\nvar ignore = ['node_modules', '.git'];\r\n\r\n/**\r\n * Escape special characters in the given string of html.\r\n *\r\n * @param  {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function(html){\r\n  return String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n};\r\n\r\n/**\r\n * Array#forEach (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} scope\r\n * @api private\r\n */\r\n\r\nexports.forEach = function(arr, fn, scope){\r\n  for (var i = 0, l = arr.length; i < l; i++)\r\n    fn.call(scope, arr[i], i);\r\n};\r\n\r\n/**\r\n * Array#indexOf (<=IE8)\r\n *\r\n * @parma {Array} arr\r\n * @param {Object} obj to find index of\r\n * @param {Number} start\r\n * @api private\r\n */\r\n\r\nexports.indexOf = function(arr, obj, start){\r\n  for (var i = start || 0, l = arr.length; i < l; i++) {\r\n    if (arr[i] === obj)\r\n      return i;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Array#reduce (<=IE8)\r\n * \r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} initial value\r\n * @api private\r\n */\r\n\r\nexports.reduce = function(arr, fn, val){\r\n  var rval = val;\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    rval = fn(rval, arr[i], i, arr);\r\n  }\r\n\r\n  return rval;\r\n};\r\n\r\n/**\r\n * Array#filter (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.filter = function(arr, fn){\r\n  var ret = [];\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    var val = arr[i];\r\n    if (fn(val, i, arr)) ret.push(val);\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Object.keys (<=IE8)\r\n *\r\n * @param {Object} obj\r\n * @return {Array} keys\r\n * @api private\r\n */\r\n\r\nexports.keys = Object.keys || function(obj) {\r\n  var keys = []\r\n    , has = Object.prototype.hasOwnProperty // for `window` on <=IE8\r\n\r\n  for (var key in obj) {\r\n    if (has.call(obj, key)) {\r\n      keys.push(key);\r\n    }\r\n  }\r\n\r\n  return keys;\r\n};\r\n\r\n/**\r\n * Watch the given `files` for changes\r\n * and invoke `fn(file)` on modification.\r\n *\r\n * @param {Array} files\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.watch = function(files, fn){\r\n  var options = { interval: 100 };\r\n  files.forEach(function(file){\r\n    debug('file %s', file);\r\n    fs.watchFile(file, options, function(curr, prev){\r\n      if (prev.mtime < curr.mtime) fn(file);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Ignored files.\r\n */\r\n\r\nfunction ignored(path){\r\n  return !~ignore.indexOf(path);\r\n}\r\n\r\n/**\r\n * Lookup files in the given `dir`.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nexports.files = function(dir, ret){\r\n  ret = ret || [];\r\n\r\n  fs.readdirSync(dir)\r\n  .filter(ignored)\r\n  .forEach(function(path){\r\n    path = join(dir, path);\r\n    if (fs.statSync(path).isDirectory()) {\r\n      exports.files(path, ret);\r\n    } else if (path.match(/\\.(js|coffee)$/)) {\r\n      ret.push(path);\r\n    }\r\n  });\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Compute a slug from the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.slug = function(str){\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/ +/g, '-')\r\n    .replace(/[^-\\w]/g, '');\r\n};\r\n\r\n/**\r\n * Strip the function definition from `str`,\r\n * and re-indent for pre whitespace.\r\n */\r\n\r\nexports.clean = function(str) {\r\n  str = str\r\n    .replace(/^function *\\(.*\\) *{/, '')\r\n    .replace(/\\s+\\}$/, '');\r\n\r\n  var spaces = str.match(/^\\n?( *)/)[1].length\r\n    , re = new RegExp('^ {' + spaces + '}', 'gm');\r\n\r\n  str = str.replace(re, '');\r\n\r\n  return exports.trim(str);\r\n};\r\n\r\n/**\r\n * Escape regular expression characters in `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escapeRegexp = function(str){\r\n  return str.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n};\r\n\r\n/**\r\n * Trim the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.trim = function(str){\r\n  return str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Parse the given `qs`.\r\n *\r\n * @param {String} qs\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nexports.parseQuery = function(qs){\r\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){\r\n    var i = pair.indexOf('=')\r\n      , key = pair.slice(0, i)\r\n      , val = pair.slice(++i);\r\n\r\n    obj[key] = decodeURIComponent(val);\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Highlight the given string of `js`.\r\n *\r\n * @param {String} js\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction highlight(js) {\r\n  return js\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\r\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\r\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/\\bnew *(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\r\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>')\r\n}\r\n\r\n/**\r\n * Highlight the contents of tag `name`.\r\n *\r\n * @param {String} name\r\n * @api private\r\n */\r\n\r\nexports.highlightTags = function(name) {\r\n  var code = document.getElementsByTagName(name);\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    code[i].innerHTML = highlight(code[i].innerHTML);\r\n  }\r\n};\r\n\r\n}); // module: utils.js\r\n/**\r\n * Node shims.\r\n *\r\n * These are meant only to allow\r\n * mocha.js to run untouched, not\r\n * to allow running node code in\r\n * the browser.\r\n */\r\n\r\nprocess = {};\r\nprocess.exit = function(status){};\r\nprocess.stdout = {};\r\nglobal = window;\r\n\r\n/**\r\n * next tick implementation.\r\n */\r\n\r\nprocess.nextTick = (function(){\r\n  // postMessage behaves badly on IE8\r\n  if (window.ActiveXObject || !window.postMessage) {\r\n    return function(fn){ fn() };\r\n  }\r\n\r\n  // based on setZeroTimeout by David Baron\r\n  // - http://dbaron.org/log/20100309-faster-timeouts\r\n  var timeouts = []\r\n    , name = 'mocha-zero-timeout'\r\n\r\n  window.addEventListener('message', function(e){\r\n    if (e.source == window && e.data == name) {\r\n      if (e.stopPropagation) e.stopPropagation();\r\n      if (timeouts.length) timeouts.shift()();\r\n    }\r\n  }, true);\r\n\r\n  return function(fn){\r\n    timeouts.push(fn);\r\n    window.postMessage(name, '*');\r\n  }\r\n})();\r\n\r\n/**\r\n * Remove uncaughtException listener.\r\n */\r\n\r\nprocess.removeListener = function(e){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = null;\r\n  }\r\n};\r\n\r\n/**\r\n * Implements uncaughtException listener.\r\n */\r\n\r\nprocess.on = function(e, fn){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = fn;\r\n  }\r\n};\r\n\r\n// boot\r\n;(function(){\r\n\r\n  /**\r\n   * Expose mocha.\r\n   */\r\n\r\n  var Mocha = window.Mocha = require('mocha'),\r\n      mocha = window.mocha = new Mocha({ reporter: 'html' });\r\n\r\n  /**\r\n   * Override ui to ensure that the ui functions are initialized.\r\n   * Normally this would happen in Mocha.prototype.loadFiles.\r\n   */\r\n\r\n  mocha.ui = function(ui){\r\n    Mocha.prototype.ui.call(this, ui);\r\n    this.suite.emit('pre-require', window, null, this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Setup mocha with the given setting options.\r\n   */\r\n\r\n  mocha.setup = function(opts){\r\n    if ('string' == typeof opts) opts = { ui: opts };\r\n    for (var opt in opts) this[opt](opts[opt]);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Run mocha, returning the Runner.\r\n   */\r\n\r\n  mocha.run = function(fn){\r\n    var options = mocha.options;\r\n    mocha.globals('location');\r\n\r\n    var query = Mocha.utils.parseQuery(window.location.search || '');\r\n    if (query.grep) mocha.grep(query.grep);\r\n\r\n    return Mocha.prototype.run.call(mocha, function(){\r\n      Mocha.utils.highlightTags('code');\r\n      if (fn) fn();\r\n    });\r\n  };\r\n})();\r\n})();","/**\r\n * Testing the browser version of NeDB\r\n * The goal of these tests is not to be exhaustive, we have the server-side NeDB tests for that\r\n * This is more of a sanity check which executes most of the code at least once and checks\r\n * it behaves as the server version does\r\n */\r\n\r\nvar assert = chai.assert;\r\nchai.should();\r\n\r\n/**\r\n * Given a docs array and an id, return the document whose id matches, or null if none is found\r\n */\r\nfunction findById (docs, id) {\r\n  return _.find(docs, function (doc) { return doc._id === id; }) || null;\r\n}\r\n\r\n\r\ndescribe('Basic CRUD functionality', function () {\r\n\r\n  it('Able to create a database object in the browser', function () {\r\n    var db = new Nedb();\r\n\r\n    db.inMemoryOnly.should.equal(true);\r\n    db.persistence.inMemoryOnly.should.equal(true);\r\n  });\r\n\r\n  it('Insertion and querying', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ a: 4 }, function (err, newDoc1) {\r\n      assert.isNull(err);\r\n      db.insert({ a: 40 }, function (err, newDoc2) {\r\n        assert.isNull(err);\r\n        db.insert({ a: 400 }, function (err, newDoc3) {\r\n          assert.isNull(err);\r\n\r\n          db.find({ a: { $gt: 36 } }, function (err, docs) {\r\n            var doc2 = _.find(docs, function (doc) { return doc._id === newDoc2._id; })\r\n              , doc3 = _.find(docs, function (doc) { return doc._id === newDoc3._id; })\r\n              ;\r\n\r\n            assert.isNull(err);\r\n            docs.length.should.equal(2);\r\n            doc2.a.should.equal(40);\r\n            doc3.a.should.equal(400);\r\n\r\n            db.find({ a: { $lt: 36 } }, function (err, docs) {\r\n              assert.isNull(err);\r\n              docs.length.should.equal(1);\r\n              docs[0].a.should.equal(4);\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Querying with regular expressions', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ planet: 'Earth' }, function (err, newDoc1) {\r\n      assert.isNull(err);\r\n      db.insert({ planet: 'Mars' }, function (err, newDoc2) {\r\n        assert.isNull(err);\r\n        db.insert({ planet: 'Jupiter' }, function (err, newDoc3) {\r\n          assert.isNull(err);\r\n          db.insert({ planet: 'Eaaaaaarth' }, function (err, newDoc4) {\r\n            assert.isNull(err);\r\n            db.insert({ planet: 'Maaaars' }, function (err, newDoc5) {\r\n              assert.isNull(err);\r\n\r\n              db.find({ planet: /ar/ }, function (err, docs) {\r\n                assert.isNull(err);\r\n                docs.length.should.equal(4);\r\n                _.find(docs, function (doc) { return doc._id === newDoc1._id; }).planet.should.equal('Earth');\r\n                _.find(docs, function (doc) { return doc._id === newDoc2._id; }).planet.should.equal('Mars');\r\n                _.find(docs, function (doc) { return doc._id === newDoc4._id; }).planet.should.equal('Eaaaaaarth');\r\n                _.find(docs, function (doc) { return doc._id === newDoc5._id; }).planet.should.equal('Maaaars');\r\n\r\n                db.find({ planet: /aa+r/ }, function (err, docs) {\r\n                  assert.isNull(err);\r\n                  docs.length.should.equal(2);\r\n                  _.find(docs, function (doc) { return doc._id === newDoc4._id; }).planet.should.equal('Eaaaaaarth');\r\n                  _.find(docs, function (doc) { return doc._id === newDoc5._id; }).planet.should.equal('Maaaars');\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Updating documents', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ planet: 'Eaaaaarth' }, function (err, newDoc1) {\r\n      db.insert({ planet: 'Maaaaars' }, function (err, newDoc2) {\r\n        // Simple update\r\n        db.update({ _id: newDoc2._id }, { $set: { planet: 'Saturn' } }, {}, function (err, nr) {\r\n          assert.isNull(err);\r\n          nr.should.equal(1);\r\n\r\n          db.find({}, function (err, docs) {\r\n            docs.length.should.equal(2);\r\n            findById(docs, newDoc1._id).planet.should.equal('Eaaaaarth');\r\n            findById(docs, newDoc2._id).planet.should.equal('Saturn');\r\n\r\n            // Failing update\r\n            db.update({ _id: 'unknown' }, { $inc: { count: 1 } }, {}, function (err, nr) {\r\n              assert.isNull(err);\r\n              nr.should.equal(0);\r\n\r\n              db.find({}, function (err, docs) {\r\n                docs.length.should.equal(2);\r\n                findById(docs, newDoc1._id).planet.should.equal('Eaaaaarth');\r\n                findById(docs, newDoc2._id).planet.should.equal('Saturn');\r\n\r\n                // Document replacement\r\n                db.update({ planet: 'Eaaaaarth' }, { planet: 'Uranus' }, { multi: false }, function (err, nr) {\r\n                  assert.isNull(err);\r\n                  nr.should.equal(1);\r\n\r\n                  db.find({}, function (err, docs) {\r\n                    docs.length.should.equal(2);\r\n                    findById(docs, newDoc1._id).planet.should.equal('Uranus');\r\n                    findById(docs, newDoc2._id).planet.should.equal('Saturn');\r\n\r\n                    // Multi update\r\n                    db.update({}, { $inc: { count: 3 } }, { multi: true }, function (err, nr) {\r\n                      assert.isNull(err);\r\n                      nr.should.equal(2);\r\n\r\n                      db.find({}, function (err, docs) {\r\n                        docs.length.should.equal(2);\r\n                        findById(docs, newDoc1._id).planet.should.equal('Uranus');\r\n                        findById(docs, newDoc1._id).count.should.equal(3);\r\n                        findById(docs, newDoc2._id).planet.should.equal('Saturn');\r\n                        findById(docs, newDoc2._id).count.should.equal(3);\r\n\r\n                        done();\r\n                      });\r\n                    });\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Updating documents: special modifiers', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ planet: 'Earth' }, function (err, newDoc1) {\r\n      // Pushing to an array\r\n      db.update({}, { $push: { satellites: 'Phobos' } }, {}, function (err, nr) {\r\n        assert.isNull(err);\r\n        nr.should.equal(1);\r\n\r\n        db.findOne({}, function (err, doc) {\r\n          assert.deepEqual(doc, { planet: 'Earth', _id: newDoc1._id, satellites: ['Phobos'] });\r\n\r\n          db.update({}, { $push: { satellites: 'Deimos' } }, {}, function (err, nr) {\r\n            assert.isNull(err);\r\n            nr.should.equal(1);\r\n\r\n            db.findOne({}, function (err, doc) {\r\n              assert.deepEqual(doc, { planet: 'Earth', _id: newDoc1._id, satellites: ['Phobos', 'Deimos'] });\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Upserts', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.update({ a: 4 }, { $inc: { b: 1 } }, { upsert: true }, function (err, nr, upsert) {\r\n      assert.isNull(err);\r\n      upsert.should.equal(true);\r\n      nr.should.equal(1);\r\n\r\n      db.find({}, function (err, docs) {\r\n        docs.length.should.equal(1);\r\n        docs[0].a.should.equal(4);\r\n        docs[0].b.should.equal(1);\r\n\r\n        done();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Removing documents', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ a: 2 });\r\n    db.insert({ a: 5 });\r\n    db.insert({ a: 7 });\r\n\r\n    // Multi remove\r\n    db.remove({ a: { $in: [ 5, 7 ] } }, { multi: true }, function (err, nr) {\r\n      assert.isNull(err);\r\n      nr.should.equal(2);\r\n\r\n      db.find({}, function (err, docs) {\r\n        docs.length.should.equal(1);\r\n        docs[0].a.should.equal(2);\r\n\r\n        // Remove with no match\r\n        db.remove({ b: { $exists: true } }, { multi: true }, function (err, nr) {\r\n          assert.isNull(err);\r\n          nr.should.equal(0);\r\n\r\n          db.find({}, function (err, docs) {\r\n            docs.length.should.equal(1);\r\n            docs[0].a.should.equal(2);\r\n\r\n            // Simple remove\r\n            db.remove({ a: { $exists: true } }, { multi: true }, function (err, nr) {\r\n              assert.isNull(err);\r\n              nr.should.equal(1);\r\n\r\n              db.find({}, function (err, docs) {\r\n                docs.length.should.equal(0);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n});   // ==== End of 'Basic CRUD functionality' ==== //\r\n\r\n\r\ndescribe('Indexing', function () {\r\n\r\n  it('getCandidates works as expected', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.insert({ a: 4 }, function () {\r\n      db.insert({ a: 6 }, function () {\r\n        db.insert({ a: 7 }, function () {\r\n          var candidates = db.getCandidates({ a: 6 })\r\n          candidates.length.should.equal(3);\r\n          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 4; }));\r\n          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));\r\n          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 7; }));\r\n\r\n          db.ensureIndex({ fieldName: 'a' });\r\n\r\n          candidates = db.getCandidates({ a: 6 })\r\n          candidates.length.should.equal(1);\r\n          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Can use indexes to enforce a unique constraint', function (done) {\r\n    var db = new Nedb();\r\n\r\n    db.ensureIndex({ fieldName: 'u', unique: true });\r\n\r\n    db.insert({ u : 5 }, function (err) {\r\n      assert.isNull(err);\r\n\r\n      db.insert({ u : 98 }, function (err) {\r\n        assert.isNull(err);\r\n\r\n        db.insert({ u : 5 }, function (err) {\r\n          err.errorType.should.equal('uniqueViolated');\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n});   // ==== End of 'Indexing' ==== //\r\n\r\n\r\n\r\n","var Datastore = require('./lib/datastore');\r\n\r\nmodule.exports = Datastore;\r\n","var crypto = require('crypto')\r\n  , fs = require('fs')\r\n  ;\r\n\r\n/**\r\n * Return a random alphanumerical string of length len\r\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\r\n * (il the base64 conversion yields too many pluses and slashes) but\r\n * that's not an issue here\r\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\r\n * See http://en.wikipedia.org/wiki/Birthday_problem\r\n */\r\nfunction uid (len) {\r\n  return crypto.randomBytes(Math.ceil(Math.max(8, len * 2)))\r\n    .toString('base64')\r\n    .replace(/[+\\/]/g, '')\r\n    .slice(0, len);\r\n}\r\n\r\n\r\n/**\r\n * Callback signature: err\r\n */\r\nfunction ensureFileDoesntExist (file, callback) {\r\n  fs.exists(file, function (exists) {\r\n    if (!exists) { return callback(null); }\r\n    \r\n    fs.unlink(file, function (err) { return callback(err); });\r\n  });\r\n}\r\n\r\n\r\nmodule.exports.uid = uid;\r\nmodule.exports.ensureFileDoesntExist = ensureFileDoesntExist;\r\n","var customUtils = require('./customUtils')\r\n  , model = require('./model')\r\n  , async = require('async')\r\n  , Executor = require('./executor')\r\n  , Index = require('./indexes')\r\n  , util = require('util')\r\n  , _ = require('underscore')\r\n  , Persistence = require('./persistence')\r\n  ;\r\n\r\n\r\n/**\r\n * Create a new collection\r\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\r\n * @param {Boolean} options.inMemoryOnly Optional, default to false\r\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\r\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\r\n * @param {Boolean} options.autoload Optional, defaults to false\r\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\r\n */\r\nfunction Datastore (options) {\r\n  var filename;\r\n\r\n  // Retrocompatibility with v0.6 and before\r\n  if (typeof options === 'string') {\r\n    filename = options;\r\n    this.inMemoryOnly = false;   // Default\r\n  } else {\r\n    options = options || {};\r\n    filename = options.filename;\r\n    this.inMemoryOnly = options.inMemoryOnly || false;\r\n    this.autoload = options.autoload || false;\r\n  }\r\n\r\n  // Determine whether in memory or persistent\r\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\r\n    this.filename = null;\r\n    this.inMemoryOnly = true;\r\n  } else {\r\n    this.filename = filename;\r\n  }\r\n\r\n  // Persistence handling\r\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName });\r\n\r\n  // This new executor is ready if we don't use persistence\r\n  // If we do, it will only be ready once loadDatabase is called\r\n  this.executor = new Executor();\r\n  if (this.inMemoryOnly) { this.executor.ready = true; }\r\n\r\n  // Indexed by field name, dot notation can be used\r\n  // _id is always indexed and since _ids are generated randomly the underlying\r\n  // binary is always well-balanced\r\n  this.indexes = {};\r\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\r\n  \r\n  // Queue a load of the database right away and call the onload handler\r\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\r\n  if (this.autoload) { this.loadDatabase(options.onload || function (err) {\r\n    if (err) { throw err; }\r\n  }); }\r\n}\r\n\r\n\r\n/**\r\n * Load the database from the datafile, and trigger the execution of buffered commands if any\r\n */\r\nDatastore.prototype.loadDatabase = function () {\r\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\r\n};\r\n\r\n\r\n/**\r\n * Get an array of all the data in the database\r\n */\r\nDatastore.prototype.getAllData = function () {\r\n  return this.indexes._id.getAll();\r\n};\r\n\r\n\r\n/**\r\n * Reset all currently defined indexes\r\n */\r\nDatastore.prototype.resetIndexes = function (newData) {\r\n  var self = this;\r\n\r\n  Object.keys(this.indexes).forEach(function (i) {\r\n    self.indexes[i].reset(newData);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Ensure an index is kept for this field. Same parameters as lib/indexes\r\n * For now this function is synchronous, we need to test how much time it takes\r\n * We use an async API for consistency with the rest of the code\r\n * @param {String} options.fieldName\r\n * @param {Boolean} options.unique\r\n * @param {Boolean} options.sparse\r\n * @param {Function} cb Optional callback, signature: err\r\n */\r\nDatastore.prototype.ensureIndex = function (options, cb) {\r\n  var callback = cb || function () {};\r\n\r\n  options = options || {};\r\n\r\n  if (!options.fieldName) { return callback({ missingFieldName: true }); }\r\n  if (this.indexes[options.fieldName]) { return callback(null); }\r\n\r\n  this.indexes[options.fieldName] = new Index(options);\r\n\r\n  try {\r\n    this.indexes[options.fieldName].insert(this.getAllData());\r\n  } catch (e) {\r\n    delete this.indexes[options.fieldName];\r\n    return callback(e);\r\n  }\r\n\r\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Remove an index\r\n * @param {String} fieldName\r\n * @param {Function} cb Optional callback, signature: err \r\n */\r\nDatastore.prototype.removeIndex = function (fieldName, cb) {\r\n  var callback = cb || function () {};\r\n  \r\n  delete this.indexes[fieldName];\r\n  \r\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null);\r\n  });  \r\n};\r\n\r\n\r\n/**\r\n * Add one or several document(s) to all indexes\r\n */\r\nDatastore.prototype.addToIndexes = function (doc) {\r\n  var i, failingIndex, error\r\n    , keys = Object.keys(this.indexes)\r\n    ;\r\n\r\n  for (i = 0; i < keys.length; i += 1) {\r\n    try {\r\n      this.indexes[keys[i]].insert(doc);\r\n    } catch (e) {\r\n      failingIndex = i;\r\n      error = e;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error happened, we need to rollback the insert on all other indexes\r\n  if (error) {\r\n    for (i = 0; i < failingIndex; i += 1) {\r\n      this.indexes[keys[i]].remove(doc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove one or several document(s) from all indexes\r\n */\r\nDatastore.prototype.removeFromIndexes = function (doc) {\r\n  var self = this;\r\n\r\n  Object.keys(this.indexes).forEach(function (i) {\r\n    self.indexes[i].remove(doc);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Update one or several documents in all indexes\r\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\r\n * If one update violates a constraint, all changes are rolled back\r\n */\r\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\r\n  var i, failingIndex, error\r\n    , keys = Object.keys(this.indexes)\r\n    ;\r\n\r\n  for (i = 0; i < keys.length; i += 1) {\r\n    try {\r\n      this.indexes[keys[i]].update(oldDoc, newDoc);\r\n    } catch (e) {\r\n      failingIndex = i;\r\n      error = e;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error happened, we need to rollback the update on all other indexes\r\n  if (error) {\r\n    for (i = 0; i < failingIndex; i += 1) {\r\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Return the list of candidates for a given query\r\n * Crude implementation for now, we return the candidates given by the first usable index if any\r\n * We try the following query types, in this order: basic match, $in match, comparison match\r\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\r\n * returns too much data. I may do it in the future.\r\n */\r\nDatastore.prototype.getCandidates = function (query) {\r\n  var indexNames = Object.keys(this.indexes)\r\n    , usableQueryKeys;\r\n\r\n  // For a basic match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]);\r\n  }\r\n\r\n  // For a $in match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (query[k] && query[k].hasOwnProperty('$in')) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in);\r\n  }\r\n\r\n  // For a comparison match\r\n  usableQueryKeys = [];\r\n  Object.keys(query).forEach(function (k) {\r\n    if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\r\n      usableQueryKeys.push(k);\r\n    }\r\n  });\r\n  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\r\n  if (usableQueryKeys.length > 0) {\r\n    return this.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]);\r\n  }\r\n\r\n  // By default, return all the DB data\r\n  return this.getAllData();\r\n};\r\n\r\n\r\n/**\r\n * Insert a new document\r\n * @param {Function} cb Optional callback, signature: err, insertedDoc\r\n *\r\n * @api private Use Datastore.insert which has the same signature\r\n */\r\nDatastore.prototype._insert = function (newDoc, cb) {\r\n  var callback = cb || function () {}\r\n    ;\r\n\r\n  try {\r\n    this._insertInCache(newDoc);\r\n  } catch (e) {\r\n    return callback(e);\r\n  }\r\n\r\n  this.persistence.persistNewState(util.isArray(newDoc) ? newDoc : [newDoc], function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null, newDoc);\r\n  });\r\n};\r\n\r\n/**\r\n * Prepare a document (or array of documents) to be inserted in a database\r\n * @api private\r\n */\r\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\r\n  var preparedDoc, self = this;\r\n\r\n  if (util.isArray(newDoc)) {\r\n    preparedDoc = [];\r\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\r\n  } else {\r\n    newDoc._id = customUtils.uid(16);\r\n    preparedDoc = model.deepCopy(newDoc);\r\n    model.checkObject(preparedDoc);\r\n  }\r\n  \r\n  return preparedDoc;\r\n};\r\n\r\n/**\r\n * If newDoc is an array of documents, this will insert all documents in the cache\r\n * @api private\r\n */\r\nDatastore.prototype._insertInCache = function (newDoc) {\r\n  if (util.isArray(newDoc)) {\r\n    this._insertMultipleDocsInCache(newDoc);\r\n  } else {\r\n    this.addToIndexes(this.prepareDocumentForInsertion(newDoc));  \r\n  }\r\n};\r\n\r\n/**\r\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\r\n * inserts and throws the error\r\n * @api private\r\n */\r\nDatastore.prototype._insertMultipleDocsInCache = function (newDocs) {\r\n  var i, failingI, error\r\n    , preparedDocs = this.prepareDocumentForInsertion(newDocs)\r\n    ;\r\n  \r\n  for (i = 0; i < preparedDocs.length; i += 1) {\r\n    try {\r\n      this.addToIndexes(preparedDocs[i]);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.removeFromIndexes(preparedDocs[i]);\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n};\r\n\r\nDatastore.prototype.insert = function () {\r\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\r\n};\r\n\r\n/**\r\n * Count all documents matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use count\r\n */\r\nDatastore.prototype._count = function(query, callback) {\r\n  var res = 0\r\n    , self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        res++;\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, res);\r\n}\r\n\r\nDatastore.prototype.count = function() {\r\n    this.executor.push({this: this, fn: this._count, arguments: arguments });\r\n}\r\n\r\n/**\r\n * Find all documents matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use find\r\n */\r\nDatastore.prototype._find = function (query, callback) {\r\n  var res = []\r\n    , self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        res.push(model.deepCopy(candidates[i]));\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, res);\r\n};\r\n\r\nDatastore.prototype.find = function () {\r\n  this.executor.push({ this: this, fn: this._find, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Find one document matching the query\r\n * @param {Object} query MongoDB-style query\r\n *\r\n * @api private Use findOne\r\n */\r\nDatastore.prototype._findOne = function (query, callback) {\r\n  var self = this\r\n    , candidates = this.getCandidates(query)\r\n    , i, found = null\r\n    ;\r\n\r\n  try {\r\n    for (i = 0; i < candidates.length; i += 1) {\r\n      if (model.match(candidates[i], query)) {\r\n        found = model.deepCopy(candidates[i]);\r\n      }\r\n    }\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  return callback(null, found);\r\n};\r\n\r\nDatastore.prototype.findOne = function () {\r\n  this.executor.push({ this: this, fn: this._findOne, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Update all docs matching query\r\n * For now, very naive implementation (recalculating the whole database)\r\n * @param {Object} query\r\n * @param {Object} updateQuery\r\n * @param {Object} options Optional options\r\n *                 options.multi If true, can update multiple documents (defaults to false)\r\n *                 options.upsert If true, document is inserted if the query doesn't match anything\r\n * @param {Function} cb Optional callback, signature: err, numReplaced, upsert (set to true if the update was in fact an upsert)\r\n *\r\n * @api private Use Datastore.update which has the same signature\r\n */\r\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\r\n  var callback\r\n    , self = this\r\n    , numReplaced = 0\r\n    , multi, upsert\r\n    , i\r\n    ;\r\n\r\n  if (typeof options === 'function') { cb = options; options = {}; }\r\n  callback = cb || function () {};\r\n  multi = options.multi !== undefined ? options.multi : false;\r\n  upsert = options.upsert !== undefined ? options.upsert : false;\r\n\r\n  async.waterfall([\r\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\r\n    if (!upsert) { return cb(); }\r\n\r\n    self._findOne(query, function (err, doc) {\r\n      if (err) { return callback(err); }\r\n      if (doc) {\r\n        return cb();\r\n      } else {\r\n        // The upserted document is the query (since for now queries have the same structure as\r\n        // documents), modified by the updateQuery\r\n        return self._insert(model.modify(query, updateQuery), function (err) {\r\n          if (err) { return callback(err); }\r\n          return callback(null, 1, true);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  , function () {   // Perform the update\r\n    var modifiedDoc\r\n\t  , candidates = self.getCandidates(query)\r\n\t  , modifications = []\r\n\t  ;\r\n\r\n\t// Preparing update (if an error is thrown here neither the datafile nor\r\n\t// the in-memory indexes are affected)\r\n    try {\r\n      for (i = 0; i < candidates.length; i += 1) {\r\n        if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\r\n          numReplaced += 1;\r\n          modifiedDoc = model.modify(candidates[i], updateQuery);\r\n          modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\r\n        }\r\n      }\r\n    } catch (err) {\r\n      return callback(err);\r\n    }\r\n\t\r\n\t// Change the docs in memory\r\n\ttry {\r\n      self.updateIndexes(modifications);\r\n\t} catch (err) {\r\n\t  return callback(err);\r\n\t}\r\n\r\n\t// Update the datafile\r\n    self.persistence.persistNewState(_.pluck(modifications, 'newDoc'), function (err) {\r\n      if (err) { return callback(err); }\r\n      return callback(null, numReplaced);\r\n    });\r\n  }\r\n  ]);\r\n};\r\nDatastore.prototype.update = function () {\r\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\r\n};\r\n\r\n\r\n/**\r\n * Remove all docs matching the query\r\n * For now very naive implementation (similar to update)\r\n * @param {Object} query\r\n * @param {Object} options Optional options\r\n *                 options.multi If true, can update multiple documents (defaults to false)\r\n * @param {Function} cb Optional callback, signature: err, numRemoved\r\n *\r\n * @api private Use Datastore.remove which has the same signature\r\n */\r\nDatastore.prototype._remove = function (query, options, cb) {\r\n  var callback\r\n    , self = this\r\n    , numRemoved = 0\r\n    , multi\r\n    , removedDocs = []\r\n    , candidates = this.getCandidates(query)\r\n    ;\r\n\r\n  if (typeof options === 'function') { cb = options; options = {}; }\r\n  callback = cb || function () {};\r\n  multi = options.multi !== undefined ? options.multi : false;\r\n\r\n  try {\r\n    candidates.forEach(function (d) {\r\n      if (model.match(d, query) && (multi || numRemoved === 0)) {\r\n        numRemoved += 1;\r\n        removedDocs.push({ $$deleted: true, _id: d._id });\r\n        self.removeFromIndexes(d);\r\n      }\r\n    });\r\n  } catch (err) { return callback(err); }\r\n\r\n  self.persistence.persistNewState(removedDocs, function (err) {\r\n    if (err) { return callback(err); }\r\n    return callback(null, numRemoved);\r\n  });\r\n};\r\nDatastore.prototype.remove = function () {\r\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\r\n};\r\n\r\n\r\nmodule.exports = Datastore;","/**\r\n * Responsible for sequentially executing actions on the database\r\n */\r\n\r\nvar async = require('async')\r\n  ;\r\n\r\nfunction Executor () {\r\n  this.buffer = [];\r\n  this.ready = false;\r\n\r\n  // This queue will execute all commands, one-by-one in order\r\n  this.queue = async.queue(function (task, cb) {\r\n    var callback\r\n      , lastArg = task.arguments[task.arguments.length - 1]\r\n      , i, newArguments = []\r\n      ;\r\n\r\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\r\n    for (i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\r\n\r\n    // Always tell the queue task is complete. Execute callback if any was given.\r\n    if (typeof lastArg === 'function') {\r\n      callback = function () {\r\n        lastArg.apply(null, arguments);\r\n        cb();\r\n      };\r\n\r\n      newArguments[newArguments.length - 1] = callback;\r\n    } else {\r\n      callback = function () { cb(); };\r\n      newArguments.push(callback);\r\n    }\r\n\r\n\r\n    task.fn.apply(task.this, newArguments);\r\n  }, 1);\r\n}\r\n\r\n\r\n/**\r\n * If executor is ready, queue task (and process it immediately if executor was idle)\r\n * If not, buffer task for later processing\r\n * @param {Object} task\r\n *                 task.this - Object to use as this\r\n *                 task.fn - Function to execute\r\n *                 task.arguments - Array of arguments\r\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\r\n */\r\nExecutor.prototype.push = function (task, forceQueuing) {\r\n  if (this.ready || forceQueuing) {\r\n    this.queue.push(task);\r\n  } else {\r\n    this.buffer.push(task);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Queue all tasks in buffer (in the same order they came in)\r\n * Automatically sets executor as ready\r\n */\r\nExecutor.prototype.processBuffer = function () {\r\n  var i;\r\n  this.ready = true;\r\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\r\n  this.buffer = [];\r\n};\r\n\r\n\r\n\r\n// Interface\r\nmodule.exports = Executor;\r\n","var BinarySearchTree = require('binary-search-tree').AVLTree\r\n  , model = require('./model')\r\n  , _ = require('underscore')\r\n  , util = require('util')\r\n  ;\r\n\r\n/**\r\n * Two indexed pointers are equal iif they point to the same place\r\n */\r\nfunction checkValueEquality (a, b) {\r\n  return a === b;\r\n}\r\n\r\n/**\r\n * Type-aware projection\r\n */\r\nfunction projectForUnique (elt) {\r\n  if (elt === null) { return '$null'; }\r\n  if (typeof elt === 'string') { return '$string' + elt; }\r\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\r\n  if (typeof elt === 'number') { return '$number' + elt; }\r\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\r\n  \r\n  return elt;   // Arrays and objects, will check for pointer equality\r\n}\r\n\r\n\r\n/**\r\n * Create a new index\r\n * All methods on an index guarantee that either the whole operation was successful and the index changed\r\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\r\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\r\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\r\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\r\n */\r\nfunction Index (options) {\r\n  this.fieldName = options.fieldName;\r\n  this.unique = options.unique || false;\r\n  this.sparse = options.sparse || false;\r\n\r\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\r\n\r\n  this.reset();   // No data in the beginning\r\n}\r\n\r\n\r\n/**\r\n * Reset an index\r\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\r\n *                                                 If an error is thrown during insertion, the index is not modified\r\n */\r\nIndex.prototype.reset = function (newData) {\r\n  this.tree = new BinarySearchTree(this.treeOptions);\r\n\r\n  if (newData) { this.insert(newData); }\r\n};\r\n\r\n\r\n/**\r\n * Insert a new document in the index\r\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\r\n * O(log(n))\r\n */\r\nIndex.prototype.insert = function (doc) {\r\n  var key, self = this\r\n    , keys, i, failingI, error\r\n    ;\r\n\r\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\r\n\r\n  key = model.getDotValue(doc, this.fieldName);\r\n\r\n  // We don't index documents that don't contain the field if the index is sparse\r\n  if (key === undefined && this.sparse) { return; }\r\n\r\n  if (!util.isArray(key)) {\r\n    this.tree.insert(key, doc);\r\n  } else {\r\n    // If an insert fails due to a unique constraint, roll back all inserts before it\r\n    keys = _.uniq(key, projectForUnique);\r\n\r\n    for (i = 0; i < keys.length; i += 1) {\r\n      try {\r\n        this.tree.insert(keys[i], doc);\r\n      } catch (e) {\r\n        error = e;\r\n        failingI = i;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (error) {\r\n      for (i = 0; i < failingI; i += 1) {\r\n        this.tree.delete(keys[i], doc);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Insert an array of documents in the index\r\n * If a constraint is violated, the changes should be rolled back and an error thrown\r\n *\r\n * @API private\r\n */\r\nIndex.prototype.insertMultipleDocs = function (docs) {\r\n  var i, error, failingI;\r\n\r\n  for (i = 0; i < docs.length; i += 1) {\r\n    try {\r\n      this.insert(docs[i]);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.remove(docs[i]);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove a document from the index\r\n * If an array is passed, we remove all its elements\r\n * The remove operation is safe with regards to the 'unique' constraint\r\n * O(log(n))\r\n */\r\nIndex.prototype.remove = function (doc) {\r\n  var key, self = this;\r\n\r\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\r\n\r\n  key = model.getDotValue(doc, this.fieldName);\r\n\r\n  if (key === undefined && this.sparse) { return; }\r\n\r\n  if (!util.isArray(key)) {\r\n    this.tree.delete(key, doc);\r\n  } else {\r\n    _.uniq(key, projectForUnique).forEach(function (_key) {\r\n      self.tree.delete(_key, doc);\r\n    });\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Update a document in the index\r\n * If a constraint is violated, changes are rolled back and an error thrown\r\n * Naive implementation, still in O(log(n))\r\n */\r\nIndex.prototype.update = function (oldDoc, newDoc) {\r\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\r\n\r\n  this.remove(oldDoc);\r\n\r\n  try {\r\n    this.insert(newDoc);\r\n  } catch (e) {\r\n    this.insert(oldDoc);\r\n    throw e;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Update multiple documents in the index\r\n * If a constraint is violated, the changes need to be rolled back\r\n * and an error thrown\r\n * @param {Array of oldDoc, newDoc pairs} pairs\r\n *\r\n * @API private\r\n */\r\nIndex.prototype.updateMultipleDocs = function (pairs) {\r\n  var i, failingI, error;\r\n\r\n  for (i = 0; i < pairs.length; i += 1) {\r\n    this.remove(pairs[i].oldDoc);\r\n  }\r\n\r\n  for (i = 0; i < pairs.length; i += 1) {\r\n    try {\r\n      this.insert(pairs[i].newDoc);\r\n    } catch (e) {\r\n      error = e;\r\n      failingI = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If an error was raised, roll back changes in the inverse order\r\n  if (error) {\r\n    for (i = 0; i < failingI; i += 1) {\r\n      this.remove(pairs[i].newDoc);\r\n    }\r\n\r\n    for (i = 0; i < pairs.length; i += 1) {\r\n      this.insert(pairs[i].oldDoc);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Revert an update\r\n */\r\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\r\n  var revert = [];\r\n\r\n  if (!util.isArray(oldDoc)) {\r\n    this.update(newDoc, oldDoc);\r\n  } else {\r\n    oldDoc.forEach(function (pair) {\r\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\r\n    });\r\n    this.update(revert);\r\n  }\r\n};\r\n\r\n\r\n// Append all elements in toAppend to array\r\nfunction append (array, toAppend) {\r\n  var i;\r\n\r\n  for (i = 0; i < toAppend.length; i += 1) {\r\n    array.push(toAppend[i]);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\r\n * @param {Thing} value Value to match the key against\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getMatching = function (value) {\r\n  var res, self = this;\r\n\r\n  if (!util.isArray(value)) {\r\n    return this.tree.search(value);\r\n  } else {\r\n    res = [];\r\n    value.forEach(function (v) { append(res, self.getMatching(v)); });\r\n    return res;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Get all documents in index whose key is between bounds are they are defined by query\r\n * Documents are sorted by key\r\n * @param {Query} query\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getBetweenBounds = function (query) {\r\n  return this.tree.betweenBounds(query);\r\n};\r\n\r\n\r\n/**\r\n * Get all elements in the index\r\n * @return {Array of documents}\r\n */\r\nIndex.prototype.getAll = function () {\r\n  var res = [];\r\n\r\n  this.tree.executeOnEveryNode(function (node) {\r\n    var i;\r\n\r\n    for (i = 0; i < node.data.length; i += 1) {\r\n      res.push(node.data[i]);\r\n    }\r\n  });\r\n\r\n  return res;\r\n};\r\n\r\n\r\n\r\n\r\n// Interface\r\nmodule.exports = Index;\r\n","/**\r\n * Handle models (i.e. docs)\r\n * Serialization/deserialization\r\n * Copying\r\n * Querying, update\r\n */\r\n\r\nvar dateToJSON = function () { return { $$date: this.getTime() }; }\r\n  , originalDateToJSON = Date.prototype.toJSON\r\n  , util = require('util')\r\n  , _ = require('underscore')\r\n  , modifierFunctions = {}\r\n  , lastStepModifierFunctions = {}\r\n  , comparisonFunctions = {}\r\n  , logicalOperators = {}\r\n  , arrayComparisonFunctions = {}\r\n  ;\r\n\r\n\r\n/**\r\n * Check a key, throw an error if the key is non valid\r\n * @param {String} k key\r\n * @param {Model} v value, needed to treat the Date edge case\r\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\r\n * Its serialized-then-deserialized version it will transformed into a Date object\r\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\r\n */\r\nfunction checkKey (k, v) {\r\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {\r\n    throw 'Field names cannot begin with the $ character';\r\n  }\r\n\r\n  if (k.indexOf('.') !== -1) {\r\n    throw 'Field names cannot contain a .';\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Check a DB object and throw an error if it's not valid\r\n * Works by applying the above checkKey function to all fields recursively\r\n */\r\nfunction checkObject (obj) {\r\n  if (util.isArray(obj)) {\r\n    obj.forEach(function (o) {\r\n      checkObject(o);\r\n    });\r\n  }\r\n\r\n  if (typeof obj === 'object' && obj !== null) {\r\n    Object.keys(obj).forEach(function (k) {\r\n      checkKey(k, obj[k]);\r\n      checkObject(obj[k]);\r\n    });\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Serialize an object to be persisted to a one-line string\r\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\r\n * That gives us less freedom but data entered in the database may come from users\r\n * so eval and the like are not safe\r\n * Accepted primitive types: Number, String, Boolean, Date, null\r\n * Accepted secondary types: Objects, Arrays\r\n */\r\nfunction serialize (obj) {\r\n  var res;\r\n\r\n  // Keep track of the fact that this is a Date object\r\n  Date.prototype.toJSON = dateToJSON;\r\n\r\n  res = JSON.stringify(obj, function (k, v) {\r\n    checkKey(k, v);\r\n\r\n    if (typeof v === undefined) { return null; }\r\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }\r\n\r\n    return v;\r\n  });\r\n\r\n  // Return Date to its original state\r\n  Date.prototype.toJSON = originalDateToJSON;\r\n\r\n  return res;\r\n}\r\n\r\n\r\n/**\r\n * From a one-line representation of an object generate by the serialize function\r\n * Return the object itself\r\n */\r\nfunction deserialize (rawData) {\r\n  return JSON.parse(rawData, function (k, v) {\r\n    if (k === '$$date') { return new Date(v); }\r\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }\r\n    if (v && v.$$date) { return v.$$date; }\r\n\r\n    return v;\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Deep copy a DB object\r\n */\r\nfunction deepCopy (obj) {\r\n  var res;\r\n\r\n  if ( typeof obj === 'boolean' ||\r\n       typeof obj === 'number' ||\r\n       typeof obj === 'string' ||\r\n       obj === null ||\r\n       (util.isDate(obj)) ) {\r\n    return obj;\r\n  }\r\n\r\n  if (util.isArray(obj)) {\r\n    res = [];\r\n    obj.forEach(function (o) { res.push(o); });\r\n    return res;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    res = {};\r\n    Object.keys(obj).forEach(function (k) {\r\n      res[k] = deepCopy(obj[k]);\r\n    });\r\n    return res;\r\n  }\r\n\r\n  return undefined;   // For now everything else is undefined. We should probably throw an error instead\r\n}\r\n\r\n\r\n/**\r\n * Tells if an object is a primitive type or a \"real\" object\r\n * Arrays are considered primitive\r\n */\r\nfunction isPrimitiveType (obj) {\r\n  return ( typeof obj === 'boolean' ||\r\n       typeof obj === 'number' ||\r\n       typeof obj === 'string' ||\r\n       obj === null ||\r\n       util.isDate(obj) ||\r\n       util.isArray(obj));\r\n}\r\n\r\n\r\n/**\r\n * Utility functions for comparing things\r\n * Assumes type checking was already done (a and b already have the same type)\r\n * compareNSB works for numbers, strings and booleans\r\n */\r\nfunction compareNSB (a, b) {\r\n  if (a < b) { return -1; }\r\n  if (a > b) { return 1; }\r\n  return 0;\r\n}\r\n\r\nfunction compareArrays (a, b) {\r\n  var i, comp;\r\n\r\n  for (i = 0; i < Math.min(a.length, b.length); i += 1) {\r\n    comp = compareThings(a[i], b[i]);\r\n\r\n    if (comp !== 0) { return comp; }\r\n  }\r\n\r\n  // Common section was identical, longest one wins\r\n  return compareNSB(a.length, b.length);\r\n}\r\n\r\n\r\n/**\r\n * Compare { things U undefined }\r\n * Things are defined as any native types (string, number, boolean, null, date) and objects\r\n * We need to compare with undefined as it will be used in indexes\r\n * In the case of objects and arrays, we deep-compare\r\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\r\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\r\n */\r\nfunction compareThings (a, b) {\r\n  var aKeys, bKeys, comp, i;\r\n\r\n  // undefined\r\n  if (a === undefined) { return b === undefined ? 0 : -1; }\r\n  if (b === undefined) { return a === undefined ? 0 : 1; }\r\n\r\n  // null\r\n  if (a === null) { return b === null ? 0 : -1; }\r\n  if (b === null) { return a === null ? 0 : 1; }\r\n\r\n  // Numbers\r\n  if (typeof a === 'number') { return typeof b === 'number' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }\r\n\r\n  // Strings\r\n  if (typeof a === 'string') { return typeof b === 'string' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'string') { return typeof a === 'string' ? compareNSB(a, b) : 1; }\r\n\r\n  // Booleans\r\n  if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }\r\n  if (typeof b === 'boolean') { return typeof a === 'boolean' ? compareNSB(a, b) : 1; }\r\n\r\n  // Dates\r\n  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }\r\n  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }\r\n\r\n  // Arrays (first element is most significant and so on)\r\n  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }\r\n  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }\r\n\r\n  // Objects\r\n  aKeys = Object.keys(a).sort();\r\n  bKeys = Object.keys(b).sort();\r\n\r\n  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\r\n    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\r\n\r\n    if (comp !== 0) { return comp; }\r\n  }\r\n\r\n  return compareNSB(aKeys.length, bKeys.length);\r\n}\r\n\r\n\r\n\r\n// ==============================================================\r\n// Updating documents\r\n// ==============================================================\r\n\r\n/**\r\n * The signature of modifier functions is as follows\r\n * Their structure is always the same: recursively follow the dot notation while creating\r\n * the nested documents if needed, then apply the \"last step modifier\"\r\n * @param {Object} obj The model to modify\r\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\r\n * @param {Model} value\r\n */\r\n\r\n/**\r\n * Set a field to a new value\r\n */\r\nlastStepModifierFunctions.$set = function (obj, field, value) {\r\n  obj[field] = value;\r\n};\r\n\r\n\r\n/**\r\n * Unset a field\r\n */\r\nlastStepModifierFunctions.$unset = function (obj, field, value) {\r\n  delete obj[field];\r\n};\r\n\r\n\r\n/**\r\n * Push an element to the end of an array field\r\n */\r\nlastStepModifierFunctions.$push = function (obj, field, value) {\r\n  // Create the array if it doesn't exist\r\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\r\n\r\n  if (!util.isArray(obj[field])) { throw \"Can't $push an element on non-array values\"; }\r\n\r\n  if (value !== null && typeof value === 'object' && value.$each) {\r\n    if (Object.keys(value).length > 1) { throw \"Can't use another field in conjunction with $each\"; }\r\n    if (!util.isArray(value.$each)) { throw \"$each requires an array value\"; }\r\n\r\n    value.$each.forEach(function (v) {\r\n      obj[field].push(v);\r\n    });\r\n  } else {\r\n    obj[field].push(value);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Add an element to an array field only if it is not already in it\r\n * No modification if the element is already in the array\r\n * Note that it doesn't check whether the original array contains duplicates\r\n */\r\nlastStepModifierFunctions.$addToSet = function (obj, field, value) {\r\n  var addToSet = true;\r\n\r\n  // Create the array if it doesn't exist\r\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\r\n\r\n  if (!util.isArray(obj[field])) { throw \"Can't $addToSet an element on non-array values\"; }\r\n\r\n  if (value !== null && typeof value === 'object' && value.$each) {\r\n    if (Object.keys(value).length > 1) { throw \"Can't use another field in conjunction with $each\"; }\r\n    if (!util.isArray(value.$each)) { throw \"$each requires an array value\"; }\r\n\r\n    value.$each.forEach(function (v) {\r\n      lastStepModifierFunctions.$addToSet(obj, field, v);\r\n    });\r\n  } else {\r\n    obj[field].forEach(function (v) {\r\n      if (compareThings(v, value) === 0) { addToSet = false; }\r\n    });\r\n    if (addToSet) { obj[field].push(value); }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Remove the first or last element of an array\r\n */\r\nlastStepModifierFunctions.$pop = function (obj, field, value) {\r\n  if (!util.isArray(obj[field])) { throw \"Can't $pop an element from non-array values\"; }\r\n  if (typeof value !== 'number') { throw value + \" isn't an integer, can't use it with $pop\"; }\r\n  if (value === 0) { return; }\r\n\r\n  if (value > 0) {\r\n    obj[field] = obj[field].slice(0, obj[field].length - 1);\r\n  } else {\r\n    obj[field] = obj[field].slice(1);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes all instances of a value from an existing array\r\n */\r\nlastStepModifierFunctions.$pull = function (obj, field, value) {\r\n  var arr, i;\r\n  \r\n  if (!util.isArray(obj[field])) { throw \"Can't $pull an element from non-array values\"; }\r\n\r\n  arr = obj[field];\r\n  for (i = arr.length - 1; i >= 0; i -= 1) {\r\n    if (match(arr[i], value)) {\r\n      arr.splice(i, 1);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Increment a numeric field's value\r\n */\r\nlastStepModifierFunctions.$inc = function (obj, field, value) {\r\n  if (typeof value !== 'number') { throw value + \" must be a number\"; }\r\n\r\n  if (typeof obj[field] !== 'number') {\r\n    if (!_.has(obj, field)) {\r\n      obj[field] = value;\r\n    } else {\r\n      throw \"Don't use the $inc modifier on non-number fields\";\r\n    }\r\n  } else {\r\n    obj[field] += value;\r\n  }\r\n};\r\n\r\n// Given its name, create the complete modifier function\r\nfunction createModifierFunction (modifier) {\r\n  return function (obj, field, value) {\r\n    var fieldParts = typeof field === 'string' ? field.split('.') : field;\r\n\r\n    if (fieldParts.length === 1) {\r\n      lastStepModifierFunctions[modifier](obj, field, value);\r\n    } else {\r\n      obj[fieldParts[0]] = obj[fieldParts[0]] || {};\r\n      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);\r\n    }\r\n  };\r\n}\r\n\r\n// Actually create all modifier functions\r\nObject.keys(lastStepModifierFunctions).forEach(function (modifier) {\r\n  modifierFunctions[modifier] = createModifierFunction(modifier);\r\n});\r\n\r\n\r\n/**\r\n * Modify a DB object according to an update query\r\n * For now the updateQuery only replaces the object\r\n */\r\nfunction modify (obj, updateQuery) {\r\n  var keys = Object.keys(updateQuery)\r\n    , firstChars = _.map(keys, function (item) { return item[0]; })\r\n    , dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; })\r\n    , newDoc, modifiers\r\n    ;\r\n\r\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) { throw \"You cannot change a document's _id\"; }\r\n\r\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\r\n    throw \"You cannot mix modifiers and normal fields\";\r\n  }\r\n\r\n  if (dollarFirstChars.length === 0) {\r\n    // Simply replace the object with the update query contents\r\n    newDoc = deepCopy(updateQuery);\r\n    newDoc._id = obj._id;\r\n  } else {\r\n    // Apply modifiers\r\n    modifiers = _.uniq(keys);\r\n    newDoc = deepCopy(obj);\r\n    modifiers.forEach(function (m) {\r\n      var keys;\r\n\r\n      if (!modifierFunctions[m]) { throw \"Unknown modifier \" + m; }\r\n\r\n      try {\r\n        keys = Object.keys(updateQuery[m]);\r\n      } catch (e) {\r\n        throw \"Modifier \" + m + \"'s argument must be an object\";\r\n      }\r\n\r\n      keys.forEach(function (k) {\r\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Check result is valid and return it\r\n  checkObject(newDoc);\r\n  if (obj._id !== newDoc._id) { throw \"You can't change a document's _id\"; }\r\n  return newDoc;\r\n};\r\n\r\n\r\n// ==============================================================\r\n// Finding documents\r\n// ==============================================================\r\n\r\n/**\r\n * Get a value from object with dot notation\r\n * @param {Object} obj\r\n * @param {String} field\r\n */\r\nfunction getDotValue (obj, field) {\r\n  var fieldParts = typeof field === 'string' ? field.split('.') : field\r\n    , i, objs;\r\n\r\n  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match\r\n\r\n  if (fieldParts.length === 0) { return obj; }\r\n\r\n  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }\r\n  \r\n  if (util.isArray(obj[fieldParts[0]])) {\r\n    // If the next field is an integer, return only this item of the array\r\n    i = parseInt(fieldParts[1], 10);\r\n    if (typeof i === 'number' && !isNaN(i)) {\r\n      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))\r\n    }\r\n\r\n    // Return the array of values\r\n    objs = new Array();\r\n    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {\r\n       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));\r\n    }\r\n    return objs;\r\n  } else {\r\n    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Check whether 'things' are equal\r\n * Things are defined as any native types (string, number, boolean, null, date) and objects\r\n * In the case of object, we check deep equality\r\n * Returns true if they are, false otherwise\r\n */\r\nfunction areThingsEqual (a, b) {\r\n  var aKeys , bKeys , i;\r\n\r\n  // Strings, booleans, numbers, null\r\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' ||\r\n      b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') { return a === b; }\r\n\r\n  // Dates\r\n  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime(); }\r\n\r\n  // Arrays (no match since arrays are used as a $in)\r\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\r\n  if (util.isArray(a) || util.isArray(b) || a === undefined || b === undefined) { return false; }\r\n\r\n  // General objects (check for deep equality)\r\n  // a and b should be objects at this point\r\n  try {\r\n    aKeys = Object.keys(a);\r\n    bKeys = Object.keys(b);\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n\r\n  if (aKeys.length !== bKeys.length) { return false; }\r\n  for (i = 0; i < aKeys.length; i += 1) {\r\n    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }\r\n    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Check that two values are comparable\r\n */\r\nfunction areComparable (a, b) {\r\n  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) &&\r\n      typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof a !== typeof b) { return false; }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Arithmetic and comparison operators\r\n * @param {Native value} a Value in the object\r\n * @param {Native value} b Value in the query\r\n */\r\ncomparisonFunctions.$lt = function (a, b) {\r\n  return areComparable(a, b) && a < b;\r\n};\r\n\r\ncomparisonFunctions.$lte = function (a, b) {\r\n  return areComparable(a, b) && a <= b;\r\n};\r\n\r\ncomparisonFunctions.$gt = function (a, b) {\r\n  return areComparable(a, b) && a > b;\r\n};\r\n\r\ncomparisonFunctions.$gte = function (a, b) {\r\n  return areComparable(a, b) && a >= b;\r\n};\r\n\r\ncomparisonFunctions.$ne = function (a, b) {\r\n  if (!a) { return true; }\r\n  return !areThingsEqual(a, b);\r\n};\r\n\r\ncomparisonFunctions.$in = function (a, b) {\r\n  var i;\r\n\r\n  if (!util.isArray(b)) { throw \"$in operator called with a non-array\"; }\r\n\r\n  for (i = 0; i < b.length; i += 1) {\r\n    if (areThingsEqual(a, b[i])) { return true; }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\ncomparisonFunctions.$nin = function (a, b) {\r\n  if (!util.isArray(b)) { throw \"$nin operator called with a non-array\"; }\r\n\r\n  return !comparisonFunctions.$in(a, b);\r\n};\r\n\r\ncomparisonFunctions.$regex = function (a, b) {\r\n  if (!util.isRegExp(b)) { throw \"$regex operator called with non regular expression\"; }\r\n\r\n  if (typeof a !== 'string') {\r\n    return false\r\n  } else {\r\n    return b.test(a);\r\n  }\r\n};\r\n\r\ncomparisonFunctions.$exists = function (value, exists) {\r\n  if (exists || exists === '') {   // This will be true for all values of exists except false, null, undefined and 0\r\n    exists = true;                 // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\r\n  } else {\r\n    exists = false;\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return !exists\r\n  } else {\r\n    return exists;\r\n  }\r\n};\r\n\r\n// Specific to arrays\r\ncomparisonFunctions.$size = function (obj, value) {\r\n    if (!util.isArray(obj)) { return false; }\r\n    if (value % 1 !== 0) { throw \"$size operator called without an integer\"; }\r\n\r\n    return (obj.length == value);\r\n};\r\narrayComparisonFunctions.$size = true;\r\n\r\n\r\n/**\r\n * Match any of the subqueries\r\n * @param {Model} obj\r\n * @param {Array of Queries} query\r\n */\r\nlogicalOperators.$or = function (obj, query) {\r\n  var i;\r\n\r\n  if (!util.isArray(query)) { throw \"$or operator used without an array\"; }\r\n\r\n  for (i = 0; i < query.length; i += 1) {\r\n    if (match(obj, query[i])) { return true; }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Match all of the subqueries\r\n * @param {Model} obj\r\n * @param {Array of Queries} query\r\n */\r\nlogicalOperators.$and = function (obj, query) {\r\n  var i;\r\n\r\n  if (!util.isArray(query)) { throw \"$and operator used without an array\"; }\r\n\r\n  for (i = 0; i < query.length; i += 1) {\r\n    if (!match(obj, query[i])) { return false; }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Inverted match of the query\r\n * @param {Model} obj\r\n * @param {Query} query\r\n */\r\nlogicalOperators.$not = function (obj, query) {\r\n  return !match(obj, query);\r\n};\r\n\r\n\r\n/**\r\n * Tell if a given document matches a query\r\n * @param {Object} obj Document to check\r\n * @param {Object} query\r\n */\r\nfunction match (obj, query) {\r\n  var queryKeys, queryKey, queryValue, i;\r\n\r\n  // Primitive query against a primitive type\r\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\r\n  // But I don't have time for a cleaner implementation now\r\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) {\r\n    return matchQueryPart({ needAKey: obj }, 'needAKey', query);\r\n  }\r\n    \r\n  // Normal query\r\n  queryKeys = Object.keys(query);\r\n  for (i = 0; i < queryKeys.length; i += 1) {\r\n    queryKey = queryKeys[i];\r\n    queryValue = query[queryKey];\r\n  \r\n    if (queryKey[0] === '$') {\r\n      if (!logicalOperators[queryKey]) { throw \"Unknown logical operator \" + queryKey; }\r\n      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }\r\n    } else {\r\n      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Match an object against a specific { key: value } part of a query\r\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\r\n */\r\nfunction matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {\r\n  var objValue = getDotValue(obj, queryKey)\r\n    , i, keys, firstChars, dollarFirstChars;\r\n\r\n  // Check if the value is an array if we don't force a treatment as value\r\n  if (util.isArray(objValue) && !treatObjAsValue) {\r\n    // Check if we are using an array-specific comparison function\r\n    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\r\n      keys = Object.keys(queryValue);      \r\n      for (i = 0; i < keys.length; i += 1) {\r\n        if (arrayComparisonFunctions[keys[i]]) { return matchQueryPart(obj, queryKey, queryValue, true); }\r\n      }\r\n    }\r\n\r\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\r\n    for (i = 0; i < objValue.length; i += 1) {\r\n      if (matchQueryPart({ k: objValue[i] }, 'k', queryValue)) { return true; }   // k here could be any string\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // queryValue is an actual object. Determine whether it contains comparison operators\r\n  // or only normal fields. Mixed objects are not allowed\r\n  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\r\n    keys = Object.keys(queryValue);\r\n    firstChars = _.map(keys, function (item) { return item[0]; });\r\n    dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });\r\n\r\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\r\n      throw \"You cannot mix operators and normal fields\";\r\n    }\r\n\r\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\r\n    if (dollarFirstChars.length > 0) {\r\n      for (i = 0; i < keys.length; i += 1) {\r\n        if (!comparisonFunctions[keys[i]]) { throw \"Unknown comparison function \" + keys[i]; }\r\n\r\n        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) { return false; }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Using regular expressions with basic querying\r\n  if (util.isRegExp(queryValue)) { return comparisonFunctions.$regex(objValue, queryValue); }\r\n\r\n  // queryValue is either a native value or a normal object\r\n  // Basic matching is possible\r\n  if (!areThingsEqual(objValue, queryValue)) { return false; }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n// Interface\r\nmodule.exports.serialize = serialize;\r\nmodule.exports.deserialize = deserialize;\r\nmodule.exports.deepCopy = deepCopy;\r\nmodule.exports.checkObject = checkObject;\r\nmodule.exports.isPrimitiveType = isPrimitiveType;\r\nmodule.exports.modify = modify;\r\nmodule.exports.getDotValue = getDotValue;\r\nmodule.exports.match = match;\r\nmodule.exports.areThingsEqual = areThingsEqual;\r\nmodule.exports.compareThings = compareThings;\r\n","/**\r\n * Handle every persistence-related task\r\n * The interface Datastore expects to be implemented is\r\n * * Persistence.loadDatabase(callback) and callback has signature err\r\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\r\n */\r\n\r\nvar fs = require('fs')\r\n  , path = require('path')\r\n  , model = require('./model')\r\n  , async = require('async')\r\n  , mkdirp = require('mkdirp')\r\n  , customUtils = require('./customUtils')\r\n  , Index = require('./indexes')\r\n  ;\r\n\r\n\r\n/**\r\n * Create a new Persistence object for database options.db\r\n * @param {Datastore} options.db\r\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\r\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\r\n */\r\nfunction Persistence (options) {\r\n  this.db = options.db;\r\n  this.inMemoryOnly = this.db.inMemoryOnly;\r\n  this.filename = this.db.filename;\r\n  \r\n  if (!this.inMemoryOnly && this.filename) {\r\n    if (this.filename.charAt(this.filename.length - 1) === '~') {\r\n      throw \"The datafile name can't end with a ~, which is reserved for automatic backup files\";\r\n    } else {\r\n      this.tempFilename = this.filename + '~';\r\n      this.oldFilename = this.filename + '~~';\r\n    }\r\n  }\r\n\r\n  // For NW apps, store data in the same directory where NW stores application data\r\n  if (this.filename && options.nodeWebkitAppName) {\r\n    console.log(\"==================================================================\");\r\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\r\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\r\n    console.log(\"for your app, use the internal nw.gui module like this\");\r\n    console.log(\"require('nw.gui').App.dataPath\");\r\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\r\n    console.log(\"==================================================================\");\r\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\r\n    this.tempFilename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.tempFilename);\r\n    this.oldFilename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.oldFilename);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Check if a directory exists and create it on the fly if it is not the case\r\n * cb is optional, signature: err\r\n */\r\nPersistence.ensureDirectoryExists = function (dir, cb) {\r\n  var callback = cb || function () {}\r\n    ;\r\n\r\n  mkdirp(dir, function (err) { return callback(err); });\r\n};\r\n\r\n\r\n/**\r\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\r\n * data for this application. Probably the best place to store data\r\n */\r\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\r\n  var home;\r\n\r\n  switch (process.platform) {\r\n    case 'win32':\r\n    case 'win64':\r\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\r\n      if (!home) { throw \"Couldn't find the base application data folder\"; }\r\n      home = path.join(home, appName);\r\n      break;\r\n    case 'darwin':\r\n      home = process.env.HOME;\r\n      if (!home) { throw \"Couldn't find the base application data directory\"; }\r\n      home = path.join(home, 'Library', 'Application Support', appName);\r\n      break;\r\n    case 'linux':\r\n      home = process.env.HOME;\r\n      if (!home) { throw \"Couldn't find the base application data directory\"; }\r\n      home = path.join(home, '.config', appName);\r\n      break;\r\n    default:\r\n      throw \"Can't use the Node Webkit relative path for platform \" + process.platform;\r\n      break;\r\n  }\r\n\r\n  return path.join(home, 'nedb-data', relativeFilename);\r\n}\r\n\r\n\r\n/**\r\n * Persist cached database\r\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\r\n * while the data file is append-only so it may grow larger\r\n * @param {Function} cb Optional callback, signature: err\r\n */\r\nPersistence.prototype.persistCachedDatabase = function (cb) {\r\n  var callback = cb || function () {}\r\n    , toPersist = ''\r\n    , self = this\r\n    ;\r\n\r\n  if (this.inMemoryOnly) { return callback(null); } \r\n\r\n  this.db.getAllData().forEach(function (doc) {\r\n    toPersist += model.serialize(doc) + '\\n';\r\n  });\r\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\r\n    if (fieldName != \"_id\") {   // The special _id index is managed by datastore.js, the others need to be persisted\r\n      toPersist += model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }}) + '\\n';\r\n    }\r\n  });\r\n\r\n  async.waterfall([\r\n    async.apply(customUtils.ensureFileDoesntExist, self.tempFilename)\r\n  , async.apply(customUtils.ensureFileDoesntExist, self.oldFilename)\r\n  , function (cb) {\r\n      fs.exists(self.filename, function (exists) {\r\n        if (exists) {\r\n          fs.rename(self.filename, self.oldFilename, function (err) { return cb(err); });\r\n        } else {\r\n          return cb();\r\n        }\r\n      });  \r\n  }\r\n  , function (cb) {\r\n      fs.writeFile(self.tempFilename, toPersist, function (err) { return cb(err); });\r\n    }\r\n  , function (cb) {\r\n      fs.rename(self.tempFilename, self.filename, function (err) { return cb(err); });\r\n    }\r\n  , async.apply(customUtils.ensureFileDoesntExist, self.oldFilename)\r\n  ], function (err) { if (err) { return callback(err); } else { return callback(null); } })\r\n};\r\n\r\n\r\n/**\r\n * Queue a rewrite of the datafile\r\n */\r\nPersistence.prototype.compactDatafile = function () {\r\n  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });\r\n};\r\n\r\n\r\n/**\r\n * Set automatic compaction every interval ms\r\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\r\n */\r\nPersistence.prototype.setAutocompactionInterval = function (interval) {\r\n  var self = this;\r\n\r\n  if (interval < 5000) { interval = 5000; }\r\n  this.stopAutocompaction();\r\n\r\n  this.autocompactionIntervalId = setInterval(function () {\r\n    self.compactDatafile();\r\n  }, interval);\r\n};\r\n\r\n\r\n/**\r\n * Stop autocompaction (do nothing if autocompaction was not running)\r\n */\r\nPersistence.prototype.stopAutocompaction = function () {\r\n  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }\r\n};\r\n\r\n\r\n/**\r\n * Persist new state for the given newDocs (can be insertion, update or removal)\r\n * Use an append-only format\r\n * @param {Array} newDocs Can be empty if no doc was updated/removed\r\n * @param {Function} cb Optional, signature: err\r\n */\r\nPersistence.prototype.persistNewState = function (newDocs, cb) {\r\n  var self = this\r\n    , toPersist = ''\r\n    , callback = cb || function () {}\r\n    ;\r\n\r\n  // In-memory only datastore\r\n  if (self.inMemoryOnly) { return callback(null); }\r\n\r\n  newDocs.forEach(function (doc) {\r\n    toPersist += model.serialize(doc) + '\\n';\r\n  });\r\n\r\n  if (toPersist.length === 0) { return callback(null); }\r\n\r\n  fs.appendFile(self.filename, toPersist, 'utf8', function (err) {\r\n    return callback(err);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * From a database's raw data, return the corresponding\r\n * machine understandable collection\r\n */\r\nPersistence.treatRawData = function (rawData) {\r\n  var data = rawData.split('\\n')\r\n    , dataById = {}\r\n    , tdata = []\r\n    , i\r\n    , indexes = {}\r\n    ;\r\n\r\n  for (i = 0; i < data.length; i += 1) {\r\n    var doc;\r\n\r\n    try {\r\n      doc = model.deserialize(data[i]);\r\n      if (doc._id) {\r\n        if (doc.$$deleted === true) {\r\n          delete dataById[doc._id];\r\n        } else {\r\n          dataById[doc._id] = doc;\r\n        }\r\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\r\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\r\n      } else if (typeof doc.$$indexRemoved === \"string\") {\r\n        delete indexes[doc.$$indexRemoved];\r\n      }\r\n    } catch (e) {\r\n    }\r\n  }\r\n\r\n  Object.keys(dataById).forEach(function (k) {\r\n    tdata.push(dataById[k]);\r\n  });\r\n\r\n  return { data: tdata, indexes: indexes };\r\n};\r\n\r\n\r\n/**\r\n * Ensure that this.filename contains the most up-to-date version of the data\r\n * Even if a loadDatabase crashed before\r\n */\r\nPersistence.prototype.ensureDatafileIntegrity = function (callback) {\r\n  var self = this  ;\r\n\r\n  fs.exists(self.filename, function (filenameExists) {\r\n    // Write was successful\r\n    if (filenameExists) { return callback(null); }\r\n  \r\n    fs.exists(self.oldFilename, function (oldFilenameExists) {\r\n      // New database\r\n      if (!oldFilenameExists) {\r\n        return fs.writeFile(self.filename, '', 'utf8', function (err) { callback(err); });            \r\n      }\r\n    \r\n      // Write failed, use old version\r\n      fs.rename(self.oldFilename, self.filename, function (err) { return callback(err); });\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Load the database\r\n * 1) Create all indexes\r\n * 2) Insert all data\r\n * 3) Compact the database\r\n * This means pulling data out of the data file or creating it if it doesn't exist\r\n * Also, all data is persisted right away, which has the effect of compacting the database file\r\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\r\n * @param {Function} cb Optional callback, signature: err\r\n */\r\nPersistence.prototype.loadDatabase = function (cb) {\r\n  var callback = cb || function () {}\r\n    , self = this\r\n    ;\r\n\r\n  self.db.resetIndexes();\r\n\r\n  // In-memory only datastore\r\n  if (self.inMemoryOnly) { return callback(null); }\r\n\r\n  async.waterfall([\r\n    function (cb) {\r\n      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\r\n        self.ensureDatafileIntegrity(function (exists) {\r\n          fs.readFile(self.filename, 'utf8', function (err, rawData) {\r\n            if (err) { return cb(err); }\r\n            var treatedData = Persistence.treatRawData(rawData);\r\n\r\n            // Recreate all indexes in the datafile\r\n            Object.keys(treatedData.indexes).forEach(function (key) {\r\n              self.db.indexes[key] = new Index(treatedData.indexes[key]);\r\n            });\r\n            \r\n            // Fill cached database (i.e. all indexes) with data\r\n            try {\r\n              self.db.resetIndexes(treatedData.data);\r\n            } catch (e) {\r\n              self.db.resetIndexes();   // Rollback any index which didn't fail\r\n              return cb(e);\r\n            }\r\n\r\n            self.db.persistence.persistCachedDatabase(cb);\r\n          });\r\n        });\r\n      });\r\n    }\r\n  ], function (err) {\r\n       if (err) { return callback(err); }\r\n\r\n       self.db.executor.processBuffer();\r\n       return callback(null);\r\n     });\r\n};\r\n\r\n\r\n// Interface\r\nmodule.exports = Persistence;\r\n","/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","module.exports.BinarySearchTree = require('./lib/bst');\nmodule.exports.AVLTree = require('./lib/avltree');\n","/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst')\n  , customUtils = require('./customUtils')\n  , util = require('util')\n  , _ = require('underscore')\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw \"Undefined height for node \" + this.left.key; }\n  if (this.right && this.right.height === undefined) { throw \"Undefined height for node \" + this.right.key; }\n  if (this.height === undefined) { throw \"Undefined height for node \" + this.key; }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw \"Height constraint failed for node \" + this.key; }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw 'Tree is unbalanced at node ' + this.key; }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        throw { message: \"Can't insert key \" + key + \", it violates the unique constraint\"\n              , key: key\n              , errorType: 'uniqueViolated'\n              };\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n","/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw 'Tree with root ' + self.key + ' is not a binary search tree';\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw 'Tree with root ' + self.key + ' is not a binary search tree';\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw 'Parent pointer broken for key ' + this.key; }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw 'Parent pointer broken for key ' + this.key; }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw \"The root shouldn't have a parent\"; }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      throw { message: \"Can't insert key \" + key + \", it violates the unique constraint\"\n            , key: key\n            , errorType: 'uniqueViolated'\n            };\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n","/**\n * Return an array with the numbers from 0 to n-1, in a random order\n */\nfunction getRandomArray (n) {\n  var res, next;\n\n  if (n === 0) { return []; }\n  if (n === 1) { return [0]; }\n\n  res = getRandomArray(n - 1);\n  next = Math.floor(Math.random() * n);\n  res.splice(next, 0, n - 1);   // Add n-1 at a random position in the array\n\n  return res;\n};\nmodule.exports.getRandomArray = getRandomArray;\n\n\n/*\n * Default compareKeys function will work for numbers, strings and dates\n */\nfunction defaultCompareKeysFunction (a, b) {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n\n  throw { message: \"Couldn't compare elements\", a: a, b: b };\n}\nmodule.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;\n\n\n/**\n * Check whether two values are equal (used in non-unique deletion)\n */\nfunction defaultCheckValueEquality (a, b) {\n  return a === b;\n}\nmodule.exports.defaultCheckValueEquality = defaultCheckValueEquality;\n","var should = require('chai').should()\n  , assert = require('chai').assert\n  , AVLTree = require('../index').AVLTree\n  , _ = require('underscore')\n  , customUtils = require('../lib/customUtils')\n  ;\n\n\ndescribe('AVL tree', function () {\n\n  describe('Sanity checks', function () {\n\n    it('Checking that all nodes heights are correct', function () {\n      var _AVLTree = AVLTree._AVLTree\n        , avlt = new _AVLTree({ key: 10 })\n        , l = new _AVLTree({ key: 5 })\n        , r = new _AVLTree({ key: 15 })\n        , ll = new _AVLTree({ key: 3 })\n        , lr = new _AVLTree({ key: 8 })\n        , rl = new _AVLTree({ key: 13 })\n        , rr = new _AVLTree({ key: 18 })\n        , lrl = new _AVLTree({ key: 7 })\n        , lrll = new _AVLTree({ key: 6 })\n        ;\n\n\n      // With a balanced tree\n      avlt.left = l;\n      avlt.right = r;\n      l.left = ll;\n      l.right = lr;\n      r.left = rl;\n      r.right = rr;\n\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      avlt.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      l.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      r.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      ll.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lr.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      rl.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      rr.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      avlt.height = 2;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      l.height = 2;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      r.height = 2;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      avlt.height = 3;\n      avlt.checkHeightCorrect();   // Correct\n\n      // With an unbalanced tree\n      lr.left = lrl;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lrl.left = lrll;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lrl.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lrll.height = 1;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lrl.height = 2;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      lr.height = 3;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      l.height = 4;\n      (function () { avlt.checkHeightCorrect() }).should.throw();\n      avlt.height = 5;\n      avlt.checkHeightCorrect();   // Correct\n    });\n\n    it('Calculate the balance factor', function () {\n      var _AVLTree = AVLTree._AVLTree\n        , avlt = new _AVLTree({ key: 10 })\n        , l = new _AVLTree({ key: 5 })\n        , r = new _AVLTree({ key: 15 })\n        , ll = new _AVLTree({ key: 3 })\n        , lr = new _AVLTree({ key: 8 })\n        , rl = new _AVLTree({ key: 13 })\n        , rr = new _AVLTree({ key: 18 })\n        , lrl = new _AVLTree({ key: 7 })\n        , lrll = new _AVLTree({ key: 6 })\n        ;\n\n\n      // With a balanced tree\n      avlt.left = l;\n      avlt.right = r;\n      l.left = ll;\n      l.right = lr;\n      r.left = rl;\n      r.right = rr;\n\n      ll.height = 1;\n      rl.height = 1;\n      rr.height = 1;\n      avlt.height = 2;\n      r.height = 2;\n      lr.left = lrl;\n      lrl.left = lrll;\n      lrl.height = 1;\n      lrll.height = 1;\n      lrl.height = 2;\n      lr.height = 3;\n      l.height = 4;\n      avlt.height = 5;\n      avlt.checkHeightCorrect();   // Correct\n\n      lrll.balanceFactor().should.equal(0);\n      lrl.balanceFactor().should.equal(1);\n      ll.balanceFactor().should.equal(0);\n      lr.balanceFactor().should.equal(2);\n      rl.balanceFactor().should.equal(0);\n      rr.balanceFactor().should.equal(0);\n      l.balanceFactor().should.equal(-2);\n      r.balanceFactor().should.equal(0);\n      avlt.balanceFactor().should.equal(2);\n    });\n\n    it('Can check that a tree is balanced', function () {\n      var _AVLTree = AVLTree._AVLTree\n        , avlt = new _AVLTree({ key: 10 })\n        , l = new _AVLTree({ key: 5 })\n        , r = new _AVLTree({ key: 15 })\n        , ll = new _AVLTree({ key: 3 })\n        , lr = new _AVLTree({ key: 8 })\n        , rl = new _AVLTree({ key: 13 })\n        , rr = new _AVLTree({ key: 18 })\n\n      avlt.left = l;\n      avlt.right = r;\n      l.left = ll;\n      l.right = lr;\n      r.left = rl;\n      r.right = rr;\n\n      ll.height = 1;\n      lr.height = 1;\n      rl.height = 1;\n      rr.height = 1;\n      l.height = 2;\n      r.height = 2;\n      avlt.height = 3;\n      avlt.checkBalanceFactors();\n\n      r.height = 0;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      r.height = 4;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      r.height = 2;\n      avlt.checkBalanceFactors();\n\n      ll.height = -1;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      ll.height = 3;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      ll.height = 1;\n      avlt.checkBalanceFactors();\n\n      rl.height = -1;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      rl.height = 3;\n      (function () { avlt.checkBalanceFactors(); }).should.throw();\n      rl.height = 1;\n      avlt.checkBalanceFactors();\n    });\n\n  });   // ==== End of 'Sanity checks' ==== //\n\n\n  describe('Insertion', function () {\n\n    it('The root has a height of 1', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'root');\n      avlt.tree.height.should.equal(1);\n    });\n\n\n    it('Insert at the root if its the first insertion', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'some data');\n\n      avlt.checkIsAVLT();\n      avlt.tree.key.should.equal(10);\n      _.isEqual(avlt.tree.data, ['some data']).should.equal(true);\n      assert.isNull(avlt.tree.left);\n      assert.isNull(avlt.tree.right);\n    });\n\n    it('If uniqueness constraint not enforced, we can insert different data for same key', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'some data');\n      avlt.insert(3, 'hello');\n      avlt.insert(3, 'world');\n\n      avlt.checkIsAVLT();\n      _.isEqual(avlt.search(3), ['hello', 'world']).should.equal(true);\n\n      avlt.insert(12, 'a');\n      avlt.insert(12, 'b');\n\n      avlt.checkIsAVLT();\n      _.isEqual(avlt.search(12), ['a', 'b']).should.equal(true);\n    });\n\n    it('If uniqueness constraint is enforced, we cannot insert different data for same key', function () {\n      var avlt = new AVLTree({ unique: true });\n\n      avlt.insert(10, 'some data');\n      avlt.insert(3, 'hello');\n      try {\n        avlt.insert(3, 'world');\n      } catch (e) {\n        e.errorType.should.equal('uniqueViolated');\n        e.key.should.equal(3);\n      }\n\n      avlt.checkIsAVLT();\n      _.isEqual(avlt.search(3), ['hello']).should.equal(true);\n\n      avlt.insert(12, 'a');\n      try {\n        avlt.insert(12, 'world');\n      } catch (e) {\n        e.errorType.should.equal('uniqueViolated');\n        e.key.should.equal(12);\n      }\n\n      avlt.checkIsAVLT();\n      _.isEqual(avlt.search(12), ['a']).should.equal(true);\n    });\n\n    it('Can insert 0 or the empty string', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(0, 'some data');\n\n      avlt.checkIsAVLT();\n      avlt.tree.key.should.equal(0);\n      _.isEqual(avlt.tree.data, ['some data']).should.equal(true);\n\n      avlt = new AVLTree();\n\n      avlt.insert('', 'some other data');\n\n      avlt.checkIsAVLT();\n      avlt.tree.key.should.equal('');\n      _.isEqual(avlt.tree.data, ['some other data']).should.equal(true);\n    });\n\n    it('Auto-balancing insertions', function () {\n      var avlt = new AVLTree()\n        , avlt2 = new AVLTree()\n        , avlt3 = new AVLTree()\n        ;\n\n      // Balancing insertions on the left\n      avlt.tree.getNumberOfKeys().should.equal(0);\n      avlt.insert(18);\n      avlt.tree.getNumberOfKeys().should.equal(1);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(15);\n      avlt.tree.getNumberOfKeys().should.equal(2);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(13);\n      avlt.tree.getNumberOfKeys().should.equal(3);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(10);\n      avlt.tree.getNumberOfKeys().should.equal(4);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(8);\n      avlt.tree.getNumberOfKeys().should.equal(5);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(5);\n      avlt.tree.getNumberOfKeys().should.equal(6);\n      avlt.tree.checkIsAVLT();\n      avlt.insert(3);\n      avlt.tree.getNumberOfKeys().should.equal(7);\n      avlt.tree.checkIsAVLT();\n\n      // Balancing insertions on the right\n      avlt2.tree.getNumberOfKeys().should.equal(0);\n      avlt2.insert(3);\n      avlt2.tree.getNumberOfKeys().should.equal(1);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(5);\n      avlt2.tree.getNumberOfKeys().should.equal(2);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(8);\n      avlt2.tree.getNumberOfKeys().should.equal(3);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(10);\n      avlt2.tree.getNumberOfKeys().should.equal(4);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(13);\n      avlt2.tree.getNumberOfKeys().should.equal(5);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(15);\n      avlt2.tree.getNumberOfKeys().should.equal(6);\n      avlt2.tree.checkIsAVLT();\n      avlt2.insert(18);\n      avlt2.tree.getNumberOfKeys().should.equal(7);\n      avlt2.tree.checkIsAVLT();\n\n      // Balancing already-balanced insertions\n      avlt3.tree.getNumberOfKeys().should.equal(0);\n      avlt3.insert(10);\n      avlt3.tree.getNumberOfKeys().should.equal(1);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(5);\n      avlt3.tree.getNumberOfKeys().should.equal(2);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(15);\n      avlt3.tree.getNumberOfKeys().should.equal(3);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(3);\n      avlt3.tree.getNumberOfKeys().should.equal(4);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(8);\n      avlt3.tree.getNumberOfKeys().should.equal(5);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(13);\n      avlt3.tree.getNumberOfKeys().should.equal(6);\n      avlt3.tree.checkIsAVLT();\n      avlt3.insert(18);\n      avlt3.tree.getNumberOfKeys().should.equal(7);\n      avlt3.tree.checkIsAVLT();\n    });\n\n    it('Can insert a lot of keys and still get an AVLT (sanity check)', function () {\n      var avlt = new AVLTree({ unique: true });\n\n      customUtils.getRandomArray(1000).forEach(function (n) {\n        avlt.insert(n, 'some data');\n        avlt.checkIsAVLT();\n      });\n\n    });\n\n  });   // ==== End of 'Insertion' ==== //\n\n\n  describe('Search', function () {\n\n    it('Can find data in an AVLT', function () {\n      var avlt = new AVLTree()\n        , i;\n\n      customUtils.getRandomArray(100).forEach(function (n) {\n        avlt.insert(n, 'some data for ' + n);\n      });\n\n      avlt.checkIsAVLT();\n\n      for (i = 0; i < 100; i += 1) {\n        _.isEqual(avlt.search(i), ['some data for ' + i]).should.equal(true);\n      }\n    });\n\n    it('If no data can be found, return an empty array', function () {\n      var avlt = new AVLTree();\n\n      customUtils.getRandomArray(100).forEach(function (n) {\n        if (n !== 63) {\n          avlt.insert(n, 'some data for ' + n);\n        }\n      });\n\n      avlt.checkIsAVLT();\n\n      avlt.search(-2).length.should.equal(0);\n      avlt.search(100).length.should.equal(0);\n      avlt.search(101).length.should.equal(0);\n      avlt.search(63).length.should.equal(0);\n    });\n\n    it('Can search for data between two bounds', function () {\n      var avlt = new AVLTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        avlt.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(avlt.betweenBounds({ $gte: 8, $lte: 15 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n      assert.deepEqual(avlt.betweenBounds({ $gt: 8, $lt: 15 }), ['data 10', 'data 13']);\n    });\n\n    it('Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte', function () {\n      var avlt = new AVLTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        avlt.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(avlt.betweenBounds({ $gt:8, $gte: 8, $lte: 15 }), ['data 10', 'data 13', 'data 15']);\n      assert.deepEqual(avlt.betweenBounds({ $gt:5, $gte: 8, $lte: 15 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n      assert.deepEqual(avlt.betweenBounds({ $gt:8, $gte: 5, $lte: 15 }), ['data 10', 'data 13', 'data 15']);\n\n      assert.deepEqual(avlt.betweenBounds({ $gte: 8, $lte: 15, $lt: 15 }), ['data 8', 'data 10', 'data 13']);\n      assert.deepEqual(avlt.betweenBounds({ $gte: 8, $lte: 18, $lt: 15 }), ['data 8', 'data 10', 'data 13']);\n      assert.deepEqual(avlt.betweenBounds({ $gte: 8, $lte: 15, $lt: 18 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n    });\n\n    it('Bounded search can work when one or both boundaries are missing', function () {\n      var avlt = new AVLTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        avlt.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(avlt.betweenBounds({ $gte: 11 }), ['data 13', 'data 15', 'data 18']);\n      assert.deepEqual(avlt.betweenBounds({ $lte: 9 }), ['data 3', 'data 5', 'data 8']);\n    });\n\n  });   /// ==== End of 'Search' ==== //\n\n\n  describe('Deletion', function () {\n\n    it('Deletion does nothing on an empty tree', function () {\n      var avlt = new AVLTree()\n        , avltu = new AVLTree({ unique: true });\n\n      avlt.getNumberOfKeys().should.equal(0);\n      avltu.getNumberOfKeys().should.equal(0);\n\n      avlt.delete(5);\n      avltu.delete(5);\n\n      avlt.tree.hasOwnProperty('key').should.equal(false);\n      avltu.tree.hasOwnProperty('key').should.equal(false);\n\n      avlt.tree.data.length.should.equal(0);\n      avltu.tree.data.length.should.equal(0);\n\n      avlt.getNumberOfKeys().should.equal(0);\n      avltu.getNumberOfKeys().should.equal(0);\n    });\n\n    it('Deleting a non-existent key doesnt have any effect', function () {\n      var avlt = new AVLTree();\n\n      [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n\n      function checkavlt () {\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n        });\n      }\n\n      checkavlt();\n      avlt.getNumberOfKeys().should.equal(7);\n\n      avlt.delete(2);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(4);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(9);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(6);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(11);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(14);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(20);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(200);\n      checkavlt(); avlt.checkIsAVLT(); avlt.getNumberOfKeys().should.equal(7);\n    });\n\n    it('Able to delete the root if it is also a leaf', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'hello');\n      avlt.tree.key.should.equal(10);\n      _.isEqual(avlt.tree.data, ['hello']).should.equal(true);\n      avlt.getNumberOfKeys().should.equal(1);\n\n      avlt.delete(10);\n      avlt.tree.hasOwnProperty('key').should.equal(false);\n      avlt.tree.data.length.should.equal(0);\n      avlt.getNumberOfKeys().should.equal(0);\n    });\n\n    it('Able to delete leaf nodes that are non-root', function () {\n      var avlt;\n\n      // This will create an AVL tree with leaves 3, 8, 12, 37\n      // (do a pretty print to see this)\n      function recreateavlt () {\n        avlt = new AVLTree();\n\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          avlt.insert(k, 'some ' + k);\n        });\n\n        avlt.getNumberOfKeys().should.equal(7);\n      }\n\n      // Check that only keys in array theRemoved were removed\n      function checkRemoved (theRemoved) {\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          if (theRemoved.indexOf(k) !== -1) {\n            avlt.search(k).length.should.equal(0);\n          } else {\n            _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n          }\n        });\n\n        avlt.getNumberOfKeys().should.equal(7 - theRemoved.length);\n      }\n\n      recreateavlt();\n      avlt.delete(3);\n      avlt.checkIsAVLT();\n      checkRemoved([3]);\n\n      recreateavlt();\n      avlt.delete(8);\n      avlt.checkIsAVLT();\n      checkRemoved([8]);\n\n      recreateavlt();\n      avlt.delete(12);\n      avlt.checkIsAVLT();\n      checkRemoved([12]);\n\n      // Delete all leaves in a way that makes the tree unbalanced\n      recreateavlt();\n      avlt.delete(37);\n      avlt.checkIsAVLT();\n      checkRemoved([37]);\n\n      avlt.delete(12);\n      avlt.checkIsAVLT();\n      checkRemoved([12, 37]);\n\n      avlt.delete(15);\n      avlt.checkIsAVLT();\n      checkRemoved([12, 15, 37]);\n\n      avlt.delete(3);\n      avlt.checkIsAVLT();\n      checkRemoved([3, 12, 15, 37]);\n\n      avlt.delete(5);\n      avlt.checkIsAVLT();\n      checkRemoved([3, 5, 12, 15, 37]);\n\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      checkRemoved([3, 5, 10, 12, 15, 37]);\n\n      avlt.delete(8);\n      avlt.checkIsAVLT();\n      checkRemoved([3, 5, 8, 10, 12, 15, 37]);\n    });\n\n    it('Able to delete the root if it has only one child', function () {\n      var avlt;\n\n      // Root has only one child, on the left\n      avlt = new AVLTree();\n      [10, 5].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(2);\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(1);\n      _.isEqual(avlt.search(5), ['some 5']).should.equal(true);\n      avlt.search(10).length.should.equal(0);\n\n      // Root has only one child, on the right\n      avlt = new AVLTree();\n      [10, 15].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(2);\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(1);\n      _.isEqual(avlt.search(15), ['some 15']).should.equal(true);\n      avlt.search(10).length.should.equal(0);\n    });\n\n    it('Able to delete non root nodes that have only one child', function () {\n      var avlt = new AVLTree()\n        , firstSet = [10, 5, 15, 3, 1, 4, 20]\n        , secondSet = [10, 5, 15, 3, 1, 4, 20, 17, 25]\n        ;\n\n      // Check that only keys in array theRemoved were removed\n      function checkRemoved (set, theRemoved) {\n        set.forEach(function (k) {\n          if (theRemoved.indexOf(k) !== -1) {\n            avlt.search(k).length.should.equal(0);\n          } else {\n            _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n          }\n        });\n\n        avlt.getNumberOfKeys().should.equal(set.length - theRemoved.length);\n      }\n\n      // First set: no rebalancing necessary\n      firstSet.forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n\n      avlt.getNumberOfKeys().should.equal(7);\n      avlt.checkIsAVLT();\n\n      avlt.delete(4);   // Leaf\n      avlt.checkIsAVLT();\n      checkRemoved(firstSet, [4]);\n\n      avlt.delete(3);   // Node with only one child (on the left)\n      avlt.checkIsAVLT();\n      checkRemoved(firstSet, [3, 4]);\n\n      avlt.delete(10);   // Leaf\n      avlt.checkIsAVLT();\n      checkRemoved(firstSet, [3, 4, 10]);\n\n      avlt.delete(15);   // Node with only one child (on the right)\n      avlt.checkIsAVLT();\n      checkRemoved(firstSet, [3, 4, 10, 15]);\n\n      // Second set: some rebalancing necessary\n      avlt = new AVLTree();\n      secondSet.forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n\n      avlt.delete(4);   // Leaf\n      avlt.checkIsAVLT();\n      checkRemoved(secondSet, [4]);\n\n      avlt.delete(3);   // Node with only one child (on the left), causes rebalancing\n      avlt.checkIsAVLT();\n      checkRemoved(secondSet, [3, 4]);\n    });\n\n    it('Can delete the root if it has 2 children', function () {\n      var avlt = new AVLTree();\n\n      // No rebalancing needed\n      [10, 5, 15, 3, 8, 12, 37].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(6);\n      [5, 3, 8, 15, 12, 37].forEach(function (k) {\n        _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n      });\n      avlt.search(10).length.should.equal(0);\n\n      // Rebalancing needed\n      avlt = new AVLTree();\n      [10, 5, 15, 8, 12, 37, 42].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(7);\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(6);\n      [5, 8, 15, 12, 37, 42].forEach(function (k) {\n        _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n      });\n      avlt.search(10).length.should.equal(0);\n    });\n\n    it('Can delete a non-root node that has two children', function () {\n      var avlt;\n\n      // On the left\n      avlt = new AVLTree();\n      [10, 5, 15, 3, 8, 12, 20, 1, 4, 6, 9, 11, 13, 19, 42, 3.5].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(16);\n      avlt.delete(5);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(15);\n      [10, 3, 1, 4, 8, 6, 9, 15, 12, 11, 13, 20, 19, 42, 3.5].forEach(function (k) {\n        _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n      });\n      avlt.search(5).length.should.equal(0);\n\n      // On the right\n      avlt = new AVLTree();\n      [10, 5, 15, 3, 8, 12, 20, 1, 4, 6, 9, 11, 13, 19, 42, 12.5].forEach(function (k) {\n        avlt.insert(k, 'some ' + k);\n      });\n      avlt.getNumberOfKeys().should.equal(16);\n      avlt.delete(15);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(15);\n      [10, 3, 1, 4, 8, 6, 9, 5, 12, 11, 13, 20, 19, 42, 12.5].forEach(function (k) {\n        _.isEqual(avlt.search(k), ['some ' + k]).should.equal(true);\n      });\n      avlt.search(15).length.should.equal(0);\n    });\n\n    it('If no value is provided, it will delete the entire node even if there are multiple pieces of data', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'yes');\n      avlt.insert(5, 'hello');\n      avlt.insert(3, 'yes');\n      avlt.insert(5, 'world');\n      avlt.insert(8, 'yes');\n\n      assert.deepEqual(avlt.search(5), ['hello', 'world']);\n      avlt.getNumberOfKeys().should.equal(4);\n\n      avlt.delete(5);\n      avlt.checkIsAVLT();\n      avlt.search(5).length.should.equal(0);\n      avlt.getNumberOfKeys().should.equal(3);\n    });\n\n    it('Can remove only one value from an array', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'yes');\n      avlt.insert(5, 'hello');\n      avlt.insert(3, 'yes');\n      avlt.insert(5, 'world');\n      avlt.insert(8, 'yes');\n\n      assert.deepEqual(avlt.search(5), ['hello', 'world']);\n      avlt.getNumberOfKeys().should.equal(4);\n\n      avlt.delete(5, 'hello');\n      avlt.checkIsAVLT();\n      assert.deepEqual(avlt.search(5), ['world']);\n      avlt.getNumberOfKeys().should.equal(4);\n    });\n\n    it('Removes nothing if value doesnt match', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'yes');\n      avlt.insert(5, 'hello');\n      avlt.insert(3, 'yes');\n      avlt.insert(5, 'world');\n      avlt.insert(8, 'yes');\n\n      assert.deepEqual(avlt.search(5), ['hello', 'world']);\n      avlt.getNumberOfKeys().should.equal(4);\n\n      avlt.delete(5, 'nope');\n      avlt.checkIsAVLT();\n      assert.deepEqual(avlt.search(5), ['hello', 'world']);\n      avlt.getNumberOfKeys().should.equal(4);\n    });\n\n    it('If value provided but node contains only one value, remove entire node', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'yes');\n      avlt.insert(5, 'hello');\n      avlt.insert(3, 'yes2');\n      avlt.insert(5, 'world');\n      avlt.insert(8, 'yes3');\n\n      assert.deepEqual(avlt.search(3), ['yes2']);\n      avlt.getNumberOfKeys().should.equal(4);\n\n      avlt.delete(3, 'yes2');\n      avlt.checkIsAVLT();\n      avlt.search(3).length.should.equal(0);\n      avlt.getNumberOfKeys().should.equal(3);\n    });\n\n    it('Can remove the root from a tree with height 2 when the root has two children (special case)', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'maybe');\n      avlt.insert(5, 'no');\n      avlt.insert(15, 'yes');\n      avlt.getNumberOfKeys().should.equal(3);\n\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(2);\n      assert.deepEqual(avlt.search(5), ['no']);\n      assert.deepEqual(avlt.search(15), ['yes']);\n    });\n\n    it('Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)', function () {\n      var avlt = new AVLTree();\n\n      avlt.insert(10, 'maybe');\n      avlt.insert(5, 'no');\n      avlt.insert(15, 'yes');\n      avlt.insert(2, 'no');\n      avlt.insert(35, 'yes');\n      avlt.getNumberOfKeys().should.equal(5);\n\n      avlt.delete(10);\n      avlt.checkIsAVLT();\n      avlt.getNumberOfKeys().should.equal(4);\n      assert.deepEqual(avlt.search(5), ['no']);\n      assert.deepEqual(avlt.search(15), ['yes']);\n    });\n\n  });   // ==== End of 'Deletion' ==== //\n\n\n  it('Can use undefined as key and value', function () {\n    function compareKeys (a, b) {\n      if (a === undefined && b === undefined) { return 0; }\n      if (a === undefined) { return -1; }\n      if (b === undefined) { return 1; }\n\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      if (a === b) { return 0; }\n    }\n\n    var avlt = new AVLTree({ compareKeys: compareKeys });\n\n    avlt.insert(2, undefined);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(undefined), []);\n\n    avlt.insert(undefined, 'hello');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(undefined), ['hello']);\n\n    avlt.insert(undefined, 'world');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(undefined), ['hello', 'world']);\n\n    avlt.insert(4, undefined);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(4), [undefined]);\n    assert.deepEqual(avlt.search(undefined), ['hello', 'world']);\n\n    avlt.delete(undefined, 'hello');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(4), [undefined]);\n    assert.deepEqual(avlt.search(undefined), ['world']);\n\n    avlt.delete(undefined);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [undefined]);\n    assert.deepEqual(avlt.search(4), [undefined]);\n    assert.deepEqual(avlt.search(undefined), []);\n\n    avlt.delete(2, undefined);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(avlt.search(2), []);\n    assert.deepEqual(avlt.search(4), [undefined]);\n    assert.deepEqual(avlt.search(undefined), []);\n\n    avlt.delete(4);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(0);\n    assert.deepEqual(avlt.search(2), []);\n    assert.deepEqual(avlt.search(4), []);\n    assert.deepEqual(avlt.search(undefined), []);\n  });\n\n\n  it('Can use null as key and value', function () {\n    function compareKeys (a, b) {\n      if (a === null && b === null) { return 0; }\n      if (a === null) { return -1; }\n      if (b === null) { return 1; }\n\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      if (a === b) { return 0; }\n    }\n\n    var avlt = new AVLTree({ compareKeys: compareKeys });\n\n    avlt.insert(2, null);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(null), []);\n\n    avlt.insert(null, 'hello');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(null), ['hello']);\n\n    avlt.insert(null, 'world');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(null), ['hello', 'world']);\n\n    avlt.insert(4, null);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(4), [null]);\n    assert.deepEqual(avlt.search(null), ['hello', 'world']);\n\n    avlt.delete(null, 'hello');\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(4), [null]);\n    assert.deepEqual(avlt.search(null), ['world']);\n\n    avlt.delete(null);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(avlt.search(2), [null]);\n    assert.deepEqual(avlt.search(4), [null]);\n    assert.deepEqual(avlt.search(null), []);\n\n    avlt.delete(2, null);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(avlt.search(2), []);\n    assert.deepEqual(avlt.search(4), [null]);\n    assert.deepEqual(avlt.search(null), []);\n\n    avlt.delete(4);\n    avlt.checkIsAVLT();\n    avlt.getNumberOfKeys().should.equal(0);\n    assert.deepEqual(avlt.search(2), []);\n    assert.deepEqual(avlt.search(4), []);\n    assert.deepEqual(avlt.search(null), []);\n  });\n\n\n  describe('Execute on every node (=tree traversal)', function () {\n\n    it('Can execute a function on every node', function () {\n      var avlt = new AVLTree()\n        , keys = []\n        , executed = 0\n        ;\n\n      avlt.insert(10, 'yes');\n      avlt.insert(5, 'hello');\n      avlt.insert(3, 'yes2');\n      avlt.insert(8, 'yes3');\n      avlt.insert(15, 'yes3');\n      avlt.insert(159, 'yes3');\n      avlt.insert(11, 'yes3');\n\n      avlt.executeOnEveryNode(function (node) {\n        keys.push(node.key);\n        executed += 1;\n      });\n\n      assert.deepEqual(keys, [3, 5, 8, 10, 11, 15, 159]);\n      executed.should.equal(7);\n    });\n\n  });   // ==== End of 'Execute on every node' ==== //\n\n\n  // This test performs several inserts and deletes at random, always checking the content\n  // of the tree are as expected and the binary search tree constraint is respected\n  // This test is important because it can catch bugs other tests can't\n  // By their nature, BSTs can be hard to test (many possible cases, bug at one operation whose\n  // effect begins to be felt only after several operations etc.)\n  describe('Randomized test (takes much longer than the rest of the test suite)', function () {\n    var avlt = new AVLTree()\n      , data = {};\n\n    // Check a avlt against a simple key => [data] object\n    function checkDataIsTheSame (avlt, data) {\n      var avltDataElems = [];\n\n      // avltDataElems is a simple array containing every piece of data in the tree\n      avlt.executeOnEveryNode(function (node) {\n        var i;\n        for (i = 0; i < node.data.length; i += 1) {\n          avltDataElems.push(node.data[i]);\n        }\n      });\n\n      // Number of key and number of pieces of data match\n      avlt.getNumberOfKeys().should.equal(Object.keys(data).length);\n      _.reduce(_.map(data, function (d) { return d.length; }), function (memo, n) { return memo + n; }, 0).should.equal(avltDataElems.length);\n\n      // Compare data\n      Object.keys(data).forEach(function (key) {\n        checkDataEquality(avlt.search(key), data[key]);\n      });\n    }\n\n    // Check two pieces of data coming from the avlt and data are the same\n    function checkDataEquality (fromavlt, fromData) {\n      if (fromavlt.length === 0) {\n        if (fromData) { fromData.length.should.equal(0); }\n      }\n\n      assert.deepEqual(fromavlt, fromData);\n    }\n\n    // Tests the tree structure (deletions concern the whole tree, deletion of some data in a node is well tested above)\n    it('Inserting and deleting entire nodes', function () {\n      // You can skew to be more insertive or deletive, to test all cases\n      function launchRandomTest (nTests, proba) {\n        var i, key, dataPiece, possibleKeys;\n\n        for (i = 0; i < nTests; i += 1) {\n          if (Math.random() > proba) {   // Deletion\n            possibleKeys = Object.keys(data);\n\n            if (possibleKeys.length > 0) {\n              key = possibleKeys[Math.floor(possibleKeys.length * Math.random()).toString()];\n            } else {\n              key = Math.floor(70 * Math.random()).toString();\n            }\n\n            delete data[key];\n            avlt.delete(key);\n          } else {   // Insertion\n            key = Math.floor(70 * Math.random()).toString();\n            dataPiece = Math.random().toString().substring(0, 6);\n\n            avlt.insert(key, dataPiece);\n            if (data[key]) {\n              data[key].push(dataPiece);\n            } else {\n              data[key] = [dataPiece];\n            }\n          }\n\n          // Check the avlt constraint are still met and the data is correct\n          avlt.checkIsAVLT();\n          checkDataIsTheSame(avlt, data);\n        }\n      }\n\n      launchRandomTest(1000, 0.65);\n      launchRandomTest(2000, 0.35);\n    });\n\n  });   // ==== End of 'Randomized test' ==== //\n\n});\n\n\n\n\n\n\n\n\n\n","var should = require('chai').should()\n  , assert = require('chai').assert\n  , BinarySearchTree = require('../index').BinarySearchTree\n  , _ = require('underscore')\n  , customUtils = require('../lib/customUtils')\n  ;\n\n\ndescribe('Binary search tree', function () {\n\n  it('Upon creation, left, right are null, key and data can be set', function () {\n    var bst = new BinarySearchTree();\n    assert.isNull(bst.left);\n    assert.isNull(bst.right);\n    bst.hasOwnProperty('key').should.equal(false);\n    bst.data.length.should.equal(0);\n\n    bst = new BinarySearchTree({ key: 6, value: 'ggg' });\n    assert.isNull(bst.left);\n    assert.isNull(bst.right);\n    bst.key.should.equal(6);\n    bst.data.length.should.equal(1);\n    bst.data[0].should.equal('ggg');\n  });\n\n  describe('Sanity checks', function () {\n\n    it('Can get maxkey and minkey descendants', function () {\n      var t = new BinarySearchTree({ key: 10 })\n        , l = new BinarySearchTree({ key: 5 })\n        , r = new BinarySearchTree({ key: 15 })\n        , ll = new BinarySearchTree({ key: 3 })\n        , lr = new BinarySearchTree({ key: 8 })\n        , rl = new BinarySearchTree({ key: 11 })\n        , rr = new BinarySearchTree({ key: 42 })\n        ;\n\n      t.left = l; t.right = r;\n      l.left = ll; l.right = lr;\n      r.left = rl; r.right = rr;\n\n      // Getting min and max key descendants\n      t.getMinKeyDescendant().key.should.equal(3);\n      t.getMaxKeyDescendant().key.should.equal(42);\n\n      t.left.getMinKeyDescendant().key.should.equal(3);\n      t.left.getMaxKeyDescendant().key.should.equal(8);\n\n      t.right.getMinKeyDescendant().key.should.equal(11);\n      t.right.getMaxKeyDescendant().key.should.equal(42);\n\n      t.right.left.getMinKeyDescendant().key.should.equal(11);\n      t.right.left.getMaxKeyDescendant().key.should.equal(11);\n\n      // Getting min and max keys\n      t.getMinKey().should.equal(3);\n      t.getMaxKey().should.equal(42);\n\n      t.left.getMinKey().should.equal(3);\n      t.left.getMaxKey().should.equal(8);\n\n      t.right.getMinKey().should.equal(11);\n      t.right.getMaxKey().should.equal(42);\n\n      t.right.left.getMinKey().should.equal(11);\n      t.right.left.getMaxKey().should.equal(11);\n    });\n\n    it('Can check a condition against every node in a tree', function () {\n      var t = new BinarySearchTree({ key: 10 })\n        , l = new BinarySearchTree({ key: 6 })\n        , r = new BinarySearchTree({ key: 16 })\n        , ll = new BinarySearchTree({ key: 4 })\n        , lr = new BinarySearchTree({ key: 8 })\n        , rl = new BinarySearchTree({ key: 12 })\n        , rr = new BinarySearchTree({ key: 42 })\n        ;\n\n      t.left = l; t.right = r;\n      l.left = ll; l.right = lr;\n      r.left = rl; r.right = rr;\n\n      function test (k, v) { if (k % 2 !== 0) { throw 'Key is not even'; } }\n\n      t.checkAllNodesFullfillCondition(test);\n\n      [l, r, ll, lr, rl, rr].forEach(function (node) {\n        node.key += 1;\n        (function () { t.checkAllNodesFullfillCondition(test); }).should.throw();\n        node.key -= 1;\n      });\n\n      t.checkAllNodesFullfillCondition(test);\n    });\n\n    it('Can check that a tree verifies node ordering', function () {\n      var t = new BinarySearchTree({ key: 10 })\n        , l = new BinarySearchTree({ key: 5 })\n        , r = new BinarySearchTree({ key: 15 })\n        , ll = new BinarySearchTree({ key: 3 })\n        , lr = new BinarySearchTree({ key: 8 })\n        , rl = new BinarySearchTree({ key: 11 })\n        , rr = new BinarySearchTree({ key: 42 })\n        ;\n\n      t.left = l; t.right = r;\n      l.left = ll; l.right = lr;\n      r.left = rl; r.right = rr;\n\n      t.checkNodeOrdering();\n\n      // Let's be paranoid and check all cases...\n      l.key = 12;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      l.key = 5;\n\n      r.key = 9;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      r.key = 15;\n\n      ll.key = 6;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      ll.key = 11;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      ll.key = 3;\n\n      lr.key = 4;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      lr.key = 11;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      lr.key = 8;\n\n      rl.key = 16;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      rl.key = 9;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      rl.key = 11;\n\n      rr.key = 12;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      rr.key = 7;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      rr.key = 10.5;\n      (function () { t.checkNodeOrdering(); }).should.throw();\n      rr.key = 42;\n\n      t.checkNodeOrdering();\n    });\n\n    it('Checking if a tree\\'s internal pointers (i.e. parents) are correct', function () {\n      var t = new BinarySearchTree({ key: 10 })\n        , l = new BinarySearchTree({ key: 5 })\n        , r = new BinarySearchTree({ key: 15 })\n        , ll = new BinarySearchTree({ key: 3 })\n        , lr = new BinarySearchTree({ key: 8 })\n        , rl = new BinarySearchTree({ key: 11 })\n        , rr = new BinarySearchTree({ key: 42 })\n        ;\n\n      t.left = l; t.right = r;\n      l.left = ll; l.right = lr;\n      r.left = rl; r.right = rr;\n\n      (function () { t.checkInternalPointers(); }).should.throw();\n      l.parent = t;\n      (function () { t.checkInternalPointers(); }).should.throw();\n      r.parent = t;\n      (function () { t.checkInternalPointers(); }).should.throw();\n      ll.parent = l;\n      (function () { t.checkInternalPointers(); }).should.throw();\n      lr.parent = l;\n      (function () { t.checkInternalPointers(); }).should.throw();\n      rl.parent = r;\n      (function () { t.checkInternalPointers(); }).should.throw();\n      rr.parent = r;\n\n      t.checkInternalPointers();\n    });\n\n    it('Can get the number of inserted keys', function () {\n      var bst = new BinarySearchTree();\n\n      bst.getNumberOfKeys().should.equal(0);\n      bst.insert(10);\n      bst.getNumberOfKeys().should.equal(1);\n      bst.insert(5);\n      bst.getNumberOfKeys().should.equal(2);\n      bst.insert(3);\n      bst.getNumberOfKeys().should.equal(3);\n      bst.insert(8);\n      bst.getNumberOfKeys().should.equal(4);\n      bst.insert(15);\n      bst.getNumberOfKeys().should.equal(5);\n      bst.insert(12);\n      bst.getNumberOfKeys().should.equal(6);\n      bst.insert(37);\n      bst.getNumberOfKeys().should.equal(7);\n    });\n\n  });\n\n  describe('Insertion', function () {\n\n    it('Insert at the root if its the first insertion', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n\n      bst.checkIsBST();\n      bst.key.should.equal(10);\n      _.isEqual(bst.data, ['some data']).should.equal(true);\n      assert.isNull(bst.left);\n      assert.isNull(bst.right);\n    });\n\n    it(\"Insert on the left if key is less than the root's\", function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n      bst.insert(7, 'some other data');\n\n      bst.checkIsBST();\n      assert.isNull(bst.right);\n      bst.left.key.should.equal(7);\n      _.isEqual(bst.left.data, ['some other data']).should.equal(true);\n      assert.isNull(bst.left.left);\n      assert.isNull(bst.left.right);\n    });\n\n    it(\"Insert on the right if key is greater than the root's\", function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n      bst.insert(14, 'some other data');\n\n      bst.checkIsBST();\n      assert.isNull(bst.left);\n      bst.right.key.should.equal(14);\n      _.isEqual(bst.right.data, ['some other data']).should.equal(true);\n      assert.isNull(bst.right.left);\n      assert.isNull(bst.right.right);\n    });\n\n    it(\"Recursive insertion on the left works\", function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n      bst.insert(7, 'some other data');\n      bst.insert(1, 'hello');\n      bst.insert(9, 'world');\n\n      bst.checkIsBST();\n      assert.isNull(bst.right);\n      bst.left.key.should.equal(7);\n      _.isEqual(bst.left.data, ['some other data']).should.equal(true);\n\n      bst.left.left.key.should.equal(1);\n      _.isEqual(bst.left.left.data, ['hello']).should.equal(true);\n\n      bst.left.right.key.should.equal(9);\n      _.isEqual(bst.left.right.data, ['world']).should.equal(true);\n    });\n\n    it(\"Recursive insertion on the right works\", function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n      bst.insert(17, 'some other data');\n      bst.insert(11, 'hello');\n      bst.insert(19, 'world');\n\n      bst.checkIsBST();\n      assert.isNull(bst.left);\n      bst.right.key.should.equal(17);\n      _.isEqual(bst.right.data, ['some other data']).should.equal(true);\n\n      bst.right.left.key.should.equal(11);\n      _.isEqual(bst.right.left.data, ['hello']).should.equal(true);\n\n      bst.right.right.key.should.equal(19);\n      _.isEqual(bst.right.right.data, ['world']).should.equal(true);\n    });\n\n    it('If uniqueness constraint not enforced, we can insert different data for same key', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'some data');\n      bst.insert(3, 'hello');\n      bst.insert(3, 'world');\n\n      bst.checkIsBST();\n      bst.left.key.should.equal(3);\n      _.isEqual(bst.left.data, ['hello', 'world']).should.equal(true);\n\n      bst.insert(12, 'a');\n      bst.insert(12, 'b');\n\n      bst.checkIsBST();\n      bst.right.key.should.equal(12);\n      _.isEqual(bst.right.data, ['a', 'b']).should.equal(true);\n    });\n\n    it('If uniqueness constraint is enforced, we cannot insert different data for same key', function () {\n      var bst = new BinarySearchTree({ unique: true });\n\n      bst.insert(10, 'some data');\n      bst.insert(3, 'hello');\n      try {\n        bst.insert(3, 'world');\n      } catch (e) {\n        e.errorType.should.equal('uniqueViolated');\n        e.key.should.equal(3);\n      }\n\n      bst.checkIsBST();\n      bst.left.key.should.equal(3);\n      _.isEqual(bst.left.data, ['hello']).should.equal(true);\n\n      bst.insert(12, 'a');\n      try {\n        bst.insert(12, 'world');\n      } catch (e) {\n        e.errorType.should.equal('uniqueViolated');\n        e.key.should.equal(12);\n      }\n\n      bst.checkIsBST();\n      bst.right.key.should.equal(12);\n      _.isEqual(bst.right.data, ['a']).should.equal(true);\n    });\n\n    it('Can insert 0 or the empty string', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(0, 'some data');\n\n      bst.checkIsBST();\n      bst.key.should.equal(0);\n      _.isEqual(bst.data, ['some data']).should.equal(true);\n      assert.isNull(bst.left);\n      assert.isNull(bst.right);\n\n      bst = new BinarySearchTree();\n\n      bst.insert('', 'some other data');\n\n      bst.checkIsBST();\n      bst.key.should.equal('');\n      _.isEqual(bst.data, ['some other data']).should.equal(true);\n      assert.isNull(bst.left);\n      assert.isNull(bst.right);\n    });\n\n    it('Can insert a lot of keys and still get a BST (sanity check)', function () {\n      var bst = new BinarySearchTree({ unique: true });\n\n      customUtils.getRandomArray(100).forEach(function (n) {\n        bst.insert(n, 'some data');\n      });\n\n      bst.checkIsBST();\n    });\n\n    it('All children get a pointer to their parent, the root doesnt', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'root');\n      bst.insert(5, 'yes');\n      bst.insert(15, 'no');\n\n      bst.checkIsBST();\n\n      assert.isNull(bst.parent);\n      bst.left.parent.should.equal(bst);\n      bst.right.parent.should.equal(bst);\n    });\n\n  });   // ==== End of 'Insertion' ==== //\n\n\n  describe('Search', function () {\n\n    it('Can find data in a BST', function () {\n      var bst = new BinarySearchTree()\n        , i;\n\n      customUtils.getRandomArray(100).forEach(function (n) {\n        bst.insert(n, 'some data for ' + n);\n      });\n\n      bst.checkIsBST();\n\n      for (i = 0; i < 100; i += 1) {\n        _.isEqual(bst.search(i), ['some data for ' + i]).should.equal(true);\n      }\n    });\n\n    it('If no data can be found, return an empty array', function () {\n      var bst = new BinarySearchTree();\n\n      customUtils.getRandomArray(100).forEach(function (n) {\n        if (n !== 63) {\n          bst.insert(n, 'some data for ' + n);\n        }\n      });\n\n      bst.checkIsBST();\n\n      bst.search(-2).length.should.equal(0);\n      bst.search(100).length.should.equal(0);\n      bst.search(101).length.should.equal(0);\n      bst.search(63).length.should.equal(0);\n    });\n\n    it('Can search for data between two bounds', function () {\n      var bst = new BinarySearchTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        bst.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(bst.betweenBounds({ $gte: 8, $lte: 15 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n      assert.deepEqual(bst.betweenBounds({ $gt: 8, $lt: 15 }), ['data 10', 'data 13']);\n    });\n\n    it('Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte', function () {\n      var bst = new BinarySearchTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        bst.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(bst.betweenBounds({ $gt:8, $gte: 8, $lte: 15 }), ['data 10', 'data 13', 'data 15']);\n      assert.deepEqual(bst.betweenBounds({ $gt:5, $gte: 8, $lte: 15 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n      assert.deepEqual(bst.betweenBounds({ $gt:8, $gte: 5, $lte: 15 }), ['data 10', 'data 13', 'data 15']);\n\n      assert.deepEqual(bst.betweenBounds({ $gte: 8, $lte: 15, $lt: 15 }), ['data 8', 'data 10', 'data 13']);\n      assert.deepEqual(bst.betweenBounds({ $gte: 8, $lte: 18, $lt: 15 }), ['data 8', 'data 10', 'data 13']);\n      assert.deepEqual(bst.betweenBounds({ $gte: 8, $lte: 15, $lt: 18 }), ['data 8', 'data 10', 'data 13', 'data 15']);\n    });\n\n    it('Bounded search can work when one or both boundaries are missing', function () {\n      var bst = new BinarySearchTree();\n\n      [10, 5, 15, 3, 8, 13, 18].forEach(function (k) {\n        bst.insert(k, 'data ' + k);\n      });\n\n      assert.deepEqual(bst.betweenBounds({ $gte: 11 }), ['data 13', 'data 15', 'data 18']);\n      assert.deepEqual(bst.betweenBounds({ $lte: 9 }), ['data 3', 'data 5', 'data 8']);\n    });\n\n  });   /// ==== End of 'Search' ==== //\n\n\n  describe('Deletion', function () {\n\n    it('Deletion does nothing on an empty tree', function () {\n      var bst = new BinarySearchTree()\n        , bstu = new BinarySearchTree({ unique: true });\n\n      bst.getNumberOfKeys().should.equal(0);\n      bstu.getNumberOfKeys().should.equal(0);\n\n      bst.delete(5);\n      bstu.delete(5);\n\n      bst.hasOwnProperty('key').should.equal(false);\n      bstu.hasOwnProperty('key').should.equal(false);\n\n      bst.data.length.should.equal(0);\n      bstu.data.length.should.equal(0);\n\n      bst.getNumberOfKeys().should.equal(0);\n      bstu.getNumberOfKeys().should.equal(0);\n    });\n\n    it('Deleting a non-existent key doesnt have any effect', function () {\n      var bst = new BinarySearchTree();\n\n      [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n\n      function checkBst () {\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n        });\n      }\n\n      checkBst();\n      bst.getNumberOfKeys().should.equal(7);\n\n      bst.delete(2);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(4);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(9);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(6);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(11);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(14);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(20);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n      bst.delete(200);\n      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(7);\n    });\n\n    it('Able to delete the root if it is also a leaf', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'hello');\n      bst.key.should.equal(10);\n      _.isEqual(bst.data, ['hello']).should.equal(true);\n      bst.getNumberOfKeys().should.equal(1);\n\n      bst.delete(10);\n      bst.hasOwnProperty('key').should.equal(false);\n      bst.data.length.should.equal(0);\n      bst.getNumberOfKeys().should.equal(0);\n    });\n\n    it('Able to delete leaf nodes that are non-root', function () {\n      var bst;\n\n      function recreateBst () {\n        bst = new BinarySearchTree();\n\n        // With this insertion order the tree is well balanced\n        // So we know the leaves are 3, 8, 12, 37\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          bst.insert(k, 'some ' + k);\n        });\n\n        bst.getNumberOfKeys().should.equal(7);\n      }\n\n      function checkOnlyOneWasRemoved (theRemoved) {\n        [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n          if (k === theRemoved) {\n            bst.search(k).length.should.equal(0);\n          } else {\n            _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n          }\n        });\n\n        bst.getNumberOfKeys().should.equal(6);\n      }\n\n      recreateBst();\n      bst.delete(3);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(3);\n      assert.isNull(bst.left.left);\n\n      recreateBst();\n      bst.delete(8);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(8);\n      assert.isNull(bst.left.right);\n\n      recreateBst();\n      bst.delete(12);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(12);\n      assert.isNull(bst.right.left);\n\n      recreateBst();\n      bst.delete(37);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(37);\n      assert.isNull(bst.right.right);\n    });\n\n    it('Able to delete the root if it has only one child', function () {\n      var bst;\n\n      // Root has only one child, on the left\n      bst = new BinarySearchTree();\n      [10, 5, 3, 6].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n      bst.getNumberOfKeys().should.equal(4);\n      bst.delete(10);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(3);\n      [5, 3, 6].forEach(function (k) {\n        _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n      });\n      bst.search(10).length.should.equal(0);\n\n      // Root has only one child, on the right\n      bst = new BinarySearchTree();\n      [10, 15, 13, 16].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n      bst.getNumberOfKeys().should.equal(4);\n      bst.delete(10);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(3);\n      [15, 13, 16].forEach(function (k) {\n        _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n      });\n      bst.search(10).length.should.equal(0);\n    });\n\n    it('Able to delete non root nodes that have only one child', function () {\n      var bst;\n\n      function recreateBst () {\n        bst = new BinarySearchTree();\n\n        [10, 5, 15, 3, 1, 4, 20, 17, 25].forEach(function (k) {\n          bst.insert(k, 'some ' + k);\n        });\n\n        bst.getNumberOfKeys().should.equal(9);\n      }\n\n      function checkOnlyOneWasRemoved (theRemoved) {\n        [10, 5, 15, 3, 1, 4, 20, 17, 25].forEach(function (k) {\n          if (k === theRemoved) {\n            bst.search(k).length.should.equal(0);\n          } else {\n            _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n          }\n        });\n\n        bst.getNumberOfKeys().should.equal(8);\n      }\n\n      recreateBst();\n      bst.delete(5);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(5);\n\n      recreateBst();\n      bst.delete(15);\n      bst.checkIsBST();\n      checkOnlyOneWasRemoved(15);\n    });\n\n    it('Can delete the root if it has 2 children', function () {\n      var bst;\n\n      bst = new BinarySearchTree();\n      [10, 5, 3, 8, 15, 12, 37].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n      bst.getNumberOfKeys().should.equal(7);\n      bst.delete(10);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(6);\n      [5, 3, 8, 15, 12, 37].forEach(function (k) {\n        _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n      });\n      bst.search(10).length.should.equal(0);\n    });\n\n    it('Can delete a non-root node that has two children', function () {\n      var bst;\n\n      bst = new BinarySearchTree();\n      [10, 5, 3, 1, 4, 8, 6, 9, 15, 12, 11, 13, 20, 19, 42].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n      bst.getNumberOfKeys().should.equal(15);\n      bst.delete(5);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(14);\n      [10, 3, 1, 4, 8, 6, 9, 15, 12, 11, 13, 20, 19, 42].forEach(function (k) {\n        _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n      });\n      bst.search(5).length.should.equal(0);\n\n      bst = new BinarySearchTree();\n      [10, 5, 3, 1, 4, 8, 6, 9, 15, 12, 11, 13, 20, 19, 42].forEach(function (k) {\n        bst.insert(k, 'some ' + k);\n      });\n      bst.getNumberOfKeys().should.equal(15);\n      bst.delete(15);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(14);\n      [10, 5, 3, 1, 4, 8, 6, 9, 12, 11, 13, 20, 19, 42].forEach(function (k) {\n        _.isEqual(bst.search(k), ['some ' + k]).should.equal(true);\n      });\n      bst.search(15).length.should.equal(0);\n    });\n\n    it('If no value is provided, it will delete the entire node even if there are multiple pieces of data', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'yes');\n      bst.insert(5, 'hello');\n      bst.insert(3, 'yes');\n      bst.insert(5, 'world');\n      bst.insert(8, 'yes');\n\n      assert.deepEqual(bst.search(5), ['hello', 'world']);\n      bst.getNumberOfKeys().should.equal(4);\n\n      bst.delete(5);\n      bst.search(5).length.should.equal(0);\n      bst.getNumberOfKeys().should.equal(3);\n    });\n\n    it('Can remove only one value from an array', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'yes');\n      bst.insert(5, 'hello');\n      bst.insert(3, 'yes');\n      bst.insert(5, 'world');\n      bst.insert(8, 'yes');\n\n      assert.deepEqual(bst.search(5), ['hello', 'world']);\n      bst.getNumberOfKeys().should.equal(4);\n\n      bst.delete(5, 'hello');\n      assert.deepEqual(bst.search(5), ['world']);\n      bst.getNumberOfKeys().should.equal(4);\n    });\n\n    it('Removes nothing if value doesnt match', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'yes');\n      bst.insert(5, 'hello');\n      bst.insert(3, 'yes');\n      bst.insert(5, 'world');\n      bst.insert(8, 'yes');\n\n      assert.deepEqual(bst.search(5), ['hello', 'world']);\n      bst.getNumberOfKeys().should.equal(4);\n\n      bst.delete(5, 'nope');\n      assert.deepEqual(bst.search(5), ['hello', 'world']);\n      bst.getNumberOfKeys().should.equal(4);\n    });\n\n    it('If value provided but node contains only one value, remove entire node', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'yes');\n      bst.insert(5, 'hello');\n      bst.insert(3, 'yes2');\n      bst.insert(5, 'world');\n      bst.insert(8, 'yes3');\n\n      assert.deepEqual(bst.search(3), ['yes2']);\n      bst.getNumberOfKeys().should.equal(4);\n\n      bst.delete(3, 'yes2');\n      bst.search(3).length.should.equal(0);\n      bst.getNumberOfKeys().should.equal(3);\n    });\n\n    it('Can remove the root from a tree with height 2 when the root has two children (special case)', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'maybe');\n      bst.insert(5, 'no');\n      bst.insert(15, 'yes');\n      bst.getNumberOfKeys().should.equal(3);\n\n      bst.delete(10);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(2);\n      assert.deepEqual(bst.search(5), ['no']);\n      assert.deepEqual(bst.search(15), ['yes']);\n    });\n\n    it('Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)', function () {\n      var bst = new BinarySearchTree();\n\n      bst.insert(10, 'maybe');\n      bst.insert(5, 'no');\n      bst.insert(15, 'yes');\n      bst.insert(2, 'no');\n      bst.insert(35, 'yes');\n      bst.getNumberOfKeys().should.equal(5);\n\n      bst.delete(10);\n      bst.checkIsBST();\n      bst.getNumberOfKeys().should.equal(4);\n      assert.deepEqual(bst.search(5), ['no']);\n      assert.deepEqual(bst.search(15), ['yes']);\n    });\n\n  });   // ==== End of 'Deletion' ==== //\n\n\n  it('Can use undefined as key and value', function () {\n    function compareKeys (a, b) {\n      if (a === undefined && b === undefined) { return 0; }\n      if (a === undefined) { return -1; }\n      if (b === undefined) { return 1; }\n\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      if (a === b) { return 0; }\n    }\n\n    var bst = new BinarySearchTree({ compareKeys: compareKeys });\n\n    bst.insert(2, undefined);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(undefined), []);\n\n    bst.insert(undefined, 'hello');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(undefined), ['hello']);\n\n    bst.insert(undefined, 'world');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(undefined), ['hello', 'world']);\n\n    bst.insert(4, undefined);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(4), [undefined]);\n    assert.deepEqual(bst.search(undefined), ['hello', 'world']);\n\n    bst.delete(undefined, 'hello');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(4), [undefined]);\n    assert.deepEqual(bst.search(undefined), ['world']);\n\n    bst.delete(undefined);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [undefined]);\n    assert.deepEqual(bst.search(4), [undefined]);\n    assert.deepEqual(bst.search(undefined), []);\n\n    bst.delete(2, undefined);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(bst.search(2), []);\n    assert.deepEqual(bst.search(4), [undefined]);\n    assert.deepEqual(bst.search(undefined), []);\n\n    bst.delete(4);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(0);\n    assert.deepEqual(bst.search(2), []);\n    assert.deepEqual(bst.search(4), []);\n    assert.deepEqual(bst.search(undefined), []);\n  });\n\n\n  it('Can use null as key and value', function () {\n    function compareKeys (a, b) {\n      if (a === null && b === null) { return 0; }\n      if (a === null) { return -1; }\n      if (b === null) { return 1; }\n\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      if (a === b) { return 0; }\n    }\n\n    var bst = new BinarySearchTree({ compareKeys: compareKeys });\n\n    bst.insert(2, null);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(null), []);\n\n    bst.insert(null, 'hello');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(null), ['hello']);\n\n    bst.insert(null, 'world');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(null), ['hello', 'world']);\n\n    bst.insert(4, null);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(4), [null]);\n    assert.deepEqual(bst.search(null), ['hello', 'world']);\n\n    bst.delete(null, 'hello');\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(3);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(4), [null]);\n    assert.deepEqual(bst.search(null), ['world']);\n\n    bst.delete(null);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(2);\n    assert.deepEqual(bst.search(2), [null]);\n    assert.deepEqual(bst.search(4), [null]);\n    assert.deepEqual(bst.search(null), []);\n\n    bst.delete(2, null);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(1);\n    assert.deepEqual(bst.search(2), []);\n    assert.deepEqual(bst.search(4), [null]);\n    assert.deepEqual(bst.search(null), []);\n\n    bst.delete(4);\n    bst.checkIsBST();\n    bst.getNumberOfKeys().should.equal(0);\n    assert.deepEqual(bst.search(2), []);\n    assert.deepEqual(bst.search(4), []);\n    assert.deepEqual(bst.search(null), []);\n  });\n\n\n  describe('Execute on every node (=tree traversal)', function () {\n\n    it('Can execute a function on every node', function () {\n      var bst = new BinarySearchTree()\n        , keys = []\n        , executed = 0\n        ;\n\n      bst.insert(10, 'yes');\n      bst.insert(5, 'hello');\n      bst.insert(3, 'yes2');\n      bst.insert(8, 'yes3');\n      bst.insert(15, 'yes3');\n      bst.insert(159, 'yes3');\n      bst.insert(11, 'yes3');\n\n      bst.executeOnEveryNode(function (node) {\n        keys.push(node.key);\n        executed += 1;\n      });\n\n      assert.deepEqual(keys, [3, 5, 8, 10, 11, 15, 159]);\n      executed.should.equal(7);\n    });\n\n  });   // ==== End of 'Execute on every node' ==== //\n\n\n  // This test performs several inserts and deletes at random, always checking the content\n  // of the tree are as expected and the binary search tree constraint is respected\n  // This test is important because it can catch bugs other tests can't\n  // By their nature, BSTs can be hard to test (many possible cases, bug at one operation whose\n  // effect begins to be felt only after several operations etc.)\n  describe('Randomized test (takes much longer than the rest of the test suite)', function () {\n    var bst = new BinarySearchTree()\n      , data = {};\n\n    // Check a bst against a simple key => [data] object\n    function checkDataIsTheSame (bst, data) {\n      var bstDataElems = [];\n\n      // bstDataElems is a simple array containing every piece of data in the tree\n      bst.executeOnEveryNode(function (node) {\n        var i;\n        for (i = 0; i < node.data.length; i += 1) {\n          bstDataElems.push(node.data[i]);\n        }\n      });\n\n      // Number of key and number of pieces of data match\n      bst.getNumberOfKeys().should.equal(Object.keys(data).length);\n      _.reduce(_.map(data, function (d) { return d.length; }), function (memo, n) { return memo + n; }, 0).should.equal(bstDataElems.length);\n\n      // Compare data\n      Object.keys(data).forEach(function (key) {\n        checkDataEquality(bst.search(key), data[key]);\n      });\n    }\n\n    // Check two pieces of data coming from the bst and data are the same\n    function checkDataEquality (fromBst, fromData) {\n      if (fromBst.length === 0) {\n        if (fromData) { fromData.length.should.equal(0); }\n      }\n\n      assert.deepEqual(fromBst, fromData);\n    }\n\n    // Tests the tree structure (deletions concern the whole tree, deletion of some data in a node is well tested above)\n    it('Inserting and deleting entire nodes', function () {\n      // You can skew to be more insertive or deletive, to test all cases\n      function launchRandomTest (nTests, proba) {\n        var i, key, dataPiece, possibleKeys;\n\n        for (i = 0; i < nTests; i += 1) {\n          if (Math.random() > proba) {   // Deletion\n            possibleKeys = Object.keys(data);\n\n            if (possibleKeys.length > 0) {\n              key = possibleKeys[Math.floor(possibleKeys.length * Math.random()).toString()];\n            } else {\n              key = Math.floor(70 * Math.random()).toString();\n            }\n\n            delete data[key];\n            bst.delete(key);\n          } else {   // Insertion\n            key = Math.floor(70 * Math.random()).toString();\n            dataPiece = Math.random().toString().substring(0, 6);\n            bst.insert(key, dataPiece);\n            if (data[key]) {\n              data[key].push(dataPiece);\n            } else {\n              data[key] = [dataPiece];\n            }\n          }\n\n          // Check the bst constraint are still met and the data is correct\n          bst.checkIsBST();\n          checkDataIsTheSame(bst, data);\n        }\n      }\n\n      launchRandomTest(1000, 0.65);\n      launchRandomTest(2000, 0.35);\n    });\n\n  });   // ==== End of 'Randomized test' ==== //\n\n\n\n});\n","var mkdirp = require('mkdirp');\n\nmkdirp('/tmp/foo/bar/baz', function (err) {\n    if (err) console.error(err)\n    else console.log('pow!')\n});\n","var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\ntest('chmod-pre', function (t) {\n    var mode = 0744\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.equal(stat && stat.mode & 0777, mode, 'should be 0744');\n            t.end();\n        });\n    });\n});\n\ntest('chmod', function (t) {\n    var mode = 0755\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.end();\n        });\n    });\n});\n","var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\n// a file in the way\nvar itw = ps.slice(0, 3).join('/');\n\n\ntest('clobber-pre', function (t) {\n    console.error(\"about to write to \"+itw)\n    fs.writeFileSync(itw, 'I AM IN THE WAY, THE TRUTH, AND THE LIGHT.');\n\n    fs.stat(itw, function (er, stat) {\n        t.ifError(er)\n        t.ok(stat && stat.isFile(), 'should be file')\n        t.end()\n    })\n})\n\ntest('clobber', function (t) {\n    t.plan(2);\n    mkdirp(file, 0755, function (err) {\n        t.ok(err);\n        t.equal(err.code, 'ENOTDIR');\n        t.end();\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('woo', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('async perm', function (t) {\n    t.plan(2);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16);\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n\ntest('async root perm', function (t) {\n    mkdirp('/tmp', 0755, function (err) {\n        if (err) t.fail(err);\n        t.end();\n    });\n    t.end();\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('sync perm', function (t) {\n    t.plan(2);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16) + '.json';\n    \n    mkdirp.sync(file, 0755);\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    });\n});\n\ntest('sync root perm', function (t) {\n    t.plan(1);\n    \n    var file = '/tmp';\n    mkdirp.sync(file, 0755);\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    });\n});\n","var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('race', function (t) {\n    t.plan(4);\n    var ps = [ '', 'tmp' ];\n    \n    for (var i = 0; i < 25; i++) {\n        var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n        ps.push(dir);\n    }\n    var file = ps.join('/');\n    \n    var res = 2;\n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    function mk (file, cb) {\n        mkdirp(file, 0755, function (err) {\n            if (err) t.fail(err);\n            else path.exists(file, function (ex) {\n                if (!ex) t.fail('file not created')\n                else fs.stat(file, function (err, stat) {\n                    if (err) t.fail(err)\n                    else {\n                        t.equal(stat.mode & 0777, 0755);\n                        t.ok(stat.isDirectory(), 'target not a directory');\n                        if (cb) cb();\n                    }\n                })\n            })\n        });\n    }\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('rel', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var cwd = process.cwd();\n    process.chdir('/tmp');\n    \n    var file = [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    process.chdir(cwd);\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('return value', function (t) {\n    t.plan(4);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    // should return the first dir created.\n    // By this point, it would be profoundly surprising if /tmp didn't\n    // already exist, since every other test makes things in there.\n    mkdirp(file, function (err, made) {\n        t.ifError(err);\n        t.equal(made, '/tmp/' + x);\n        mkdirp(file, function (err, made) {\n          t.ifError(err);\n          t.equal(made, null);\n        });\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('return value', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    // should return the first dir created.\n    // By this point, it would be profoundly surprising if /tmp didn't\n    // already exist, since every other test makes things in there.\n    // Note that this will throw on failure, which will fail the test.\n    var made = mkdirp.sync(file);\n    t.equal(made, '/tmp/' + x);\n\n    // making the same file again should have no effect.\n    made = mkdirp.sync(file);\n    t.equal(made, null);\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('root', function (t) {\n    // '/' on unix, 'c:/' on windows.\n    var file = path.resolve('/');\n\n    mkdirp(file, 0755, function (err) {\n        if (err) throw err\n        fs.stat(file, function (er, stat) {\n            if (er) throw er\n            t.ok(stat.isDirectory(), 'target is a directory');\n            t.end();\n        })\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('sync', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    try {\n        mkdirp.sync(file, 0755);\n    } catch (err) {\n        t.fail(err);\n        return t.end();\n    }\n\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        });\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('implicit mode from umask', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0777 & (~process.umask()));\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n","var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('umask sync modes', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    try {\n        mkdirp.sync(file);\n    } catch (err) {\n        t.fail(err);\n        return t.end();\n    }\n\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, (0777 & (~process.umask())));\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        });\n    });\n});\n","module.exports = require('./underscore');\n","(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,d=e.filter,g=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,_=Object.keys,j=i.bind,w=function(n){return n instanceof w?n:this instanceof w?(this._wrapped=n,void 0):new w(n)};\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=w),exports._=w):n._=w,w.VERSION=\"1.4.4\";var A=w.each=w.forEach=function(n,t,e){if(null!=n)if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a in n)if(w.has(n,a)&&t.call(e,n[a],a,n)===r)return};w.map=w.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e[e.length]=t.call(r,n,u,i)}),e)};var O=\"Reduce of empty array with no initial value\";w.reduce=w.foldl=w.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=w.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(O);return r},w.reduceRight=w.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=w.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=w.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(O);return r},w.find=w.detect=function(n,t,r){var e;return E(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},w.filter=w.select=function(n,t,r){var e=[];return null==n?e:d&&n.filter===d?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&(e[e.length]=n)}),e)},w.reject=function(n,t,r){return w.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},w.every=w.all=function(n,t,e){t||(t=w.identity);var u=!0;return null==n?u:g&&n.every===g?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var E=w.some=w.any=function(n,t,e){t||(t=w.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};w.contains=w.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:E(n,function(n){return n===t})},w.invoke=function(n,t){var r=o.call(arguments,2),e=w.isFunction(t);return w.map(n,function(n){return(e?t:n[t]).apply(n,r)})},w.pluck=function(n,t){return w.map(n,function(n){return n[t]})},w.where=function(n,t,r){return w.isEmpty(t)?r?null:[]:w[r?\"find\":\"filter\"](n,function(n){for(var r in t)if(t[r]!==n[r])return!1;return!0})},w.findWhere=function(n,t){return w.where(n,t,!0)},w.max=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.max.apply(Math,n);if(!t&&w.isEmpty(n))return-1/0;var e={computed:-1/0,value:-1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a>=e.computed&&(e={value:n,computed:a})}),e.value},w.min=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.min.apply(Math,n);if(!t&&w.isEmpty(n))return 1/0;var e={computed:1/0,value:1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;e.computed>a&&(e={value:n,computed:a})}),e.value},w.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=w.random(r++),e[r-1]=e[t],e[t]=n}),e};var k=function(n){return w.isFunction(n)?n:function(t){return t[n]}};w.sortBy=function(n,t,r){var e=k(t);return w.pluck(w.map(n,function(n,t,u){return{value:n,index:t,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index<t.index?-1:1}),\"value\")};var F=function(n,t,r,e){var u={},i=k(t||w.identity);return A(n,function(t,a){var o=i.call(r,t,a,n);e(u,o,t)}),u};w.groupBy=function(n,t,r){return F(n,t,r,function(n,t,r){(w.has(n,t)?n[t]:n[t]=[]).push(r)})},w.countBy=function(n,t,r){return F(n,t,r,function(n,t){w.has(n,t)||(n[t]=0),n[t]++})},w.sortedIndex=function(n,t,r,e){r=null==r?w.identity:k(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;u>r.call(e,n[o])?i=o+1:a=o}return i},w.toArray=function(n){return n?w.isArray(n)?o.call(n):n.length===+n.length?w.map(n,w.identity):w.values(n):[]},w.size=function(n){return null==n?0:n.length===+n.length?n.length:w.keys(n).length},w.first=w.head=w.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:o.call(n,0,t)},w.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},w.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},w.rest=w.tail=w.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},w.compact=function(n){return w.filter(n,w.identity)};var R=function(n,t,r){return A(n,function(n){w.isArray(n)?t?a.apply(r,n):R(n,t,r):r.push(n)}),r};w.flatten=function(n,t){return R(n,t,[])},w.without=function(n){return w.difference(n,o.call(arguments,1))},w.uniq=w.unique=function(n,t,r,e){w.isFunction(t)&&(e=r,r=t,t=!1);var u=r?w.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:w.contains(a,r))||(a.push(r),i.push(n[e]))}),i},w.union=function(){return w.uniq(c.apply(e,arguments))},w.intersection=function(n){var t=o.call(arguments,1);return w.filter(w.uniq(n),function(n){return w.every(t,function(t){return w.indexOf(t,n)>=0})})},w.difference=function(n){var t=c.apply(e,o.call(arguments,1));return w.filter(n,function(n){return!w.contains(t,n)})},w.zip=function(){for(var n=o.call(arguments),t=w.max(w.pluck(n,\"length\")),r=Array(t),e=0;t>e;e++)r[e]=w.pluck(n,\"\"+e);return r},w.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},w.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if(\"number\"!=typeof r)return e=w.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},w.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},w.range=function(n,t,r){1>=arguments.length&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=Array(e);e>u;)i[u++]=n,n+=r;return i},w.bind=function(n,t){if(n.bind===j&&j)return j.apply(n,o.call(arguments,1));var r=o.call(arguments,2);return function(){return n.apply(t,r.concat(o.call(arguments)))}},w.partial=function(n){var t=o.call(arguments,1);return function(){return n.apply(this,t.concat(o.call(arguments)))}},w.bindAll=function(n){var t=o.call(arguments,1);return 0===t.length&&(t=w.functions(n)),A(t,function(t){n[t]=w.bind(n[t],n)}),n},w.memoize=function(n,t){var r={};return t||(t=w.identity),function(){var e=t.apply(this,arguments);return w.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},w.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},w.defer=function(n){return w.delay.apply(w,[n,1].concat(o.call(arguments,1)))},w.throttle=function(n,t){var r,e,u,i,a=0,o=function(){a=new Date,u=null,i=n.apply(r,e)};return function(){var c=new Date,l=t-(c-a);return r=this,e=arguments,0>=l?(clearTimeout(u),u=null,a=c,i=n.apply(r,e)):u||(u=setTimeout(o,l)),i}},w.debounce=function(n,t,r){var e,u;return function(){var i=this,a=arguments,o=function(){e=null,r||(u=n.apply(i,a))},c=r&&!e;return clearTimeout(e),e=setTimeout(o,t),c&&(u=n.apply(i,a)),u}},w.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},w.wrap=function(n,t){return function(){var r=[n];return a.apply(r,arguments),t.apply(this,r)}},w.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},w.after=function(n,t){return 0>=n?t():function(){return 1>--n?t.apply(this,arguments):void 0}},w.keys=_||function(n){if(n!==Object(n))throw new TypeError(\"Invalid object\");var t=[];for(var r in n)w.has(n,r)&&(t[t.length]=r);return t},w.values=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push(n[r]);return t},w.pairs=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push([r,n[r]]);return t},w.invert=function(n){var t={};for(var r in n)w.has(n,r)&&(t[n[r]]=r);return t},w.functions=w.methods=function(n){var t=[];for(var r in n)w.isFunction(n[r])&&t.push(r);return t.sort()},w.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},w.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},w.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)w.contains(r,u)||(t[u]=n[u]);return t},w.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)null==n[r]&&(n[r]=t[r])}),n},w.clone=function(n){return w.isObject(n)?w.isArray(n)?n.slice():w.extend({},n):n},w.tap=function(n,t){return t(n),n};var I=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof w&&(n=n._wrapped),t instanceof w&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case\"[object String]\":return n==t+\"\";case\"[object Number]\":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case\"[object Date]\":case\"[object Boolean]\":return+n==+t;case\"[object RegExp]\":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if(\"object\"!=typeof n||\"object\"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;r.push(n),e.push(t);var a=0,o=!0;if(\"[object Array]\"==u){if(a=n.length,o=a==t.length)for(;a--&&(o=I(n[a],t[a],r,e)););}else{var c=n.constructor,f=t.constructor;if(c!==f&&!(w.isFunction(c)&&c instanceof c&&w.isFunction(f)&&f instanceof f))return!1;for(var s in n)if(w.has(n,s)&&(a++,!(o=w.has(t,s)&&I(n[s],t[s],r,e))))break;if(o){for(s in t)if(w.has(t,s)&&!a--)break;o=!a}}return r.pop(),e.pop(),o};w.isEqual=function(n,t){return I(n,t,[],[])},w.isEmpty=function(n){if(null==n)return!0;if(w.isArray(n)||w.isString(n))return 0===n.length;for(var t in n)if(w.has(n,t))return!1;return!0},w.isElement=function(n){return!(!n||1!==n.nodeType)},w.isArray=x||function(n){return\"[object Array]\"==l.call(n)},w.isObject=function(n){return n===Object(n)},A([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\"],function(n){w[\"is\"+n]=function(t){return l.call(t)==\"[object \"+n+\"]\"}}),w.isArguments(arguments)||(w.isArguments=function(n){return!(!n||!w.has(n,\"callee\"))}),\"function\"!=typeof/./&&(w.isFunction=function(n){return\"function\"==typeof n}),w.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},w.isNaN=function(n){return w.isNumber(n)&&n!=+n},w.isBoolean=function(n){return n===!0||n===!1||\"[object Boolean]\"==l.call(n)},w.isNull=function(n){return null===n},w.isUndefined=function(n){return n===void 0},w.has=function(n,t){return f.call(n,t)},w.noConflict=function(){return n._=t,this},w.identity=function(n){return n},w.times=function(n,t,r){for(var e=Array(n),u=0;n>u;u++)e[u]=t.call(r,u);return e},w.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))};var M={escape:{\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\",\"/\":\"&#x2F;\"}};M.unescape=w.invert(M.escape);var S={escape:RegExp(\"[\"+w.keys(M.escape).join(\"\")+\"]\",\"g\"),unescape:RegExp(\"(\"+w.keys(M.unescape).join(\"|\")+\")\",\"g\")};w.each([\"escape\",\"unescape\"],function(n){w[n]=function(t){return null==t?\"\":(\"\"+t).replace(S[n],function(t){return M[n][t]})}}),w.result=function(n,t){if(null==n)return null;var r=n[t];return w.isFunction(r)?r.call(n):r},w.mixin=function(n){A(w.functions(n),function(t){var r=w[t]=n[t];w.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),D.call(this,r.apply(w,n))}})};var N=0;w.uniqueId=function(n){var t=++N+\"\";return n?n+t:t},w.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var T=/(.)^/,q={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"\t\":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},B=/\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;w.template=function(n,t,r){var e;r=w.defaults({},r,w.templateSettings);var u=RegExp([(r.escape||T).source,(r.interpolate||T).source,(r.evaluate||T).source].join(\"|\")+\"|$\",\"g\"),i=0,a=\"__p+='\";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(B,function(n){return\"\\\\\"+q[n]}),r&&(a+=\"'+\\n((__t=(\"+r+\"))==null?'':_.escape(__t))+\\n'\"),e&&(a+=\"'+\\n((__t=(\"+e+\"))==null?'':__t)+\\n'\"),u&&(a+=\"';\\n\"+u+\"\\n__p+='\"),i=o+t.length,t}),a+=\"';\\n\",r.variable||(a=\"with(obj||{}){\\n\"+a+\"}\\n\"),a=\"var __t,__p='',__j=Array.prototype.join,\"+\"print=function(){__p+=__j.call(arguments,'');};\\n\"+a+\"return __p;\\n\";try{e=Function(r.variable||\"obj\",\"_\",a)}catch(o){throw o.source=a,o}if(t)return e(t,w);var c=function(n){return e.call(this,n,w)};return c.source=\"function(\"+(r.variable||\"obj\")+\"){\\n\"+a+\"}\",c},w.chain=function(n){return w(n).chain()};var D=function(n){return this._chain?w(n).chain():n};w.mixin(w),A([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(n){var t=e[n];w.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),\"shift\"!=n&&\"splice\"!=n||0!==r.length||delete r[0],D.call(this,r)}}),A([\"concat\",\"join\",\"slice\"],function(n){var t=e[n];w.prototype[n]=function(){return D.call(this,t.apply(this._wrapped,arguments))}}),w.extend(w.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);","//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","var should = require('chai').should()\r\n  , assert = require('chai').assert\r\n  , customUtils = require('../lib/customUtils')\r\n  , fs = require('fs')\r\n  ;\r\n\r\n\r\ndescribe('customUtils', function () {\r\n\r\n  describe('ensureFileDoesntExist', function () {\r\n  \r\n    it('Doesnt do anything if file already doesnt exist', function (done) {\r\n      customUtils.ensureFileDoesntExist('workspace/nonexisting', function (err) {\r\n        assert.isNull(err);\r\n        fs.existsSync('workspace/nonexisting').should.equal(false);\r\n        done();\r\n      });\r\n    });\r\n\r\n    it('Deletes file if it exists', function (done) {\r\n      fs.writeFileSync('workspace/existing', 'hello world', 'utf8');\r\n      fs.existsSync('workspace/existing').should.equal(true);\r\n    \r\n      customUtils.ensureFileDoesntExist('workspace/existing', function (err) {\r\n        assert.isNull(err);\r\n        fs.existsSync('workspace/existing').should.equal(false);\r\n        done();\r\n      });\r\n    });\r\n    \r\n  });\r\n\r\n\r\n\r\n});\r\n","var should = require('chai').should()\r\n  , assert = require('chai').assert\r\n  , testDb = 'workspace/test.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , _ = require('underscore')\r\n  , async = require('async')\r\n  , model = require('../lib/model')\r\n  , Datastore = require('../lib/datastore')\r\n  , Persistence = require('../lib/persistence')\r\n  ;\r\n\r\n\r\ndescribe('Database', function () {\r\n  var d;\r\n\r\n  beforeEach(function (done) {\r\n    d = new Datastore({ filename: testDb });\r\n    d.filename.should.equal(testDb);\r\n    d.inMemoryOnly.should.equal(false);\r\n\r\n    async.waterfall([\r\n      function (cb) {\r\n        Persistence.ensureDirectoryExists(path.dirname(testDb), function () {\r\n          fs.exists(testDb, function (exists) {\r\n            if (exists) {\r\n              fs.unlink(testDb, cb);\r\n            } else { return cb(); }\r\n          });\r\n        });\r\n      }\r\n    , function (cb) {\r\n        d.loadDatabase(function (err) {\r\n          assert.isNull(err);\r\n          d.getAllData().length.should.equal(0);\r\n          return cb();\r\n        });\r\n      }\r\n    ], done);\r\n  });\r\n\r\n  it('Constructor compatibility with v0.6-', function () {\r\n    var dbef = new Datastore('somefile');\r\n    dbef.filename.should.equal('somefile');\r\n    dbef.inMemoryOnly.should.equal(false);\r\n\r\n    var dbef = new Datastore('');\r\n    assert.isNull(dbef.filename);\r\n    dbef.inMemoryOnly.should.equal(true);\r\n\r\n    var dbef = new Datastore();\r\n    assert.isNull(dbef.filename);\r\n    dbef.inMemoryOnly.should.equal(true);\r\n  });\r\n\r\n  describe('Autoloading', function () {\r\n  \r\n    it('Can autoload a database and query it right away', function (done) {\r\n      var fileStr = model.serialize({ _id: '1', a: 5, planet: 'Earth' }) + '\\n' + model.serialize({ _id: '2', a: 5, planet: 'Mars' }) + '\\n'\r\n        , autoDb = 'workspace/auto.db'\r\n        , db\r\n        ;\r\n      \r\n      fs.writeFileSync(autoDb, fileStr, 'utf8');\r\n      db = new Datastore({ filename: autoDb, autoload: true })\r\n      \r\n      db.find({}, function (err, docs) {\r\n        assert.isNull(err);\r\n        docs.length.should.equal(2);\r\n        done();\r\n      });\r\n    });\r\n    \r\n    it('Throws if autoload fails', function (done) {\r\n      var fileStr = model.serialize({ _id: '1', a: 5, planet: 'Earth' }) + '\\n' + model.serialize({ _id: '2', a: 5, planet: 'Mars' }) + '\\n' + '{\"$$indexCreated\":{\"fieldName\":\"a\",\"unique\":true}}'\r\n        , autoDb = 'workspace/auto.db'\r\n        , db\r\n        ;\r\n      \r\n      fs.writeFileSync(autoDb, fileStr, 'utf8');\r\n      \r\n      // Check the loadDatabase generated an error\r\n      function onload (err) {\r\n        err.errorType.should.equal('uniqueViolated');\r\n        done();\r\n      }\r\n      \r\n      db = new Datastore({ filename: autoDb, autoload: true, onload: onload })\r\n      \r\n      db.find({}, function (err, docs) {\r\n        done(\"Find should not be executed since autoload failed\");\r\n      });    \r\n    });\r\n \r\n  });\r\n\r\n  describe('Insert', function () {\r\n\r\n    it('Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload', function (done) {\r\n      d.find({}, function (err, docs) {\r\n        docs.length.should.equal(0);\r\n\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          // The data was correctly updated\r\n          d.find({}, function (err, docs) {\r\n            assert.isNull(err);\r\n            docs.length.should.equal(1);\r\n            Object.keys(docs[0]).length.should.equal(2);\r\n            docs[0].somedata.should.equal('ok');\r\n            assert.isDefined(docs[0]._id);\r\n\r\n            // After a reload the data has been correctly persisted\r\n            d.loadDatabase(function (err) {\r\n              d.find({}, function (err, docs) {\r\n                assert.isNull(err);\r\n                docs.length.should.equal(1);\r\n                Object.keys(docs[0]).length.should.equal(2);\r\n                docs[0].somedata.should.equal('ok');\r\n                assert.isDefined(docs[0]._id);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can insert multiple documents in the database', function (done) {\r\n      d.find({}, function (err, docs) {\r\n        docs.length.should.equal(0);\r\n\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'another' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) {\r\n              d.find({}, function (err, docs) {\r\n                docs.length.should.equal(3);\r\n                _.pluck(docs, 'somedata').should.contain('ok');\r\n                _.pluck(docs, 'somedata').should.contain('another');\r\n                _.pluck(docs, 'somedata').should.contain('again');\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can insert and get back from DB complex objects with all primitive and secondary types', function (done) {\r\n      var da = new Date()\r\n        , obj = { a: ['ee', 'ff', 42], date: da, subobj: { a: 'b', b: 'c' } }\r\n        ;\r\n\r\n      d.insert(obj, function (err) {\r\n        d.findOne({}, function (err, res) {\r\n          assert.isNull(err);\r\n          res.a.length.should.equal(3);\r\n          res.a[0].should.equal('ee');\r\n          res.a[1].should.equal('ff');\r\n          res.a[2].should.equal(42);\r\n          res.date.getTime().should.equal(da.getTime());\r\n          res.subobj.a.should.equal('b');\r\n          res.subobj.b.should.equal('c');\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n    it('If an object returned from the DB is modified and refetched, the original value should be found', function (done) {\r\n      d.insert({ a: 'something' }, function () {\r\n        d.findOne({}, function (err, doc) {\r\n          doc.a.should.equal('something');\r\n          doc.a = 'another thing';\r\n          doc.a.should.equal('another thing');\r\n\r\n          // Re-fetching with findOne should yield the persisted value\r\n          d.findOne({}, function (err, doc) {\r\n            doc.a.should.equal('something');\r\n            doc.a = 'another thing';\r\n            doc.a.should.equal('another thing');\r\n\r\n            // Re-fetching with find should yield the persisted value\r\n            d.find({}, function (err, docs) {\r\n              docs[0].a.should.equal('something');\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Cannot insert a doc that has a field beginning with a $ sign', function (done) {\r\n      d.insert({ $something: 'atest' }, function (err) {\r\n        assert.isDefined(err);\r\n        done();\r\n      });\r\n    });\r\n\r\n    it('If an _id is already given when we insert a document, dont use it but use an automatic one', function (done) {\r\n      d.insert({ _id: 'test', stuff: true }, function (err, newDoc) {\r\n        if (err) { return done(err); }\r\n\r\n        newDoc.stuff.should.equal(true);\r\n        newDoc._id.should.not.equal('test');\r\n\r\n        done();\r\n      });\r\n    });\r\n\r\n    it('Modifying the insertedDoc after an insert doesnt change the copy saved in the database', function (done) {\r\n      d.insert({ a: 2, hello: 'world' }, function (err, newDoc) {\r\n        newDoc.hello = 'changed';\r\n\r\n        d.findOne({ a: 2 }, function (err, doc) {\r\n          doc.hello.should.equal('world');\r\n          done();\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('Can insert an array of documents at once', function (done) {\r\n      var docs = [{ a: 5, b: 'hello' }, { a: 42, b: 'world' }];\r\n    \r\n      d.insert(docs, function (err) {\r\n        d.find({}, function (err, docs) {\r\n          var data;\r\n        \r\n          docs.length.should.equal(2);\r\n          _.find(docs, function (doc) { return doc.a === 5; }).b.should.equal('hello');\r\n          _.find(docs, function (doc) { return doc.a === 42; }).b.should.equal('world');\r\n          \r\n          // The data has been persisted correctly\r\n          data = _.filter(fs.readFileSync(testDb, 'utf8').split('\\n'), function (line) { return line.length > 0; });\r\n          data.length.should.equal(2);\r\n          model.deserialize(data[0]).a.should.equal(5);\r\n          model.deserialize(data[0]).b.should.equal('hello');\r\n          model.deserialize(data[1]).a.should.equal(42);\r\n          model.deserialize(data[1]).b.should.equal('world');\r\n                    \r\n          done();\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('If a bulk insert violates a constraint, all changes are rolled back', function (done) {\r\n      var docs = [{ a: 5, b: 'hello' }, { a: 42, b: 'world' }, { a: 5, b: 'bloup' }, { a: 7 }];\r\n    \r\n      d.ensureIndex({ fieldName: 'a', unique: true });\r\n    \r\n      d.insert(docs, function (err) {\r\n        err.errorType.should.equal('uniqueViolated');\r\n      \r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(0);\r\n          fs.readFileSync(testDb, 'utf8').length.should.equal(0);   // Datafile not written to\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n    \r\n    /**\r\n     * Complicated behavior here. Basically we need to test that when a user function throws an exception, it is not caught\r\n     * in NeDB and the callback called again, transforming a user error into a NeDB error.\r\n     *\r\n     * So we need a way to check that the callback is called only once and the exception thrown is indeed the client exception\r\n     * Mocha's exception handling mechanism interferes with this since it already registers a listener on uncaughtException\r\n     * which we need to use since findOne is not called in the same turn of the event loop (so no try/catch)\r\n     * So we remove all current listeners, put our own which when called will register the former listeners (incl. Mocha's) again.\r\n     *\r\n     * Note: maybe using an in-memory only NeDB would give us an easier solution\r\n     */\r\n    it('If the callback throws an uncaught execption, dont catch it inside findOne, this is userspace concern', function (done) {\r\n      var tryCount = 0\r\n        , currentUncaughtExceptionHandlers = process.listeners('uncaughtException')\r\n        , i\r\n        ;\r\n\r\n      process.removeAllListeners('uncaughtException');\r\n      \r\n      process.on('uncaughtException', function MINE (ex) {\r\n        for (i = 0; i < currentUncaughtExceptionHandlers.length; i += 1) {\r\n          process.on('uncaughtException', currentUncaughtExceptionHandlers[i]);\r\n        }\r\n      \r\n        ex.should.equal('SOME EXCEPTION');\r\n        done();\r\n      });\r\n\r\n      d.insert({ a: 5 }, function () {\r\n        d.findOne({ a : 5}, function (err, doc) {            \r\n          if (tryCount === 0) {\r\n            tryCount += 1;\r\n            throw 'SOME EXCEPTION';\r\n          } else {\r\n            done('Callback was called twice');\r\n          }\r\n        });\r\n      });      \r\n    });\r\n\r\n  });   // ==== End of 'Insert' ==== //\r\n\r\n\r\n  describe('#getCandidates', function () {\r\n\r\n    it('Can use an index to get docs with a basic match', function (done) {\r\n      d.ensureIndex({ fieldName: 'tf' }, function (err) {\r\n        d.insert({ tf: 4 }, function (err, _doc1) {\r\n          d.insert({ tf: 6 }, function () {\r\n            d.insert({ tf: 4, an: 'other' }, function (err, _doc2) {\r\n              d.insert({ tf: 9 }, function () {\r\n                var data = d.getCandidates({ r: 6, tf: 4 })\r\n                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })\r\n                  ;\r\n\r\n                data.length.should.equal(2);\r\n                assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });\r\n                assert.deepEqual(doc2, { _id: doc2._id, tf: 4, an: 'other' });\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can use an index to get docs with a $in match', function (done) {\r\n      d.ensureIndex({ fieldName: 'tf' }, function (err) {\r\n        d.insert({ tf: 4 }, function (err) {\r\n          d.insert({ tf: 6 }, function (err, _doc1) {\r\n            d.insert({ tf: 4, an: 'other' }, function (err) {\r\n              d.insert({ tf: 9 }, function (err, _doc2) {\r\n                var data = d.getCandidates({ r: 6, tf: { $in: [6, 9, 5] } })\r\n                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })\r\n                  ;\r\n\r\n                data.length.should.equal(2);\r\n                assert.deepEqual(doc1, { _id: doc1._id, tf: 6 });\r\n                assert.deepEqual(doc2, { _id: doc2._id, tf: 9 });\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('If no index can be used, return the whole database', function (done) {\r\n      d.ensureIndex({ fieldName: 'tf' }, function (err) {\r\n        d.insert({ tf: 4 }, function (err, _doc1) {\r\n          d.insert({ tf: 6 }, function (err, _doc2) {\r\n            d.insert({ tf: 4, an: 'other' }, function (err, _doc3) {\r\n              d.insert({ tf: 9 }, function (err, _doc4) {\r\n                var data = d.getCandidates({ r: 6, notf: { $in: [6, 9, 5] } })\r\n                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })\r\n                  , doc3 = _.find(data, function (d) { return d._id === _doc3._id; })\r\n                  , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })\r\n                  ;\r\n\r\n                data.length.should.equal(4);\r\n                assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });\r\n                assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });\r\n                assert.deepEqual(doc3, { _id: doc3._id, tf: 4, an: 'other' });\r\n                assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can use indexes for comparison matches', function (done) {\r\n      d.ensureIndex({ fieldName: 'tf' }, function (err) {\r\n        d.insert({ tf: 4 }, function (err, _doc1) {\r\n          d.insert({ tf: 6 }, function (err, _doc2) {\r\n            d.insert({ tf: 4, an: 'other' }, function (err, _doc3) {\r\n              d.insert({ tf: 9 }, function (err, _doc4) {\r\n                var data = d.getCandidates({ r: 6, tf: { $lte: 9, $gte: 6 } })\r\n                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })\r\n                  , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })\r\n                  ;\r\n\r\n                data.length.should.equal(2);\r\n                assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });\r\n                assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n  });   // ==== End of '#getCandidates' ==== //\r\n\r\n\r\n  describe('Find', function () {\r\n\r\n    it('Can find all documents if an empty query is used', function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'another', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with empty object\r\n        d.find({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(3);\r\n          _.pluck(docs, 'somedata').should.contain('ok');\r\n          _.pluck(docs, 'somedata').should.contain('another');\r\n          _.find(docs, function (d) { return d.somedata === 'another' }).plus.should.equal('additional data');\r\n          _.pluck(docs, 'somedata').should.contain('again');\r\n          return cb();\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it('Can find all documents matching a basic query', function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that will return docs\r\n        d.find({ somedata: 'again' }, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(2);\r\n          _.pluck(docs, 'somedata').should.not.contain('ok');\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.find({ somedata: 'nope' }, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(0);\r\n          return cb();\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it('Can find one document matching a basic query and return null if none is found', function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that will return docs\r\n        d.findOne({ somedata: 'ok' }, function (err, doc) {\r\n          assert.isNull(err);\r\n          Object.keys(doc).length.should.equal(2);\r\n          doc.somedata.should.equal('ok');\r\n          assert.isDefined(doc._id);\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.findOne({ somedata: 'nope' }, function (err, doc) {\r\n          assert.isNull(err);\r\n          assert.isNull(doc);\r\n          return cb();\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it('Can find dates and objects (non JS-native types)', function (done) {\r\n      var date1 = new Date(1234543)\r\n        , date2 = new Date(9999)\r\n        ;\r\n\r\n      d.insert({ now: date1, sth: { name: 'nedb' } }, function () {\r\n        d.findOne({ now: date1 }, function (err, doc) {\r\n          assert.isNull(err);\r\n          doc.sth.name.should.equal('nedb');\r\n\r\n          d.findOne({ now: date2 }, function (err, doc) {\r\n            assert.isNull(err);\r\n            assert.isNull(doc);\r\n\r\n            d.findOne({ sth: { name: 'nedb' } }, function (err, doc) {\r\n              assert.isNull(err);\r\n              doc.sth.name.should.equal('nedb');\r\n\r\n              d.findOne({ sth: { name: 'other' } }, function (err, doc) {\r\n                assert.isNull(err);\r\n                assert.isNull(doc);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can use dot-notation to query subfields', function (done) {\r\n      d.insert({ greeting: { english: 'hello' } }, function () {\r\n        d.findOne({ \"greeting.english\": 'hello' }, function (err, doc) {\r\n          assert.isNull(err);\r\n          doc.greeting.english.should.equal('hello');\r\n\r\n          d.findOne({ \"greeting.english\": 'hellooo' }, function (err, doc) {\r\n            assert.isNull(err);\r\n            assert.isNull(doc);\r\n\r\n            d.findOne({ \"greeting.englis\": 'hello' }, function (err, doc) {\r\n              assert.isNull(err);\r\n              assert.isNull(doc);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Array fields match if any element matches', function (done) {\r\n      d.insert({ fruits: ['pear', 'apple', 'banana'] }, function (err, doc1) {\r\n        d.insert({ fruits: ['coconut', 'orange', 'pear'] }, function (err, doc2) {\r\n          d.insert({ fruits: ['banana'] }, function (err, doc3) {\r\n            d.find({ fruits: 'pear' }, function (err, docs) {\r\n              assert.isNull(err);\r\n              docs.length.should.equal(2);\r\n              _.pluck(docs, '_id').should.contain(doc1._id);\r\n              _.pluck(docs, '_id').should.contain(doc2._id);\r\n\r\n              d.find({ fruits: 'banana' }, function (err, docs) {\r\n                assert.isNull(err);\r\n                docs.length.should.equal(2);\r\n                _.pluck(docs, '_id').should.contain(doc1._id);\r\n                _.pluck(docs, '_id').should.contain(doc3._id);\r\n\r\n                d.find({ fruits: 'doesntexist' }, function (err, docs) {\r\n                  assert.isNull(err);\r\n                  docs.length.should.equal(0);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Returns an error if the query is not well formed', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.find({ $or: { hello: 'world' } }, function (err, docs) {\r\n          assert.isDefined(err);\r\n          assert.isUndefined(docs);\r\n\r\n          d.findOne({ $or: { hello: 'world' } }, function (err, doc) {\r\n            assert.isDefined(err);\r\n            assert.isUndefined(doc);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Changing the documents returned by find or findOne do not change the database state', function (done) {\r\n      d.insert({ a: 2, hello: 'world' }, function () {\r\n        d.findOne({ a: 2 }, function (err, doc) {\r\n          doc.hello = 'changed';\r\n\r\n          d.findOne({ a: 2 }, function (err, doc) {\r\n            doc.hello.should.equal('world');\r\n\r\n            d.find({ a: 2 }, function (err, docs) {\r\n              docs[0].hello = 'changed';\r\n\r\n              d.findOne({ a: 2 }, function (err, doc) {\r\n                doc.hello.should.equal('world');\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n  });   // ==== End of 'Find' ==== //\r\n\r\n  describe('Count', function() {\r\n\r\n    it('Count all documents if an empty query is used', function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'another', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with empty object\r\n        d.count({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.should.equal(3);\r\n          return cb();\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it('Count all documents matching a basic query', function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'again' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that will return docs\r\n        d.count({ somedata: 'again' }, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.should.equal(2);\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.count({ somedata: 'nope' }, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.should.equal(0);\r\n          return cb();\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it('Array fields match if any element matches', function (done) {\r\n      d.insert({ fruits: ['pear', 'apple', 'banana'] }, function (err, doc1) {\r\n        d.insert({ fruits: ['coconut', 'orange', 'pear'] }, function (err, doc2) {\r\n          d.insert({ fruits: ['banana'] }, function (err, doc3) {\r\n            d.count({ fruits: 'pear' }, function (err, docs) {\r\n              assert.isNull(err);\r\n              docs.should.equal(2);\r\n\r\n              d.count({ fruits: 'banana' }, function (err, docs) {\r\n                assert.isNull(err);\r\n                docs.should.equal(2);\r\n\r\n                d.count({ fruits: 'doesntexist' }, function (err, docs) {\r\n                  assert.isNull(err);\r\n                  docs.should.equal(0);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Returns an error if the query is not well formed', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.count({ $or: { hello: 'world' } }, function (err, docs) {\r\n          assert.isDefined(err);\r\n          assert.isUndefined(docs);\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n  }); \r\n\r\n  describe('Update', function () {\r\n\r\n    it(\"If the query doesn't match anything, database is not modified\", function (done) {\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err) {\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err) {\r\n            d.insert({ somedata: 'another' }, function (err) { return cb(err); });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.update({ somedata: 'nope' }, { newDoc: 'yes' }, { multi: true }, function (err, n) {\r\n          assert.isNull(err);\r\n          n.should.equal(0);\r\n\r\n          d.find({}, function (err, docs) {\r\n            var doc1 = _.find(docs, function (d) { return d.somedata === 'ok'; })\r\n              , doc2 = _.find(docs, function (d) { return d.somedata === 'again'; })\r\n              , doc3 = _.find(docs, function (d) { return d.somedata === 'another'; })\r\n              ;\r\n\r\n            docs.length.should.equal(3);\r\n            assert.isUndefined(_.find(docs, function (d) { return d.newDoc === 'yes'; }));\r\n\r\n            assert.deepEqual(doc1, { _id: doc1._id, somedata: 'ok' });\r\n            assert.deepEqual(doc2, { _id: doc2._id, somedata: 'again', plus: 'additional data' });\r\n            assert.deepEqual(doc3, { _id: doc3._id, somedata: 'another' });\r\n\r\n            return cb();\r\n          });\r\n        });\r\n      }\r\n      ], done);\r\n    });\r\n\r\n    it(\"Can update multiple documents matching the query\", function (done) {\r\n      var id1, id2, id3;\r\n\r\n      // Test DB state after update and reload\r\n      function testPostUpdateState (cb) {\r\n        d.find({}, function (err, docs) {\r\n          var doc1 = _.find(docs, function (d) { return d._id === id1; })\r\n            , doc2 = _.find(docs, function (d) { return d._id === id2; })\r\n            , doc3 = _.find(docs, function (d) { return d._id === id3; })\r\n            ;\r\n\r\n          docs.length.should.equal(3);\r\n\r\n          Object.keys(doc1).length.should.equal(2);\r\n          doc1.somedata.should.equal('ok');\r\n          doc1._id.should.equal(id1);\r\n\r\n          Object.keys(doc2).length.should.equal(2);\r\n          doc2.newDoc.should.equal('yes');\r\n          doc2._id.should.equal(id2);\r\n\r\n          Object.keys(doc3).length.should.equal(2);\r\n          doc3.newDoc.should.equal('yes');\r\n          doc3._id.should.equal(id3);\r\n\r\n          return cb();\r\n        });\r\n      }\r\n\r\n      // Actually launch the tests\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err, doc1) {\r\n          id1 = doc1._id;\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err, doc2) {\r\n            id2 = doc2._id;\r\n            d.insert({ somedata: 'again' }, function (err, doc3) {\r\n              id3 = doc3._id;\r\n              return cb(err);\r\n            });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {\r\n        d.update({ somedata: 'again' }, { newDoc: 'yes' }, { multi: true }, function (err, n) {\r\n          assert.isNull(err);\r\n          n.should.equal(2);\r\n          return cb();\r\n        });\r\n      }\r\n      , async.apply(testPostUpdateState)\r\n      , function (cb) {\r\n        d.loadDatabase(function (err) { cb(err); });\r\n      }\r\n      , async.apply(testPostUpdateState)\r\n      ], done);\r\n    });\r\n\r\n    it(\"Can update only one document matching the query\", function (done) {\r\n      var id1, id2, id3;\r\n\r\n      // Test DB state after update and reload\r\n      function testPostUpdateState (cb) {\r\n        d.find({}, function (err, docs) {\r\n          var doc1 = _.find(docs, function (d) { return d._id === id1; })\r\n            , doc2 = _.find(docs, function (d) { return d._id === id2; })\r\n            , doc3 = _.find(docs, function (d) { return d._id === id3; })\r\n            ;\r\n\r\n          docs.length.should.equal(3);\r\n\r\n          assert.deepEqual(doc1, { somedata: 'ok', _id: doc1._id });\r\n\r\n          // doc2 or doc3 was modified. Since we sort on _id and it is random\r\n          // it can be either of two situations\r\n          try {\r\n            assert.deepEqual(doc2, { newDoc: 'yes', _id: doc2._id });\r\n            assert.deepEqual(doc3, { somedata: 'again', _id: doc3._id });\r\n          } catch (e) {\r\n            assert.deepEqual(doc2, { somedata: 'again', plus: 'additional data', _id: doc2._id });\r\n            assert.deepEqual(doc3, { newDoc: 'yes', _id: doc3._id });\r\n          }\r\n\r\n          return cb();\r\n        });\r\n      }\r\n\r\n      // Actually launch the test\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err, doc1) {\r\n          id1 = doc1._id;\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err, doc2) {\r\n            id2 = doc2._id;\r\n            d.insert({ somedata: 'again' }, function (err, doc3) {\r\n              id3 = doc3._id;\r\n              return cb(err);\r\n            });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.update({ somedata: 'again' }, { newDoc: 'yes' }, { multi: false }, function (err, n) {\r\n          assert.isNull(err);\r\n          n.should.equal(1);\r\n          return cb();\r\n        });\r\n      }\r\n      , async.apply(testPostUpdateState)\r\n      , function (cb) {\r\n        d.loadDatabase(function (err) { return cb(err); });\r\n      }\r\n      , async.apply(testPostUpdateState)   // The persisted state has been updated\r\n      ], done);\r\n    });\r\n\r\n    it('Can perform upserts if needed', function (done) {\r\n      d.update({ impossible: 'db is empty anyway' }, { newDoc: true }, {}, function (err, nr, upsert) {\r\n        assert.isNull(err);\r\n        nr.should.equal(0);\r\n        assert.isUndefined(upsert);\r\n\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(0);   // Default option for upsert is false\r\n\r\n          d.update({ impossible: 'db is empty anyway' }, { newDoc: true }, { upsert: true }, function (err, nr, upsert) {\r\n            assert.isNull(err);\r\n            nr.should.equal(1);\r\n            upsert.should.equal(true);\r\n\r\n            d.find({}, function (err, docs) {\r\n              docs.length.should.equal(1);   // Default option for upsert is false\r\n              docs[0].newDoc.should.equal(true);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields', function (done) {\r\n      d.insert({ something: 'yup' }, function () {\r\n        d.update({}, { boom: { $badfield: 5 } }, { multi: false }, function (err) {\r\n          assert.isDefined(err);\r\n\r\n          d.update({}, { boom: { \"bad.field\": 5 } }, { multi: false }, function (err) {\r\n            assert.isDefined(err);\r\n\r\n            d.update({}, { $inc: { test: 5 }, mixed: 'rrr' }, { multi: false }, function (err) {\r\n              assert.isDefined(err);\r\n\r\n              d.update({}, { $inexistent: { test: 5 } }, { multi: false }, function (err) {\r\n                assert.isDefined(err);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can update documents using multiple modifiers', function (done) {\r\n      var id;\r\n\r\n      d.insert({ something: 'yup', other: 40 }, function (err, newDoc) {\r\n        id = newDoc._id;\r\n\r\n        d.update({}, { $set: { something: 'changed' }, $inc: { other: 10 } }, { multi: false }, function (err, nr) {\r\n          assert.isNull(err);\r\n          nr.should.equal(1);\r\n\r\n          d.findOne({ _id: id }, function (err, doc) {\r\n            Object.keys(doc).length.should.equal(3);\r\n            doc._id.should.equal(id);\r\n            doc.something.should.equal('changed');\r\n            doc.other.should.equal(50);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Can upsert a document even with modifiers', function (done) {\r\n      d.update({ bloup: 'blap' }, { $set: { hello: 'world' } }, { upsert: true }, function (err, nr, upsert) {\r\n        assert.isNull(err);\r\n        nr.should.equal(1);\r\n        upsert.should.equal(true);\r\n\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(1);\r\n          Object.keys(docs[0]).length.should.equal(3);\r\n          docs[0].hello.should.equal('world');\r\n          docs[0].bloup.should.equal('blap');\r\n          assert.isDefined(docs[0]._id);\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n    it('When using modifiers, the only way to update subdocs is with the dot-notation', function (done) {\r\n      d.insert({ bloup: { blip: \"blap\", other: true } }, function () {\r\n        // Correct methos\r\n        d.update({}, { $set: { \"bloup.blip\": \"hello\" } }, {}, function () {\r\n          d.findOne({}, function (err, doc) {\r\n            doc.bloup.blip.should.equal(\"hello\");\r\n            doc.bloup.other.should.equal(true);\r\n\r\n            // Wrong\r\n            d.update({}, { $set: { bloup: { blip: \"ola\" } } }, {}, function () {\r\n              d.findOne({}, function (err, doc) {\r\n                doc.bloup.blip.should.equal(\"ola\");\r\n                assert.isUndefined(doc.bloup.other);   // This information was lost\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Returns an error if the query is not well formed', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.update({ $or: { hello: 'world' } }, { a: 1 }, {}, function (err, nr, upsert) {\r\n          assert.isDefined(err);\r\n          assert.isUndefined(nr);\r\n          assert.isUndefined(upsert);\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n    it('If an error is thrown by a modifier, the database state is not changed', function (done) {\r\n      d.insert({ hello: 'world' }, function (err, newDoc) {\r\n        d.update({}, { $inc: { hello: 4 } }, {}, function (err, nr) {\r\n          assert.isDefined(err);\r\n          assert.isUndefined(nr);\r\n\r\n          d.find({}, function (err, docs) {\r\n            assert.deepEqual(docs, [ { _id: newDoc._id, hello: 'world' } ]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Cant change the _id of a document', function (done) {\r\n      d.insert({ a: 2 }, function (err, newDoc) {\r\n        d.update({ a: 2 }, { a: 2, _id: 'nope' }, {}, function (err) {\r\n          assert.isDefined(err);\r\n\r\n          d.find({}, function (err, docs) {\r\n            docs.length.should.equal(1);\r\n            Object.keys(docs[0]).length.should.equal(2);\r\n            docs[0].a.should.equal(2);\r\n            docs[0]._id.should.equal(newDoc._id);\r\n\r\n            d.update({ a: 2 }, { $set: { _id: 'nope' } }, {}, function (err) {\r\n              assert.isDefined(err);\r\n\r\n              d.find({}, function (err, docs) {\r\n                docs.length.should.equal(1);\r\n                Object.keys(docs[0]).length.should.equal(2);\r\n                docs[0].a.should.equal(2);\r\n                docs[0]._id.should.equal(newDoc._id);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Non-multi updates are persistent', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.update({ a: 2 }, { $set: { hello: 'changed' } }, {}, function (err) {\r\n            assert.isNull(err);\r\n\r\n            d.find({}, function (err, docs) {\r\n              docs.sort(function (a, b) { return a.a - b.a; });\r\n              docs.length.should.equal(2);\r\n              _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'world' }).should.equal(true);\r\n              _.isEqual(docs[1], { _id: doc2._id, a:2, hello: 'changed' }).should.equal(true);\r\n\r\n              // Even after a reload the database state hasn't changed\r\n              d.loadDatabase(function (err) {\r\n                assert.isNull(err);\r\n\r\n                d.find({}, function (err, docs) {\r\n                  docs.sort(function (a, b) { return a.a - b.a; });\r\n                  docs.length.should.equal(2);\r\n                  _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'world' }).should.equal(true);\r\n                  _.isEqual(docs[1], { _id: doc2._id, a:2, hello: 'changed' }).should.equal(true);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Multi updates are persistent', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.insert({ a:5, hello: 'pluton' }, function (err, doc3) {\r\n            d.update({ a: { $in: [1, 2] } }, { $set: { hello: 'changed' } }, { multi: true }, function (err) {\r\n              assert.isNull(err);\r\n\r\n              d.find({}, function (err, docs) {\r\n                docs.sort(function (a, b) { return a.a - b.a; });\r\n                docs.length.should.equal(3);\r\n                _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'changed' }).should.equal(true);\r\n                _.isEqual(docs[1], { _id: doc2._id, a:2, hello: 'changed' }).should.equal(true);\r\n                _.isEqual(docs[2], { _id: doc3._id, a:5, hello: 'pluton' }).should.equal(true);\r\n\r\n                // Even after a reload the database state hasn't changed\r\n                d.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n\r\n                  d.find({}, function (err, docs) {\r\n                    docs.sort(function (a, b) { return a.a - b.a; });\r\n                    docs.length.should.equal(3);\r\n                    _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'changed' }).should.equal(true);\r\n                    _.isEqual(docs[1], { _id: doc2._id, a:2, hello: 'changed' }).should.equal(true);\r\n                    _.isEqual(docs[2], { _id: doc3._id, a:5, hello: 'pluton' }).should.equal(true);\r\n\r\n                    done();\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('Can update without the options arg (will use defaults then)', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.insert({ a:5, hello: 'pluton' }, function (err, doc3) {\r\n            d.update({ a: 2 }, { $inc: { a: 10 } }, function (err, nr) {\r\n              assert.isNull(err);\r\n              nr.should.equal(1);\r\n              d.find({}, function (err, docs) {\r\n                var d1 = _.find(docs, function (doc) { return doc._id === doc1._id })\r\n                  , d2 = _.find(docs, function (doc) { return doc._id === doc2._id })\r\n                  , d3 = _.find(docs, function (doc) { return doc._id === doc3._id })\r\n                  ;\r\n                  \r\n                d1.a.should.equal(1);\r\n                d2.a.should.equal(12);\r\n                d3.a.should.equal(5);\r\n                \r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('If a multi update fails on one document, previous updates should be rolled back', function (done) {\r\n      d.ensureIndex({ fieldName: 'a' });\r\n      d.insert({ a: 4 }, function (err, doc1) {\r\n        d.insert({ a: 5 }, function (err, doc2) {\r\n          d.insert({ a: 'abc' }, function (err, doc3) {\r\n            // With this query, candidates are always returned in the order 4, 5, 'abc' so it's always the last one which fails\r\n            d.update({ a: { $in: [4, 5, 'abc'] } }, { $inc: { a: 10 } }, { multi: true }, function (err) {\r\n              assert.isDefined(err);\r\n\r\n              // No index modified\r\n              _.each(d.indexes, function (index) {\r\n                var docs = index.getAll()\r\n                  , d1 = _.find(docs, function (doc) { return doc._id === doc1._id })\r\n                  , d2 = _.find(docs, function (doc) { return doc._id === doc2._id })\r\n                  , d3 = _.find(docs, function (doc) { return doc._id === doc3._id })\r\n                  ;\r\n\r\n                // All changes rolled back, including those that didn't trigger an error\r\n                d1.a.should.equal(4);\r\n                d2.a.should.equal(5);\r\n                d3.a.should.equal('abc');\r\n              });\r\n \r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('If an index constraint is violated by an update, all changes should be rolled back', function (done) {\r\n      d.ensureIndex({ fieldName: 'a', unique: true });\r\n      d.insert({ a: 4 }, function (err, doc1) {\r\n        d.insert({ a: 5 }, function (err, doc2) {\r\n          // With this query, candidates are always returned in the order 4, 5, 'abc' so it's always the last one which fails\r\n           d.update({ a: { $in: [4, 5, 'abc'] } }, { $set: { a: 10 } }, { multi: true }, function (err) {\r\n            assert.isDefined(err);\r\n\t\t\t\r\n            // Check that no index was modified\r\n            _.each(d.indexes, function (index) {\r\n              var docs = index.getAll()\r\n              , d1 = _.find(docs, function (doc) { return doc._id === doc1._id })\r\n              , d2 = _.find(docs, function (doc) { return doc._id === doc2._id })\r\n              ;\r\n\t\t\t  \r\n              d1.a.should.equal(4);\r\n              d2.a.should.equal(5);\r\n            });\r\n            \r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n  });   // ==== End of 'Update' ==== //\r\n\r\n\r\n  describe('Remove', function () {\r\n\r\n    it('Can remove multiple documents', function (done) {\r\n      var id1, id2, id3;\r\n\r\n      // Test DB status\r\n      function testPostUpdateState (cb) {\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(1);\r\n\r\n          Object.keys(docs[0]).length.should.equal(2);\r\n          docs[0]._id.should.equal(id1);\r\n          docs[0].somedata.should.equal('ok');\r\n\r\n          return cb();\r\n        });\r\n      }\r\n\r\n      // Actually launch the test\r\n      async.waterfall([\r\n      function (cb) {\r\n        d.insert({ somedata: 'ok' }, function (err, doc1) {\r\n          id1 = doc1._id;\r\n          d.insert({ somedata: 'again', plus: 'additional data' }, function (err, doc2) {\r\n            id2 = doc2._id;\r\n            d.insert({ somedata: 'again' }, function (err, doc3) {\r\n              id3 = doc3._id;\r\n              return cb(err);\r\n            });\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {   // Test with query that doesn't match anything\r\n        d.remove({ somedata: 'again' }, { multi: true }, function (err, n) {\r\n          assert.isNull(err);\r\n          n.should.equal(2);\r\n          return cb();\r\n        });\r\n      }\r\n      , async.apply(testPostUpdateState)\r\n      , function (cb) {\r\n        d.loadDatabase(function (err) { return cb(err); });\r\n      }\r\n      , async.apply(testPostUpdateState)\r\n      ], done);\r\n    });\r\n\r\n    // This tests concurrency issues\r\n    it('Remove can be called multiple times in parallel and everything that needs to be removed will be', function (done) {\r\n      d.insert({ planet: 'Earth' }, function () {\r\n        d.insert({ planet: 'Mars' }, function () {\r\n          d.insert({ planet: 'Saturn' }, function () {\r\n            d.find({}, function (err, docs) {\r\n              docs.length.should.equal(3);\r\n\r\n              // Remove two docs simultaneously\r\n              var toRemove = ['Mars', 'Saturn'];\r\n              async.each(toRemove, function(planet, cb) {\r\n                d.remove({ planet: planet }, function (err) { return cb(err); });\r\n              }, function (err) {\r\n                d.find({}, function (err, docs) {\r\n                  docs.length.should.equal(1);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Returns an error if the query is not well formed', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.remove({ $or: { hello: 'world' } }, {}, function (err, nr, upsert) {\r\n          assert.isDefined(err);\r\n          assert.isUndefined(nr);\r\n          assert.isUndefined(upsert);\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Non-multi removes are persistent', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.insert({ a:3, hello: 'moto' }, function (err, doc3) {\r\n            d.remove({ a: 2 }, {}, function (err) {\r\n              assert.isNull(err);\r\n\r\n              d.find({}, function (err, docs) {\r\n                docs.sort(function (a, b) { return a.a - b.a; });\r\n                docs.length.should.equal(2);\r\n                _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'world' }).should.equal(true);\r\n                _.isEqual(docs[1], { _id: doc3._id, a:3, hello: 'moto' }).should.equal(true);\r\n\r\n                // Even after a reload the database state hasn't changed\r\n                d.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n\r\n                  d.find({}, function (err, docs) {\r\n                    docs.sort(function (a, b) { return a.a - b.a; });\r\n                    docs.length.should.equal(2);\r\n                    _.isEqual(docs[0], { _id: doc1._id, a:1, hello: 'world' }).should.equal(true);\r\n                    _.isEqual(docs[1], { _id: doc3._id, a:3, hello: 'moto' }).should.equal(true);\r\n\r\n                    done();\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Multi removes are persistent', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.insert({ a:3, hello: 'moto' }, function (err, doc3) {\r\n            d.remove({ a: { $in: [1, 3] } }, { multi: true }, function (err) {\r\n              assert.isNull(err);\r\n\r\n              d.find({}, function (err, docs) {\r\n                docs.length.should.equal(1);\r\n                _.isEqual(docs[0], { _id: doc2._id, a:2, hello: 'earth' }).should.equal(true);\r\n\r\n                // Even after a reload the database state hasn't changed\r\n                d.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n\r\n                  d.find({}, function (err, docs) {\r\n                    docs.length.should.equal(1);\r\n                    _.isEqual(docs[0], { _id: doc2._id, a:2, hello: 'earth' }).should.equal(true);\r\n\r\n                    done();\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('Can remove without the options arg (will use defaults then)', function (done) {\r\n      d.insert({ a:1, hello: 'world' }, function (err, doc1) {\r\n        d.insert({ a:2, hello: 'earth' }, function (err, doc2) {\r\n          d.insert({ a:5, hello: 'pluton' }, function (err, doc3) {\r\n            d.remove({ a: 2 }, function (err, nr) {\r\n              assert.isNull(err);\r\n              nr.should.equal(1);\r\n              d.find({}, function (err, docs) {\r\n                var d1 = _.find(docs, function (doc) { return doc._id === doc1._id })\r\n                  , d2 = _.find(docs, function (doc) { return doc._id === doc2._id })\r\n                  , d3 = _.find(docs, function (doc) { return doc._id === doc3._id })\r\n                  ;\r\n                  \r\n                d1.a.should.equal(1);\r\n                assert.isUndefined(d2);\r\n                d3.a.should.equal(5);\r\n                \r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n  });   // ==== End of 'Remove' ==== //\r\n\r\n\r\n  describe('Using indexes', function () {\r\n\r\n    describe('ensureIndex and index initialization in database loading', function () {\r\n\r\n      it('ensureIndex can be called right after a loadDatabase and be initialized and filled correctly', function (done) {\r\n        var now = new Date()\r\n          , rawData = model.serialize({ _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                      model.serialize({ _id: \"bbb\", z: \"2\", hello: 'world' }) + '\\n' +\r\n                      model.serialize({ _id: \"ccc\", z: \"3\", nested: { today: now } })\r\n          ;\r\n\r\n        d.getAllData().length.should.equal(0);\r\n\r\n        fs.writeFile(testDb, rawData, 'utf8', function () {\r\n          d.loadDatabase(function () {\r\n            d.getAllData().length.should.equal(3);\r\n\r\n            assert.deepEqual(Object.keys(d.indexes), ['_id']);\r\n\r\n            d.ensureIndex({ fieldName: 'z' });\r\n            d.indexes.z.fieldName.should.equal('z');\r\n            d.indexes.z.unique.should.equal(false);\r\n            d.indexes.z.sparse.should.equal(false);\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(3);\r\n            d.indexes.z.tree.search('1')[0].should.equal(d.getAllData()[0]);\r\n            d.indexes.z.tree.search('2')[0].should.equal(d.getAllData()[1]);\r\n            d.indexes.z.tree.search('3')[0].should.equal(d.getAllData()[2]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n      \r\n      it('ensureIndex can be called twice on the same field, the second call will ahve no effect', function (done) {\r\n        Object.keys(d.indexes).length.should.equal(1);\r\n        Object.keys(d.indexes)[0].should.equal(\"_id\");\r\n      \r\n        d.insert({ planet: \"Earth\" }, function () {\r\n          d.insert({ planet: \"Mars\" }, function () {\r\n            d.find({}, function (err, docs) {\r\n              docs.length.should.equal(2);\r\n              \r\n              d.ensureIndex({ fieldName: \"planet\" }, function (err) {\r\n                assert.isNull(err);\r\n                Object.keys(d.indexes).length.should.equal(2);\r\n                Object.keys(d.indexes)[0].should.equal(\"_id\");   \r\n                Object.keys(d.indexes)[1].should.equal(\"planet\");   \r\n\r\n                d.indexes.planet.getAll().length.should.equal(2);\r\n                \r\n                // This second call has no effect, documents don't get inserted twice in the index\r\n                d.ensureIndex({ fieldName: \"planet\" }, function (err) {\r\n                  assert.isNull(err);\r\n                  Object.keys(d.indexes).length.should.equal(2);\r\n                  Object.keys(d.indexes)[0].should.equal(\"_id\");   \r\n                  Object.keys(d.indexes)[1].should.equal(\"planet\");   \r\n\r\n                  d.indexes.planet.getAll().length.should.equal(2);                \r\n                  \r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('ensureIndex can be called after the data set was modified and the index still be correct', function (done) {\r\n        var rawData = model.serialize({ _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                      model.serialize({ _id: \"bbb\", z: \"2\", hello: 'world' })\r\n          ;\r\n\r\n        d.getAllData().length.should.equal(0);\r\n\r\n        fs.writeFile(testDb, rawData, 'utf8', function () {\r\n          d.loadDatabase(function () {\r\n            d.getAllData().length.should.equal(2);\r\n\r\n            assert.deepEqual(Object.keys(d.indexes), ['_id']);\r\n\r\n            d.insert({ z: \"12\", yes: 'yes' }, function (err, newDoc1) {\r\n              d.insert({ z: \"14\", nope: 'nope' }, function (err, newDoc2) {\r\n                d.remove({ z: \"2\" }, {}, function () {\r\n                  d.update({ z: \"1\" }, { $set: { 'yes': 'yep' } }, {}, function () {\r\n                    assert.deepEqual(Object.keys(d.indexes), ['_id']);\r\n\r\n                    d.ensureIndex({ fieldName: 'z' });\r\n                    d.indexes.z.fieldName.should.equal('z');\r\n                    d.indexes.z.unique.should.equal(false);\r\n                    d.indexes.z.sparse.should.equal(false);\r\n                    d.indexes.z.tree.getNumberOfKeys().should.equal(3);\r\n\r\n                    // The pointers in the _id and z indexes are the same\r\n                    d.indexes.z.tree.search('1')[0].should.equal(d.indexes._id.getMatching('aaa')[0]);\r\n                    d.indexes.z.tree.search('12')[0].should.equal(d.indexes._id.getMatching(newDoc1._id)[0]);\r\n                    d.indexes.z.tree.search('14')[0].should.equal(d.indexes._id.getMatching(newDoc2._id)[0]);\r\n\r\n                    // The data in the z index is correct\r\n                    d.find({}, function (err, docs) {\r\n                      var doc0 = _.find(docs, function (doc) { return doc._id === 'aaa'; })\r\n                        , doc1 = _.find(docs, function (doc) { return doc._id === newDoc1._id; })\r\n                        , doc2 = _.find(docs, function (doc) { return doc._id === newDoc2._id; })\r\n                        ;\r\n\r\n                      docs.length.should.equal(3);\r\n\r\n                      assert.deepEqual(doc0, { _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12], yes: 'yep' });\r\n                      assert.deepEqual(doc1, { _id: newDoc1._id, z: \"12\", yes: 'yes' });\r\n                      assert.deepEqual(doc2, { _id: newDoc2._id, z: \"14\", nope: 'nope' });\r\n\r\n                      done();\r\n                    });\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('ensureIndex can be called before a loadDatabase and still be initialized and filled correctly', function (done) {\r\n        var now = new Date()\r\n          , rawData = model.serialize({ _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                      model.serialize({ _id: \"bbb\", z: \"2\", hello: 'world' }) + '\\n' +\r\n                      model.serialize({ _id: \"ccc\", z: \"3\", nested: { today: now } })\r\n          ;\r\n\r\n        d.getAllData().length.should.equal(0);\r\n\r\n        d.ensureIndex({ fieldName: 'z' });\r\n        d.indexes.z.fieldName.should.equal('z');\r\n        d.indexes.z.unique.should.equal(false);\r\n        d.indexes.z.sparse.should.equal(false);\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        fs.writeFile(testDb, rawData, 'utf8', function () {\r\n          d.loadDatabase(function () {\r\n            var doc1 = _.find(d.getAllData(), function (doc) { return doc.z === \"1\"; })\r\n              , doc2 = _.find(d.getAllData(), function (doc) { return doc.z === \"2\"; })\r\n              , doc3 = _.find(d.getAllData(), function (doc) { return doc.z === \"3\"; })\r\n              ;\r\n\r\n            d.getAllData().length.should.equal(3);\r\n\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(3);\r\n            d.indexes.z.tree.search('1')[0].should.equal(doc1);\r\n            d.indexes.z.tree.search('2')[0].should.equal(doc2);\r\n            d.indexes.z.tree.search('3')[0].should.equal(doc3);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Can initialize multiple indexes on a database load', function (done) {\r\n        var now = new Date()\r\n          , rawData = model.serialize({ _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                      model.serialize({ _id: \"bbb\", z: \"2\", a: 'world' }) + '\\n' +\r\n                      model.serialize({ _id: \"ccc\", z: \"3\", a: { today: now } })\r\n          ;\r\n\r\n        d.getAllData().length.should.equal(0);\r\n\r\n        d.ensureIndex({ fieldName: 'z' });\r\n        d.ensureIndex({ fieldName: 'a' });\r\n        d.indexes.a.tree.getNumberOfKeys().should.equal(0);\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        fs.writeFile(testDb, rawData, 'utf8', function () {\r\n          d.loadDatabase(function () {\r\n            var doc1 = _.find(d.getAllData(), function (doc) { return doc.z === \"1\"; })\r\n              , doc2 = _.find(d.getAllData(), function (doc) { return doc.z === \"2\"; })\r\n              , doc3 = _.find(d.getAllData(), function (doc) { return doc.z === \"3\"; })\r\n              ;\r\n\r\n            d.getAllData().length.should.equal(3);\r\n\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(3);\r\n            d.indexes.z.tree.search('1')[0].should.equal(doc1);\r\n            d.indexes.z.tree.search('2')[0].should.equal(doc2);\r\n            d.indexes.z.tree.search('3')[0].should.equal(doc3);\r\n\r\n            d.indexes.a.tree.getNumberOfKeys().should.equal(3);\r\n            d.indexes.a.tree.search(2)[0].should.equal(doc1);\r\n            d.indexes.a.tree.search('world')[0].should.equal(doc2);\r\n            d.indexes.a.tree.search({ today: now })[0].should.equal(doc3);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If a unique constraint is not respected, database loading will not work and no data will be inserted', function (done) {\r\n        var now = new Date()\r\n          , rawData = model.serialize({ _id: \"aaa\", z: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                      model.serialize({ _id: \"bbb\", z: \"2\", a: 'world' }) + '\\n' +\r\n                      model.serialize({ _id: \"ccc\", z: \"1\", a: { today: now } })\r\n          ;\r\n\r\n        d.getAllData().length.should.equal(0);\r\n\r\n        d.ensureIndex({ fieldName: 'z', unique: true });\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        fs.writeFile(testDb, rawData, 'utf8', function () {\r\n          d.loadDatabase(function (err) {\r\n            err.errorType.should.equal('uniqueViolated');\r\n            err.key.should.equal(\"1\");\r\n            d.getAllData().length.should.equal(0);\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If a unique constraint is not respected, ensureIndex will return an error and not create an index', function (done) {\r\n        d.insert({ a: 1, b: 4 }, function () {\r\n          d.insert({ a: 2, b: 45 }, function () {\r\n            d.insert({ a: 1, b: 3 }, function () {\r\n              d.ensureIndex({ fieldName: 'b' }, function (err) {\r\n                assert.isNull(err);\r\n\r\n                d.ensureIndex({ fieldName: 'a', unique: true }, function (err) {\r\n                  err.errorType.should.equal('uniqueViolated');\r\n                  assert.deepEqual(Object.keys(d.indexes), ['_id', 'b']);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n      \r\n      it('Can remove an index', function (done) {\r\n        d.ensureIndex({ fieldName: 'e' }, function (err) {\r\n          assert.isNull(err);\r\n          \r\n          Object.keys(d.indexes).length.should.equal(2);\r\n          assert.isNotNull(d.indexes.e);\r\n          \r\n          d.removeIndex(\"e\", function (err) {\r\n            assert.isNull(err);\r\n            Object.keys(d.indexes).length.should.equal(1);\r\n            assert.isUndefined(d.indexes.e); \r\n \r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n    });   // ==== End of 'ensureIndex and index initialization in database loading' ==== //\r\n\r\n    \r\n    describe('Indexing newly inserted documents', function () {\r\n\r\n      it('Newly inserted documents are indexed', function (done) {\r\n        d.ensureIndex({ fieldName: 'z' });\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        d.insert({ a: 2, z: 'yes' }, function (err, newDoc) {\r\n          d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n          assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc]);\r\n\r\n          d.insert({ a: 5, z: 'nope' }, function (err, newDoc) {\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(2);\r\n            assert.deepEqual(d.indexes.z.getMatching('nope'), [newDoc]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If multiple indexes are defined, the document is inserted in all of them', function (done) {\r\n        d.ensureIndex({ fieldName: 'z' });\r\n        d.ensureIndex({ fieldName: 'ya' });\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        d.insert({ a: 2, z: 'yes', ya: 'indeed' }, function (err, newDoc) {\r\n          d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n          d.indexes.ya.tree.getNumberOfKeys().should.equal(1);\r\n          assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc]);\r\n          assert.deepEqual(d.indexes.ya.getMatching('indeed'), [newDoc]);\r\n\r\n          d.insert({ a: 5, z: 'nope', ya: 'sure' }, function (err, newDoc2) {\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(2);\r\n            d.indexes.ya.tree.getNumberOfKeys().should.equal(2);\r\n            assert.deepEqual(d.indexes.z.getMatching('nope'), [newDoc2]);\r\n            assert.deepEqual(d.indexes.ya.getMatching('sure'), [newDoc2]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Can insert two docs at the same key for a non unique index', function (done) {\r\n        d.ensureIndex({ fieldName: 'z' });\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        d.insert({ a: 2, z: 'yes' }, function (err, newDoc) {\r\n          d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n          assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc]);\r\n\r\n          d.insert({ a: 5, z: 'yes' }, function (err, newDoc2) {\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n            assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc, newDoc2]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If the index has a unique constraint, an error is thrown if it is violated and the data is not modified', function (done) {\r\n        d.ensureIndex({ fieldName: 'z', unique: true });\r\n        d.indexes.z.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        d.insert({ a: 2, z: 'yes' }, function (err, newDoc) {\r\n          d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n          assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc]);\r\n\r\n          d.insert({ a: 5, z: 'yes' }, function (err) {\r\n            err.errorType.should.equal('uniqueViolated');\r\n            err.key.should.equal('yes');\r\n\r\n            // Index didn't change\r\n            d.indexes.z.tree.getNumberOfKeys().should.equal(1);\r\n            assert.deepEqual(d.indexes.z.getMatching('yes'), [newDoc]);\r\n\r\n            // Data didn't change\r\n            assert.deepEqual(d.getAllData(), [newDoc]);\r\n            d.loadDatabase(function () {\r\n              d.getAllData().length.should.equal(1);\r\n              assert.deepEqual(d.getAllData()[0], newDoc);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If an index has a unique constraint, other indexes cannot be modified when it raises an error', function (done) {\r\n        d.ensureIndex({ fieldName: 'nonu1' });\r\n        d.ensureIndex({ fieldName: 'uni', unique: true });\r\n        d.ensureIndex({ fieldName: 'nonu2' });\r\n\r\n        d.insert({ nonu1: 'yes', nonu2: 'yes2', uni: 'willfail' }, function (err, newDoc) {\r\n          assert.isNull(err);\r\n          d.indexes.nonu1.tree.getNumberOfKeys().should.equal(1);\r\n          d.indexes.uni.tree.getNumberOfKeys().should.equal(1);\r\n          d.indexes.nonu2.tree.getNumberOfKeys().should.equal(1);\r\n\r\n          d.insert({ nonu1: 'no', nonu2: 'no2', uni: 'willfail' }, function (err) {\r\n            err.errorType.should.equal('uniqueViolated');\r\n\r\n            // No index was modified\r\n            d.indexes.nonu1.tree.getNumberOfKeys().should.equal(1);\r\n            d.indexes.uni.tree.getNumberOfKeys().should.equal(1);\r\n            d.indexes.nonu2.tree.getNumberOfKeys().should.equal(1);\r\n\r\n            assert.deepEqual(d.indexes.nonu1.getMatching('yes'), [newDoc]);\r\n            assert.deepEqual(d.indexes.uni.getMatching('willfail'), [newDoc]);\r\n            assert.deepEqual(d.indexes.nonu2.getMatching('yes2'), [newDoc]);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse', function (done) {\r\n        d.ensureIndex({ fieldName: 'zzz', unique: true });\r\n        d.indexes.zzz.tree.getNumberOfKeys().should.equal(0);\r\n\r\n        d.insert({ a: 2, z: 'yes' }, function (err, newDoc) {\r\n          d.indexes.zzz.tree.getNumberOfKeys().should.equal(1);\r\n          assert.deepEqual(d.indexes.zzz.getMatching(undefined), [newDoc]);\r\n\r\n          d.insert({ a: 5, z: 'other' }, function (err) {\r\n            err.errorType.should.equal('uniqueViolated');\r\n            assert.isUndefined(err.key);\r\n\r\n            d.ensureIndex({ fieldName: 'yyy', unique: true, sparse: true });\r\n\r\n            d.insert({ a: 5, z: 'other', zzz: 'set' }, function (err) {\r\n              assert.isNull(err);\r\n              d.indexes.yyy.getAll().length.should.equal(0);   // Nothing indexed\r\n              d.indexes.zzz.getAll().length.should.equal(2);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Insertion still works as before with indexing', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n        d.ensureIndex({ fieldName: 'b' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, doc2) {\r\n            d.find({}, function (err, docs) {\r\n              assert.deepEqual(doc1, _.find(docs, function (d) { return d._id === doc1._id; }));\r\n              assert.deepEqual(doc2, _.find(docs, function (d) { return d._id === doc2._id; }));\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('All indexes point to the same data as the main index on _id', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, doc2) {\r\n            d.find({}, function (err, docs) {\r\n              docs.length.should.equal(2);\r\n              d.getAllData().length.should.equal(2);\r\n\r\n              d.indexes._id.getMatching(doc1._id).length.should.equal(1);\r\n              d.indexes.a.getMatching(1).length.should.equal(1);\r\n              d.indexes._id.getMatching(doc1._id)[0].should.equal(d.indexes.a.getMatching(1)[0]);\r\n\r\n              d.indexes._id.getMatching(doc2._id).length.should.equal(1);\r\n              d.indexes.a.getMatching(2).length.should.equal(1);\r\n              d.indexes._id.getMatching(doc2._id)[0].should.equal(d.indexes.a.getMatching(2)[0]);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If a unique constraint is violated, no index is changed, including the main one', function (done) {\r\n        d.ensureIndex({ fieldName: 'a', unique: true });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, doc1) {\r\n          d.insert({ a: 1, b: 'si' }, function (err) {\r\n            assert.isDefined(err);\r\n\r\n            d.find({}, function (err, docs) {\r\n              docs.length.should.equal(1);\r\n              d.getAllData().length.should.equal(1);\r\n\r\n              d.indexes._id.getMatching(doc1._id).length.should.equal(1);\r\n              d.indexes.a.getMatching(1).length.should.equal(1);\r\n              d.indexes._id.getMatching(doc1._id)[0].should.equal(d.indexes.a.getMatching(1)[0]);\r\n\r\n              d.indexes.a.getMatching(2).length.should.equal(0);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n    });   // ==== End of 'Indexing newly inserted documents' ==== //\r\n\r\n    describe('Updating indexes upon document update', function () {\r\n\r\n      it('Updating docs still works as before with indexing', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, _doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, _doc2) {\r\n            d.update({ a: 1 }, { $set: { a: 456, b: 'no' } }, {}, function (err, nr) {\r\n              var data = d.getAllData()\r\n                , doc1 = _.find(data, function (doc) { return doc._id === _doc1._id; })\r\n                , doc2 = _.find(data, function (doc) { return doc._id === _doc2._id; })\r\n                ;\r\n\r\n              assert.isNull(err);\r\n              nr.should.equal(1);\r\n\r\n              data.length.should.equal(2);\r\n              assert.deepEqual(doc1, { a: 456, b: 'no', _id: _doc1._id });\r\n              assert.deepEqual(doc2, { a: 2, b: 'si', _id: _doc2._id });\r\n\r\n              d.update({}, { $inc: { a: 10 }, $set: { b: 'same' } }, { multi: true }, function (err, nr) {\r\n                var data = d.getAllData()\r\n                  , doc1 = _.find(data, function (doc) { return doc._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (doc) { return doc._id === _doc2._id; })\r\n                  ;\r\n\r\n                assert.isNull(err);\r\n                nr.should.equal(2);\r\n\r\n                data.length.should.equal(2);\r\n                assert.deepEqual(doc1, { a: 466, b: 'same', _id: _doc1._id });\r\n                assert.deepEqual(doc2, { a: 12, b: 'same', _id: _doc2._id });\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Indexes get updated when a document (or multiple documents) is updated', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n        d.ensureIndex({ fieldName: 'b' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, doc2) {\r\n            // Simple update\r\n            d.update({ a: 1 }, { $set: { a: 456, b: 'no' } }, {}, function (err, nr) {\r\n              assert.isNull(err);\r\n              nr.should.equal(1);\r\n\r\n              d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n              d.indexes.a.getMatching(456)[0]._id.should.equal(doc1._id);\r\n              d.indexes.a.getMatching(2)[0]._id.should.equal(doc2._id);\r\n\r\n              d.indexes.b.tree.getNumberOfKeys().should.equal(2);\r\n              d.indexes.b.getMatching('no')[0]._id.should.equal(doc1._id);\r\n              d.indexes.b.getMatching('si')[0]._id.should.equal(doc2._id);\r\n\r\n              // The same pointers are shared between all indexes\r\n              d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n              d.indexes.b.tree.getNumberOfKeys().should.equal(2);\r\n              d.indexes._id.tree.getNumberOfKeys().should.equal(2);\r\n              d.indexes.a.getMatching(456)[0].should.equal(d.indexes._id.getMatching(doc1._id)[0]);\r\n              d.indexes.b.getMatching('no')[0].should.equal(d.indexes._id.getMatching(doc1._id)[0]);\r\n              d.indexes.a.getMatching(2)[0].should.equal(d.indexes._id.getMatching(doc2._id)[0]);\r\n              d.indexes.b.getMatching('si')[0].should.equal(d.indexes._id.getMatching(doc2._id)[0]);\r\n\r\n              // Multi update\r\n              d.update({}, { $inc: { a: 10 }, $set: { b: 'same' } }, { multi: true }, function (err, nr) {\r\n                assert.isNull(err);\r\n                nr.should.equal(2);\r\n\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.a.getMatching(466)[0]._id.should.equal(doc1._id);\r\n                d.indexes.a.getMatching(12)[0]._id.should.equal(doc2._id);\r\n\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(1);\r\n                d.indexes.b.getMatching('same').length.should.equal(2);\r\n                _.pluck(d.indexes.b.getMatching('same'), '_id').should.contain(doc1._id);\r\n                _.pluck(d.indexes.b.getMatching('same'), '_id').should.contain(doc2._id);\r\n\r\n                // The same pointers are shared between all indexes\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(1);\r\n                d.indexes.b.getAll().length.should.equal(2);\r\n                d.indexes._id.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.a.getMatching(466)[0].should.equal(d.indexes._id.getMatching(doc1._id)[0]);\r\n                d.indexes.a.getMatching(12)[0].should.equal(d.indexes._id.getMatching(doc2._id)[0]);\r\n                // Can't test the pointers in b as their order is randomized, but it is the same as with a\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If a simple update violates a contraint, all changes are rolled back and an error is thrown', function (done) {\r\n        d.ensureIndex({ fieldName: 'a', unique: true });\r\n        d.ensureIndex({ fieldName: 'b', unique: true });\r\n        d.ensureIndex({ fieldName: 'c', unique: true });\r\n\r\n        d.insert({ a: 1, b: 10, c: 100 }, function (err, _doc1) {\r\n          d.insert({ a: 2, b: 20, c: 200 }, function (err, _doc2) {\r\n            d.insert({ a: 3, b: 30, c: 300 }, function (err, _doc3) {\r\n              // Will conflict with doc3\r\n              d.update({ a: 2 }, { $inc: { a: 10, c: 1000 }, $set: { b: 30 } }, {}, function (err) {\r\n                var data = d.getAllData()\r\n                  , doc1 = _.find(data, function (doc) { return doc._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (doc) { return doc._id === _doc2._id; })\r\n                  , doc3 = _.find(data, function (doc) { return doc._id === _doc3._id; })\r\n                  ;\r\n\r\n                err.errorType.should.equal('uniqueViolated');\r\n\r\n                // Data left unchanged\r\n                data.length.should.equal(3);\r\n                assert.deepEqual(doc1, { a: 1, b: 10, c: 100, _id: _doc1._id });\r\n                assert.deepEqual(doc2, { a: 2, b: 20, c: 200, _id: _doc2._id });\r\n                assert.deepEqual(doc3, { a: 3, b: 30, c: 300, _id: _doc3._id });\r\n\r\n                // All indexes left unchanged and pointing to the same docs\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.a.getMatching(1)[0].should.equal(doc1);\r\n                d.indexes.a.getMatching(2)[0].should.equal(doc2);\r\n                d.indexes.a.getMatching(3)[0].should.equal(doc3);\r\n\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.b.getMatching(10)[0].should.equal(doc1);\r\n                d.indexes.b.getMatching(20)[0].should.equal(doc2);\r\n                d.indexes.b.getMatching(30)[0].should.equal(doc3);\r\n\r\n                d.indexes.c.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.c.getMatching(100)[0].should.equal(doc1);\r\n                d.indexes.c.getMatching(200)[0].should.equal(doc2);\r\n                d.indexes.c.getMatching(300)[0].should.equal(doc3);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('If a multi update violates a contraint, all changes are rolled back and an error is thrown', function (done) {\r\n        d.ensureIndex({ fieldName: 'a', unique: true });\r\n        d.ensureIndex({ fieldName: 'b', unique: true });\r\n        d.ensureIndex({ fieldName: 'c', unique: true });\r\n\r\n        d.insert({ a: 1, b: 10, c: 100 }, function (err, _doc1) {\r\n          d.insert({ a: 2, b: 20, c: 200 }, function (err, _doc2) {\r\n            d.insert({ a: 3, b: 30, c: 300 }, function (err, _doc3) {\r\n              // Will conflict with doc3\r\n              d.update({ a: { $in: [1, 2] } }, { $inc: { a: 10, c: 1000 }, $set: { b: 30 } }, { multi: true }, function (err) {\r\n                var data = d.getAllData()\r\n                  , doc1 = _.find(data, function (doc) { return doc._id === _doc1._id; })\r\n                  , doc2 = _.find(data, function (doc) { return doc._id === _doc2._id; })\r\n                  , doc3 = _.find(data, function (doc) { return doc._id === _doc3._id; })\r\n                  ;\r\n\r\n                err.errorType.should.equal('uniqueViolated');\r\n\r\n                // Data left unchanged\r\n                data.length.should.equal(3);\r\n                assert.deepEqual(doc1, { a: 1, b: 10, c: 100, _id: _doc1._id });\r\n                assert.deepEqual(doc2, { a: 2, b: 20, c: 200, _id: _doc2._id });\r\n                assert.deepEqual(doc3, { a: 3, b: 30, c: 300, _id: _doc3._id });\r\n\r\n                // All indexes left unchanged and pointing to the same docs\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.a.getMatching(1)[0].should.equal(doc1);\r\n                d.indexes.a.getMatching(2)[0].should.equal(doc2);\r\n                d.indexes.a.getMatching(3)[0].should.equal(doc3);\r\n\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.b.getMatching(10)[0].should.equal(doc1);\r\n                d.indexes.b.getMatching(20)[0].should.equal(doc2);\r\n                d.indexes.b.getMatching(30)[0].should.equal(doc3);\r\n\r\n                d.indexes.c.tree.getNumberOfKeys().should.equal(3);\r\n                d.indexes.c.getMatching(100)[0].should.equal(doc1);\r\n                d.indexes.c.getMatching(200)[0].should.equal(doc2);\r\n                d.indexes.c.getMatching(300)[0].should.equal(doc3);\r\n\r\n                done();\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n    });   // ==== End of 'Updating indexes upon document update' ==== //\r\n\r\n    describe('Updating indexes upon document remove', function () {\r\n\r\n      it('Removing docs still works as before with indexing', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, _doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, _doc2) {\r\n            d.insert({ a: 3, b: 'coin' }, function (err, _doc3) {\r\n              d.remove({ a: 1 }, {}, function (err, nr) {\r\n                var data = d.getAllData()\r\n                , doc2 = _.find(data, function (doc) { return doc._id === _doc2._id; })\r\n                , doc3 = _.find(data, function (doc) { return doc._id === _doc3._id; })\r\n                ;\r\n\r\n                assert.isNull(err);\r\n                nr.should.equal(1);\r\n\r\n                data.length.should.equal(2);\r\n                assert.deepEqual(doc2, { a: 2, b: 'si', _id: _doc2._id });\r\n                assert.deepEqual(doc3, { a: 3, b: 'coin', _id: _doc3._id });\r\n\r\n                d.remove({ a: { $in: [2, 3] } }, { multi: true }, function (err, nr) {\r\n                  var data = d.getAllData()\r\n                  ;\r\n\r\n                  assert.isNull(err);\r\n                  nr.should.equal(2);\r\n                  data.length.should.equal(0);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      it('Indexes get updated when a document (or multiple documents) is removed', function (done) {\r\n        d.ensureIndex({ fieldName: 'a' });\r\n        d.ensureIndex({ fieldName: 'b' });\r\n\r\n        d.insert({ a: 1, b: 'hello' }, function (err, doc1) {\r\n          d.insert({ a: 2, b: 'si' }, function (err, doc2) {\r\n            d.insert({ a: 3, b: 'coin' }, function (err, doc3) {\r\n              // Simple remove\r\n              d.remove({ a: 1 }, {}, function (err, nr) {\r\n                assert.isNull(err);\r\n                nr.should.equal(1);\r\n\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.a.getMatching(2)[0]._id.should.equal(doc2._id);\r\n                d.indexes.a.getMatching(3)[0]._id.should.equal(doc3._id);\r\n\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.b.getMatching('si')[0]._id.should.equal(doc2._id);\r\n                d.indexes.b.getMatching('coin')[0]._id.should.equal(doc3._id);\r\n\r\n                // The same pointers are shared between all indexes\r\n                d.indexes.a.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.b.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes._id.tree.getNumberOfKeys().should.equal(2);\r\n                d.indexes.a.getMatching(2)[0].should.equal(d.indexes._id.getMatching(doc2._id)[0]);\r\n                d.indexes.b.getMatching('si')[0].should.equal(d.indexes._id.getMatching(doc2._id)[0]);\r\n                d.indexes.a.getMatching(3)[0].should.equal(d.indexes._id.getMatching(doc3._id)[0]);\r\n                d.indexes.b.getMatching('coin')[0].should.equal(d.indexes._id.getMatching(doc3._id)[0]);\r\n\r\n                // Multi remove\r\n                d.remove({}, { multi: true }, function (err, nr) {\r\n                  assert.isNull(err);\r\n                  nr.should.equal(2);\r\n\r\n                  d.indexes.a.tree.getNumberOfKeys().should.equal(0);\r\n                  d.indexes.b.tree.getNumberOfKeys().should.equal(0);\r\n                  d.indexes._id.tree.getNumberOfKeys().should.equal(0);\r\n\r\n                  done();\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n    });   // ==== End of 'Updating indexes upon document remove' ==== //\r\n    \r\n    \r\n    describe('Persisting indexes', function () {\r\n    \r\n      it('Indexes are persisted to a separate file and recreated upon reload', function (done) {\r\n        var persDb = \"workspace/persistIndexes.db\"\r\n          , db\r\n          ;\r\n        \r\n        if (fs.existsSync(persDb)) { fs.writeFileSync(persDb, '', 'utf8'); }\r\n        db = new Datastore({ filename: persDb, autoload: true });\r\n        \r\n        Object.keys(db.indexes).length.should.equal(1);\r\n        Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n        \r\n        db.insert({ planet: \"Earth\" }, function (err) {\r\n          assert.isNull(err);\r\n          db.insert({ planet: \"Mars\" }, function (err) {\r\n            assert.isNull(err);\r\n            \r\n            db.ensureIndex({ fieldName: \"planet\" }, function (err) {\r\n              Object.keys(db.indexes).length.should.equal(2);\r\n              Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n              Object.keys(db.indexes)[1].should.equal(\"planet\");              \r\n              db.indexes._id.getAll().length.should.equal(2);\r\n              db.indexes.planet.getAll().length.should.equal(2);\r\n              db.indexes.planet.fieldName.should.equal(\"planet\");\r\n              \r\n              // After a reload the indexes are recreated\r\n              db = new Datastore({ filename: persDb });\r\n              db.loadDatabase(function (err) {\r\n                assert.isNull(err);\r\n                Object.keys(db.indexes).length.should.equal(2);\r\n                Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                Object.keys(db.indexes)[1].should.equal(\"planet\");                \r\n                db.indexes._id.getAll().length.should.equal(2);\r\n                db.indexes.planet.getAll().length.should.equal(2);\r\n                db.indexes.planet.fieldName.should.equal(\"planet\");\r\n\r\n                // After another reload the indexes are still there (i.e. they are preserved during autocompaction)\r\n                db = new Datastore({ filename: persDb });\r\n                db.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n                  Object.keys(db.indexes).length.should.equal(2);\r\n                  Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                  Object.keys(db.indexes)[1].should.equal(\"planet\");                \r\n                  db.indexes._id.getAll().length.should.equal(2);\r\n                  db.indexes.planet.getAll().length.should.equal(2);\r\n                  db.indexes.planet.fieldName.should.equal(\"planet\");\r\n              \r\n                  done();                \r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    \r\n      it('Indexes are persisted with their options and recreated even if some db operation happen between loads', function (done) {\r\n        var persDb = \"workspace/persistIndexes.db\"\r\n          , db\r\n          ;\r\n        \r\n        if (fs.existsSync(persDb)) { fs.writeFileSync(persDb, '', 'utf8'); }\r\n        db = new Datastore({ filename: persDb, autoload: true });\r\n        \r\n        Object.keys(db.indexes).length.should.equal(1);\r\n        Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n        \r\n        db.insert({ planet: \"Earth\" }, function (err) {\r\n          assert.isNull(err);\r\n          db.insert({ planet: \"Mars\" }, function (err) {\r\n            assert.isNull(err);\r\n            \r\n            db.ensureIndex({ fieldName: \"planet\", unique: true, sparse: false }, function (err) {\r\n              Object.keys(db.indexes).length.should.equal(2);\r\n              Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n              Object.keys(db.indexes)[1].should.equal(\"planet\");              \r\n              db.indexes._id.getAll().length.should.equal(2);\r\n              db.indexes.planet.getAll().length.should.equal(2);\r\n              db.indexes.planet.unique.should.equal(true);\r\n              db.indexes.planet.sparse.should.equal(false);\r\n              \r\n              db.insert({ planet: \"Jupiter\" }, function (err) {\r\n                assert.isNull(err);\r\n\r\n                // After a reload the indexes are recreated\r\n                db = new Datastore({ filename: persDb });\r\n                db.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n                  Object.keys(db.indexes).length.should.equal(2);\r\n                  Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                  Object.keys(db.indexes)[1].should.equal(\"planet\");                \r\n                  db.indexes._id.getAll().length.should.equal(3);\r\n                  db.indexes.planet.getAll().length.should.equal(3);\r\n                  db.indexes.planet.unique.should.equal(true);\r\n                  db.indexes.planet.sparse.should.equal(false);\r\n                  \r\n                  db.ensureIndex({ fieldName: 'bloup', unique: false, sparse: true }, function (err) {\r\n                    assert.isNull(err);\r\n                    Object.keys(db.indexes).length.should.equal(3);\r\n                    Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                    Object.keys(db.indexes)[1].should.equal(\"planet\");\r\n                    Object.keys(db.indexes)[2].should.equal(\"bloup\");\r\n                    db.indexes._id.getAll().length.should.equal(3);\r\n                    db.indexes.planet.getAll().length.should.equal(3);\r\n                    db.indexes.bloup.getAll().length.should.equal(0);\r\n                    db.indexes.planet.unique.should.equal(true);\r\n                    db.indexes.planet.sparse.should.equal(false);                  \r\n                    db.indexes.bloup.unique.should.equal(false);\r\n                    db.indexes.bloup.sparse.should.equal(true);                  \r\n\r\n                    // After another reload the indexes are still there (i.e. they are preserved during autocompaction)\r\n                    db = new Datastore({ filename: persDb });\r\n                    db.loadDatabase(function (err) {\r\n                      assert.isNull(err);\r\n                      Object.keys(db.indexes).length.should.equal(3);\r\n                      Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                      Object.keys(db.indexes)[1].should.equal(\"planet\");\r\n                      Object.keys(db.indexes)[2].should.equal(\"bloup\");\r\n                      db.indexes._id.getAll().length.should.equal(3);\r\n                      db.indexes.planet.getAll().length.should.equal(3);\r\n                      db.indexes.bloup.getAll().length.should.equal(0);\r\n                      db.indexes.planet.unique.should.equal(true);\r\n                      db.indexes.planet.sparse.should.equal(false);\r\n                      db.indexes.bloup.unique.should.equal(false);\r\n                      db.indexes.bloup.sparse.should.equal(true);\r\n                  \r\n                      done();                \r\n                    });\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n    \r\n      it('Indexes can also be removed and the remove persisted', function (done) {\r\n        var persDb = \"workspace/persistIndexes.db\"\r\n          , db\r\n          ;\r\n        \r\n        if (fs.existsSync(persDb)) { fs.writeFileSync(persDb, '', 'utf8'); }\r\n        db = new Datastore({ filename: persDb, autoload: true });\r\n        \r\n        Object.keys(db.indexes).length.should.equal(1);\r\n        Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n        \r\n        db.insert({ planet: \"Earth\" }, function (err) {\r\n          assert.isNull(err);\r\n          db.insert({ planet: \"Mars\" }, function (err) {\r\n            assert.isNull(err);\r\n            \r\n            db.ensureIndex({ fieldName: \"planet\" }, function (err) {\r\n              assert.isNull(err);\r\n              db.ensureIndex({ fieldName: \"another\" }, function (err) {\r\n                assert.isNull(err);\r\n                Object.keys(db.indexes).length.should.equal(3);\r\n                Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                Object.keys(db.indexes)[1].should.equal(\"planet\");\r\n                Object.keys(db.indexes)[2].should.equal(\"another\");\r\n                db.indexes._id.getAll().length.should.equal(2);\r\n                db.indexes.planet.getAll().length.should.equal(2);\r\n                db.indexes.planet.fieldName.should.equal(\"planet\");\r\n                \r\n                // After a reload the indexes are recreated\r\n                db = new Datastore({ filename: persDb });\r\n                db.loadDatabase(function (err) {\r\n                  assert.isNull(err);\r\n                  Object.keys(db.indexes).length.should.equal(3);\r\n                  Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                  Object.keys(db.indexes)[1].should.equal(\"planet\");  \r\n                  Object.keys(db.indexes)[2].should.equal(\"another\");                 \r\n                  db.indexes._id.getAll().length.should.equal(2);\r\n                  db.indexes.planet.getAll().length.should.equal(2);\r\n                  db.indexes.planet.fieldName.should.equal(\"planet\");\r\n                  \r\n                  // Index is removed\r\n                  db.removeIndex(\"planet\", function (err) {\r\n                    assert.isNull(err);\r\n                    Object.keys(db.indexes).length.should.equal(2);\r\n                    Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                    Object.keys(db.indexes)[1].should.equal(\"another\");\r\n                    db.indexes._id.getAll().length.should.equal(2);\r\n\r\n                    // After a reload indexes are preserved\r\n                    db = new Datastore({ filename: persDb });\r\n                    db.loadDatabase(function (err) {\r\n                      assert.isNull(err);\r\n                      Object.keys(db.indexes).length.should.equal(2);\r\n                      Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                      Object.keys(db.indexes)[1].should.equal(\"another\");\r\n                      db.indexes._id.getAll().length.should.equal(2);\r\n                  \r\n                      // After another reload the indexes are still there (i.e. they are preserved during autocompaction)\r\n                      db = new Datastore({ filename: persDb });\r\n                      db.loadDatabase(function (err) {\r\n                        assert.isNull(err);\r\n                        Object.keys(db.indexes).length.should.equal(2);\r\n                        Object.keys(db.indexes)[0].should.equal(\"_id\");\r\n                        Object.keys(db.indexes)[1].should.equal(\"another\");\r\n                        db.indexes._id.getAll().length.should.equal(2);\r\n                    \r\n                        done();                \r\n                      });\r\n                    });\r\n                  });\r\n                });\r\n              });\r\n            });\r\n          });\r\n        });\r\n      });\r\n      \r\n    });   // ==== End of 'Persisting indexes' ====    \r\n\r\n  });   // ==== End of 'Using indexes' ==== //\r\n\r\n\r\n});\r\n","var Index = require('../lib/indexes')\r\n  , customUtils = require('../lib/customUtils')\r\n  , should = require('chai').should()\r\n  , assert = require('chai').assert\r\n  , _ = require('underscore')\r\n  , async = require('async')\r\n  , model = require('../lib/model')\r\n  ;\r\n\r\ndescribe('Indexes', function () {\r\n\r\n  describe('Insertion', function () {\r\n\r\n    it('Can insert pointers to documents in the index correctly when they have the field', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      // The underlying BST now has 3 nodes which contain the docs where it's expected\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), [{ a: 5, tf: 'hello' }]);\r\n      assert.deepEqual(idx.tree.search('world'), [{ a: 8, tf: 'world' }]);\r\n      assert.deepEqual(idx.tree.search('bloup'), [{ a: 2, tf: 'bloup' }]);\r\n\r\n      // The nodes contain pointers to the actual documents\r\n      idx.tree.search('world')[0].should.equal(doc2);\r\n      idx.tree.search('bloup')[0].a = 42;\r\n      doc3.a.should.equal(42);\r\n    });\r\n\r\n    it('Inserting twice for the same fieldName in a unique index will result in an error thrown', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.tree.getNumberOfKeys().should.equal(1);\r\n      (function () { idx.insert(doc1); }).should.throw();\r\n    });\r\n\r\n    it('Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown', function () {\r\n      var idx = new Index({ fieldName: 'nope', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 5, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.tree.getNumberOfKeys().should.equal(1);\r\n      (function () { idx.insert(doc2); }).should.throw();\r\n    });\r\n\r\n    it('Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed', function () {\r\n      var idx = new Index({ fieldName: 'nope', unique: true, sparse: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 5, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.tree.getNumberOfKeys().should.equal(0);   // Docs are not indexed\r\n    });\r\n\r\n    it('Works with dot notation', function () {\r\n      var idx = new Index({ fieldName: 'tf.nested' })\r\n        , doc1 = { a: 5, tf: { nested: 'hello' } }\r\n        , doc2 = { a: 8, tf: { nested: 'world', additional: true } }\r\n        , doc3 = { a: 2, tf: { nested: 'bloup', age: 42 } }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      // The underlying BST now has 3 nodes which contain the docs where it's expected\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), [doc1]);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n      assert.deepEqual(idx.tree.search('bloup'), [doc3]);\r\n\r\n      // The nodes contain pointers to the actual documents\r\n      idx.tree.search('bloup')[0].a = 42;\r\n      doc3.a.should.equal(42);\r\n    });\r\n\r\n    it('Can insert an array of documents', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert([doc1, doc2, doc3]);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), [doc1]);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n      assert.deepEqual(idx.tree.search('bloup'), [doc3]);\r\n    });\r\n\r\n    it('When inserting an array of elements, if an error is thrown all inserts need to be rolled back', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc2b = { a: 84, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      try {\r\n        idx.insert([doc1, doc2, doc2b, doc3]);\r\n      } catch (e) {\r\n        e.errorType.should.equal('uniqueViolated');\r\n      }\r\n      idx.tree.getNumberOfKeys().should.equal(0);\r\n      assert.deepEqual(idx.tree.search('hello'), []);\r\n      assert.deepEqual(idx.tree.search('world'), []);\r\n      assert.deepEqual(idx.tree.search('bloup'), []);\r\n    });\r\n\t\r\n\tdescribe('Array fields', function () {\r\n\t\r\n\t  it('Inserts one entry per array element in the index', function () {\r\n      var obj = { tf: ['aa', 'bb'], really: 'yeah' }\r\n        , obj2 = { tf: 'normal', yes: 'indeed' }\r\n        , idx = new Index({ fieldName: 'tf' })\r\n        ;\r\n      \r\n      idx.insert(obj);\r\n      idx.getAll().length.should.equal(2);\r\n      idx.getAll()[0].should.equal(obj);\r\n      idx.getAll()[1].should.equal(obj);\r\n\r\n      idx.insert(obj2);\r\n      idx.getAll().length.should.equal(3);\r\n\t  });\r\n\r\n\t  it('Inserts one entry per array element in the index, type-checked', function () {\r\n      var obj = { tf: ['42', 42, new Date(42), 42], really: 'yeah' }\r\n        , idx = new Index({ fieldName: 'tf' })\r\n        ;\r\n      \r\n      idx.insert(obj);\r\n      idx.getAll().length.should.equal(3);\r\n      idx.getAll()[0].should.equal(obj);\r\n      idx.getAll()[1].should.equal(obj);\r\n      idx.getAll()[2].should.equal(obj);\r\n\t  });\r\n    \r\n\t  it('Inserts one entry per unique array element in the index, the unique constraint only holds across documents', function () {\r\n      var obj = { tf: ['aa', 'aa'], really: 'yeah' }\r\n        , obj2 = { tf: ['cc', 'yy', 'cc'], yes: 'indeed' }\r\n        , idx = new Index({ fieldName: 'tf', unique: true })\r\n        ;\r\n      \r\n      idx.insert(obj);\r\n      idx.getAll().length.should.equal(1);\r\n      idx.getAll()[0].should.equal(obj);\r\n\r\n      idx.insert(obj2);\r\n      idx.getAll().length.should.equal(3);\r\n\t  });\r\n\r\n\t  it('The unique constraint holds across documents', function () {\r\n      var obj = { tf: ['aa', 'aa'], really: 'yeah' }\r\n        , obj2 = { tf: ['cc', 'aa', 'cc'], yes: 'indeed' }\r\n        , idx = new Index({ fieldName: 'tf', unique: true })\r\n        ;\r\n      \r\n      idx.insert(obj);\r\n      idx.getAll().length.should.equal(1);\r\n      idx.getAll()[0].should.equal(obj);\r\n\r\n      (function () { idx.insert(obj2); }).should.throw();\r\n\t  });\r\n    \r\n    it('When removing a document, remove it from the index at all unique array elements', function () {\r\n      var obj = { tf: ['aa', 'aa'], really: 'yeah' }\r\n        , obj2 = { tf: ['cc', 'aa', 'cc'], yes: 'indeed' }\r\n        , idx = new Index({ fieldName: 'tf' })\r\n        ;\r\n      \r\n      idx.insert(obj);\r\n      idx.insert(obj2);\r\n      idx.getMatching('aa').length.should.equal(2);\r\n      idx.getMatching('aa').indexOf(obj).should.not.equal(-1);\r\n      idx.getMatching('aa').indexOf(obj2).should.not.equal(-1);\r\n      idx.getMatching('cc').length.should.equal(1);\r\n\r\n      idx.remove(obj2);\r\n      idx.getMatching('aa').length.should.equal(1);\r\n      idx.getMatching('aa').indexOf(obj).should.not.equal(-1);\r\n      idx.getMatching('aa').indexOf(obj2).should.equal(-1);\r\n      idx.getMatching('cc').length.should.equal(0);      \r\n    });\r\n    \r\n    it('If a unique constraint is violated when inserting an array key, roll back all inserts before the key', function () {\r\n      var obj = { tf: ['aa', 'bb'], really: 'yeah' }\r\n        , obj2 = { tf: ['cc', 'dd', 'aa', 'ee'], yes: 'indeed' }\r\n        , idx = new Index({ fieldName: 'tf', unique: true })\r\n        ;\r\n\r\n      idx.insert(obj);\r\n      idx.getAll().length.should.equal(2);\r\n      idx.getMatching('aa').length.should.equal(1);\r\n      idx.getMatching('bb').length.should.equal(1);\r\n      idx.getMatching('cc').length.should.equal(0);\r\n      idx.getMatching('dd').length.should.equal(0);\r\n      idx.getMatching('ee').length.should.equal(0);\r\n      \r\n      (function () { idx.insert(obj2); }).should.throw();\r\n      idx.getAll().length.should.equal(2);\r\n      idx.getMatching('aa').length.should.equal(1);\r\n      idx.getMatching('bb').length.should.equal(1);\r\n      idx.getMatching('cc').length.should.equal(0);\r\n      idx.getMatching('dd').length.should.equal(0);      \r\n      idx.getMatching('ee').length.should.equal(0);\r\n    });\r\n\t\r\n\t});   // ==== End of 'Array fields' ==== //\r\n\r\n  });   // ==== End of 'Insertion' ==== //\r\n\r\n\r\n  describe('Removal', function () {\r\n\r\n    it('Can remove pointers from the index, even when multiple documents have the same key', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc4 = { a: 23, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n\r\n      idx.remove(doc1);\r\n      idx.tree.getNumberOfKeys().should.equal(2);\r\n      idx.tree.search('hello').length.should.equal(0);\r\n\r\n      idx.remove(doc2);\r\n      idx.tree.getNumberOfKeys().should.equal(2);\r\n      idx.tree.search('world').length.should.equal(1);\r\n      idx.tree.search('world')[0].should.equal(doc4);\r\n    });\r\n\r\n    it('If we have a sparse index, removing a non indexed doc has no effect', function () {\r\n      var idx = new Index({ fieldName: 'nope', sparse: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 5, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.tree.getNumberOfKeys().should.equal(0);\r\n\r\n      idx.remove(doc1);\r\n      idx.tree.getNumberOfKeys().should.equal(0);\r\n    });\r\n\r\n    it('Works with dot notation', function () {\r\n      var idx = new Index({ fieldName: 'tf.nested' })\r\n        , doc1 = { a: 5, tf: { nested: 'hello' } }\r\n        , doc2 = { a: 8, tf: { nested: 'world', additional: true } }\r\n        , doc3 = { a: 2, tf: { nested: 'bloup', age: 42 } }\r\n        , doc4 = { a: 2, tf: { nested: 'world', fruits: ['apple', 'carrot'] } }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n\r\n      idx.remove(doc1);\r\n      idx.tree.getNumberOfKeys().should.equal(2);\r\n      idx.tree.search('hello').length.should.equal(0);\r\n\r\n      idx.remove(doc2);\r\n      idx.tree.getNumberOfKeys().should.equal(2);\r\n      idx.tree.search('world').length.should.equal(1);\r\n      idx.tree.search('world')[0].should.equal(doc4);\r\n    });\r\n\r\n    it('Can remove an array of documents', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert([doc1, doc2, doc3]);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.remove([doc1, doc3]);\r\n      idx.tree.getNumberOfKeys().should.equal(1);\r\n      assert.deepEqual(idx.tree.search('hello'), []);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n      assert.deepEqual(idx.tree.search('bloup'), []);\r\n    });\r\n\r\n  });   // ==== End of 'Removal' ==== //\r\n\r\n\r\n  describe('Update', function () {\r\n\r\n    it('Can update a document whose key did or didnt change', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc4 = { a: 23, tf: 'world' }\r\n        , doc5 = { a: 1, tf: 'changed' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n\r\n      idx.update(doc2, doc4);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('world'), [doc4]);\r\n\r\n      idx.update(doc1, doc5);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), []);\r\n      assert.deepEqual(idx.tree.search('changed'), [doc5]);\r\n    });\r\n\r\n    it('If a simple update violates a unique constraint, changes are rolled back and an error thrown', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , bad = { a: 23, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), [doc1]);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n      assert.deepEqual(idx.tree.search('bloup'), [doc3]);\r\n\r\n      try {\r\n        idx.update(doc3, bad);\r\n      } catch (e) {\r\n        e.errorType.should.equal('uniqueViolated');\r\n      }\r\n\r\n      // No change\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('hello'), [doc1]);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n      assert.deepEqual(idx.tree.search('bloup'), [doc3]);\r\n    });\r\n\r\n    it('Can update an array of documents', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc1b = { a: 23, tf: 'world' }\r\n        , doc2b = { a: 1, tf: 'changed' }\r\n        , doc3b = { a: 44, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n\r\n      idx.update([{ oldDoc: doc1, newDoc: doc1b }, { oldDoc: doc2, newDoc: doc2b }, { oldDoc: doc3, newDoc: doc3b }]);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc1b);\r\n      idx.getMatching('changed').length.should.equal(1);\r\n      idx.getMatching('changed')[0].should.equal(doc2b);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3b);\r\n    });\r\n\r\n    it('If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc0 = { a: 432, tf: 'notthistoo' }\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc1b = { a: 23, tf: 'changed' }\r\n        , doc2b = { a: 1, tf: 'changed' }   // Will violate the constraint (first try)\r\n        , doc2c = { a: 1, tf: 'notthistoo' }   // Will violate the constraint (second try)\r\n        , doc3b = { a: 44, tf: 'alsochanged' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n\r\n      try {\r\n        idx.update([{ oldDoc: doc1, newDoc: doc1b }, { oldDoc: doc2, newDoc: doc2b }, { oldDoc: doc3, newDoc: doc3b }]);\r\n      } catch (e) {\r\n        e.errorType.should.equal('uniqueViolated');\r\n      }\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('hello')[0].should.equal(doc1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc2);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3);\r\n\r\n      try {\r\n        idx.update([{ oldDoc: doc1, newDoc: doc1b }, { oldDoc: doc2, newDoc: doc2b }, { oldDoc: doc3, newDoc: doc3b }]);\r\n      } catch (e) {\r\n        e.errorType.should.equal('uniqueViolated');\r\n      }\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('hello')[0].should.equal(doc1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc2);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3);\r\n    });\r\n\r\n    it('If an update doesnt change a document, the unique constraint is not violated', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , noChange = { a: 8, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('world'), [doc2]);\r\n\r\n      idx.update(doc2, noChange);   // No error thrown\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      assert.deepEqual(idx.tree.search('world'), [noChange]);\r\n    });\r\n\r\n    it('Can revert simple and batch updates', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc1b = { a: 23, tf: 'world' }\r\n        , doc2b = { a: 1, tf: 'changed' }\r\n        , doc3b = { a: 44, tf: 'bloup' }\r\n        , batchUpdate = [{ oldDoc: doc1, newDoc: doc1b }, { oldDoc: doc2, newDoc: doc2b }, { oldDoc: doc3, newDoc: doc3b }]\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n\r\n      idx.update(batchUpdate);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc1b);\r\n      idx.getMatching('changed').length.should.equal(1);\r\n      idx.getMatching('changed')[0].should.equal(doc2b);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3b);\r\n\r\n      idx.revertUpdate(batchUpdate);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('hello')[0].should.equal(doc1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc2);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3);\r\n\r\n      // Now a simple update\r\n      idx.update(doc2, doc2b);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('hello')[0].should.equal(doc1);\r\n      idx.getMatching('changed').length.should.equal(1);\r\n      idx.getMatching('changed')[0].should.equal(doc2b);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3);\r\n\r\n      idx.revertUpdate(doc2, doc2b);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('hello')[0].should.equal(doc1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('world')[0].should.equal(doc2);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n      idx.getMatching('bloup')[0].should.equal(doc3);\r\n    });\r\n\r\n  });   // ==== End of 'Update' ==== //\r\n\r\n\r\n  describe('Get matching documents', function () {\r\n\r\n    it('Get all documents where fieldName is equal to the given value, or an empty array if no match', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , doc4 = { a: 23, tf: 'world' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc2, doc4]);\r\n      assert.deepEqual(idx.getMatching('nope'), []);\r\n    });\r\n\r\n    it('Can get all documents for a given key in a unique index', function () {\r\n      var idx = new Index({ fieldName: 'tf', unique: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc2]);\r\n      assert.deepEqual(idx.getMatching('nope'), []);\r\n    });\r\n\r\n    it('Can get all documents for which a field is undefined', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 2, nottf: 'bloup' }\r\n        , doc3 = { a: 8, tf: 'world' }\r\n        , doc4 = { a: 7, nottf: 'yes' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), []);\r\n      assert.deepEqual(idx.getMatching('hello'), [doc1]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('yes'), []);\r\n      assert.deepEqual(idx.getMatching(undefined), [doc2]);\r\n\r\n      idx.insert(doc4);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), []);\r\n      assert.deepEqual(idx.getMatching('hello'), [doc1]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('yes'), []);\r\n      assert.deepEqual(idx.getMatching(undefined), [doc2, doc4]);\r\n    });\r\n\r\n    it('Can get all documents for which a field is null', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 2, tf: null }\r\n        , doc3 = { a: 8, tf: 'world' }\r\n        , doc4 = { a: 7, tf: null }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), []);\r\n      assert.deepEqual(idx.getMatching('hello'), [doc1]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('yes'), []);\r\n      assert.deepEqual(idx.getMatching(null), [doc2]);\r\n\r\n      idx.insert(doc4);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), []);\r\n      assert.deepEqual(idx.getMatching('hello'), [doc1]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('yes'), []);\r\n      assert.deepEqual(idx.getMatching(null), [doc2, doc4]);\r\n    });\r\n\r\n    it('Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)', function () {\r\n      var idx = new Index({ fieldName: 'tf', sparse: true })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 2, nottf: 'bloup' }\r\n        , doc3 = { a: 8, tf: 'world' }\r\n        , doc4 = { a: 7, nottf: 'yes' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n\r\n      assert.deepEqual(idx.getMatching('bloup'), []);\r\n      assert.deepEqual(idx.getMatching('hello'), [doc1]);\r\n      assert.deepEqual(idx.getMatching('world'), [doc3]);\r\n      assert.deepEqual(idx.getMatching('yes'), []);\r\n      assert.deepEqual(idx.getMatching(undefined), []);\r\n    });\r\n\r\n    it('Can get all documents whose key is in an array of keys', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 2, tf: 'bloup' }\r\n        , doc3 = { a: 8, tf: 'world' }\r\n        , doc4 = { a: 7, tf: 'yes' }\r\n        , doc5 = { a: 7, tf: 'yes' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n      idx.insert(doc5);\r\n\r\n      assert.deepEqual(idx.getMatching([]), []);\r\n      assert.deepEqual(idx.getMatching(['bloup']), [doc2]);\r\n      assert.deepEqual(idx.getMatching(['bloup', 'yes']), [doc2, doc4, doc5]);\r\n      assert.deepEqual(idx.getMatching(['hello', 'no']), [doc1]);\r\n      assert.deepEqual(idx.getMatching(['nope', 'no']), []);\r\n    });\r\n\r\n    it('Can get all documents whose key is between certain bounds', function () {\r\n      var idx = new Index({ fieldName: 'a' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 2, tf: 'bloup' }\r\n        , doc3 = { a: 8, tf: 'world' }\r\n        , doc4 = { a: 7, tf: 'yes' }\r\n        , doc5 = { a: 10, tf: 'yes' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n      idx.insert(doc4);\r\n      idx.insert(doc5);\r\n\r\n      assert.deepEqual(idx.getBetweenBounds({ $lt: 10, $gte: 5 }), [ doc1, doc4, doc3 ]);\r\n      assert.deepEqual(idx.getBetweenBounds({ $lte: 8 }), [ doc2, doc1, doc4, doc3 ]);\r\n      assert.deepEqual(idx.getBetweenBounds({ $gt: 7 }), [ doc3, doc5 ]);\r\n    });\r\n\r\n  });   // ==== End of 'Get matching documents' ==== //\r\n\r\n\r\n  describe('Resetting', function () {\r\n\r\n    it('Can reset an index without any new data, the index will be empty afterwards', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n\r\n      idx.reset();\r\n      idx.tree.getNumberOfKeys().should.equal(0);\r\n      idx.getMatching('hello').length.should.equal(0);\r\n      idx.getMatching('world').length.should.equal(0);\r\n      idx.getMatching('bloup').length.should.equal(0);\r\n    });\r\n\r\n    it('Can reset an index and initialize it with one document', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , newDoc = { a: 555, tf: 'new' }\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n\r\n      idx.reset(newDoc);\r\n      idx.tree.getNumberOfKeys().should.equal(1);\r\n      idx.getMatching('hello').length.should.equal(0);\r\n      idx.getMatching('world').length.should.equal(0);\r\n      idx.getMatching('bloup').length.should.equal(0);\r\n      idx.getMatching('new')[0].a.should.equal(555);\r\n    });\r\n\r\n    it('Can reset an index and initialize it with an array of documents', function () {\r\n      var idx = new Index({ fieldName: 'tf' })\r\n        , doc1 = { a: 5, tf: 'hello' }\r\n        , doc2 = { a: 8, tf: 'world' }\r\n        , doc3 = { a: 2, tf: 'bloup' }\r\n        , newDocs = [{ a: 555, tf: 'new' }, { a: 666, tf: 'again' }]\r\n        ;\r\n\r\n      idx.insert(doc1);\r\n      idx.insert(doc2);\r\n      idx.insert(doc3);\r\n\r\n      idx.tree.getNumberOfKeys().should.equal(3);\r\n      idx.getMatching('hello').length.should.equal(1);\r\n      idx.getMatching('world').length.should.equal(1);\r\n      idx.getMatching('bloup').length.should.equal(1);\r\n\r\n      idx.reset(newDocs);\r\n      idx.tree.getNumberOfKeys().should.equal(2);\r\n      idx.getMatching('hello').length.should.equal(0);\r\n      idx.getMatching('world').length.should.equal(0);\r\n      idx.getMatching('bloup').length.should.equal(0);\r\n      idx.getMatching('new')[0].a.should.equal(555);\r\n      idx.getMatching('again')[0].a.should.equal(666);\r\n    });\r\n\r\n  });   // ==== End of 'Resetting' ==== //\r\n\r\n  it('Get all elements in the index', function () {\r\n    var idx = new Index({ fieldName: 'a' })\r\n      , doc1 = { a: 5, tf: 'hello' }\r\n      , doc2 = { a: 8, tf: 'world' }\r\n      , doc3 = { a: 2, tf: 'bloup' }\r\n      ;\r\n\r\n    idx.insert(doc1);\r\n    idx.insert(doc2);\r\n    idx.insert(doc3);\r\n\r\n    assert.deepEqual(idx.getAll(), [{ a: 2, tf: 'bloup' }, { a: 5, tf: 'hello' }, { a: 8, tf: 'world' }]);\r\n  });\r\n\r\n\r\n});\r\n","var model = require('../lib/model')\r\n  , should = require('chai').should()\r\n  , assert = require('chai').assert\r\n  , _ = require('underscore')\r\n  , async = require('async')\r\n  , util = require('util')\r\n  , Datastore = require('../lib/datastore')\r\n  , fs = require('fs')\r\n  ;\r\n\r\n\r\ndescribe('Model', function () {\r\n\r\n  describe('Serialization, deserialization', function () {\r\n\r\n    it('Can serialize and deserialize strings', function () {\r\n      var a, b, c;\r\n\r\n      a = { test: \"Some string\" };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test.should.equal(\"Some string\");\r\n\r\n      // Even if a property is a string containing a new line, the serialized\r\n      // version doesn't. The new line must still be there upon deserialization\r\n      a = { test: \"With a new\\nline\" };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      c.test.should.equal(\"With a new\\nline\");\r\n      a.test.indexOf('\\n').should.not.equal(-1);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test.indexOf('\\n').should.not.equal(-1);\r\n    });\r\n\r\n    it('Can serialize and deserialize booleans', function () {\r\n      var a, b, c;\r\n\r\n      a = { test: true };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test.should.equal(true);\r\n    });\r\n\r\n    it('Can serialize and deserialize numbers', function () {\r\n      var a, b, c;\r\n\r\n      a = { test: 5 };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test.should.equal(5);\r\n    });\r\n\r\n    it('Can serialize and deserialize null', function () {\r\n      var a, b, c;\r\n\r\n      a = { test: null };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      assert.isNull(a.test);\r\n    });\r\n\r\n    it('undefined fields are removed when serialized', function() {\r\n      var a = { bloup: undefined, hello: 'world' }\r\n        , b = model.serialize(a)\r\n        , c = model.deserialize(b)\r\n        ;\r\n\r\n      Object.keys(c).length.should.equal(1);\r\n      c.hello.should.equal('world');\r\n      assert.isUndefined(c.bloup);\r\n    });\r\n\r\n    it('Can serialize and deserialize a date', function () {\r\n      var a, b, c\r\n        , d = new Date();\r\n\r\n      a = { test: d };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      util.isDate(c.test).should.equal(true);\r\n      c.test.getTime().should.equal(d.getTime());\r\n    });\r\n\r\n    it('Can serialize and deserialize sub objects', function () {\r\n      var a, b, c\r\n        , d = new Date();\r\n\r\n      a = { test: { something: 39, also: d, yes: { again: 'yes' } } };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test.something.should.equal(39);\r\n      c.test.also.getTime().should.equal(d.getTime());\r\n      c.test.yes.again.should.equal('yes');\r\n    });\r\n\r\n    it('Can serialize and deserialize sub arrays', function () {\r\n      var a, b, c\r\n        , d = new Date();\r\n\r\n      a = { test: [ 39, d, { again: 'yes' } ] };\r\n      b = model.serialize(a);\r\n      c = model.deserialize(b);\r\n      b.indexOf('\\n').should.equal(-1);\r\n      c.test[0].should.equal(39);\r\n      c.test[1].getTime().should.equal(d.getTime());\r\n      c.test[2].again.should.equal('yes');\r\n    });\r\n\r\n    it('Reject field names beginning with a $ sign or containing a dot, except the four edge cases', function () {\r\n      var a1 = { $something: 'totest' }\r\n        , a2 = { \"with.dot\": 'totest' }\r\n        , e1 = { $$date: 4321 }\r\n        , e2 = { $$deleted: true }\r\n        , e3 = { $$indexCreated: \"indexName\" }\r\n        , e4 = { $$indexRemoved: \"indexName\" }\r\n        , b;\r\n\r\n      // Normal cases\r\n      (function () { b = model.serialize(a1); }).should.throw();\r\n      (function () { b = model.serialize(a2); }).should.throw();\r\n\r\n      // Edge cases\r\n      b = model.serialize(e1);\r\n      b = model.serialize(e2);\r\n      b = model.serialize(e3);\r\n      b = model.serialize(e4);\r\n    });\r\n    \r\n    it('Can serialize string fields with a new line without breaking the DB', function (done) {\r\n      var db1, db2\r\n        , badString = \"world\\r\\nearth\\nother\\rline\"\r\n        ;\r\n      \r\n      if (fs.existsSync('workspace/test1.db')) { fs.unlinkSync('workspace/test1.db'); }\r\n      fs.existsSync('workspace/test1.db').should.equal(false);\r\n      db1 = new Datastore({ filename: 'workspace/test1.db' });\r\n      \r\n      db1.loadDatabase(function (err) {\r\n        assert.isNull(err);\r\n        db1.insert({ hello: badString }, function (err) {\r\n          assert.isNull(err);\r\n        \r\n          db2 = new Datastore({ filename: 'workspace/test1.db' });\r\n          db2.loadDatabase(function (err) {\r\n            assert.isNull(err);\r\n            db2.find({}, function (err, docs) {\r\n              assert.isNull(err);\r\n              docs.length.should.equal(1);\r\n              docs[0].hello.should.equal(badString);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n  });   // ==== End of 'Serialization, deserialization' ==== //\r\n\r\n\r\n  describe('Object checking', function () {\r\n\r\n    it('Field names beginning with a $ sign are forbidden', function () {\r\n      assert.isDefined(model.checkObject);\r\n\r\n      (function () {\r\n        model.checkObject({ $bad: true });\r\n      }).should.throw();\r\n\r\n      (function () {\r\n        model.checkObject({ some: 42, nested: { again: \"no\", $worse: true } });\r\n      }).should.throw();\r\n\r\n      // This shouldn't throw since \"$actuallyok\" is not a field name\r\n      model.checkObject({ some: 42, nested: [ 5, \"no\", \"$actuallyok\", true ] });\r\n\r\n      (function () {\r\n        model.checkObject({ some: 42, nested: [ 5, \"no\", \"$actuallyok\", true, { $hidden: \"useless\" } ] });\r\n      }).should.throw();\r\n    });\r\n\r\n    it('Field names cannot contain a .', function () {\r\n      assert.isDefined(model.checkObject);\r\n\r\n      (function () {\r\n        model.checkObject({ \"so.bad\": true });\r\n      }).should.throw();\r\n\r\n      // Recursive behaviour testing done in the above test on $ signs\r\n    });\r\n\r\n    it('Properties with a null value dont trigger an error', function () {\r\n      var obj = { prop: null };\r\n\r\n      model.checkObject(obj);\r\n    });\r\n    \r\n    it('Can check if an object is a primitive or not', function () {\r\n      model.isPrimitiveType(5).should.equal(true);\r\n      model.isPrimitiveType('sdsfdfs').should.equal(true);\r\n      model.isPrimitiveType(0).should.equal(true);\r\n      model.isPrimitiveType(true).should.equal(true);\r\n      model.isPrimitiveType(false).should.equal(true);\r\n      model.isPrimitiveType(new Date()).should.equal(true);\r\n      model.isPrimitiveType([]).should.equal(true);\r\n      model.isPrimitiveType([3, 'try']).should.equal(true);\r\n      model.isPrimitiveType(null).should.equal(true);\r\n\r\n      model.isPrimitiveType({}).should.equal(false);\r\n      model.isPrimitiveType({ a: 42 }).should.equal(false);\r\n    });\r\n\r\n  });   // ==== End of 'Object checking' ==== //\r\n\r\n\r\n  describe('Deep copying', function () {\r\n\r\n    it('Should be able to deep copy any serializable model', function () {\r\n      var d = new Date()\r\n        , obj = { a: ['ee', 'ff', 42], date: d, subobj: { a: 'b', b: 'c' } }\r\n        , res = model.deepCopy(obj);\r\n        ;\r\n\r\n      res.a.length.should.equal(3);\r\n      res.a[0].should.equal('ee');\r\n      res.a[1].should.equal('ff');\r\n      res.a[2].should.equal(42);\r\n      res.date.getTime().should.equal(d.getTime());\r\n      res.subobj.a.should.equal('b');\r\n      res.subobj.b.should.equal('c');\r\n\r\n      obj.a.push('ggg');\r\n      obj.date = 'notadate';\r\n      obj.subobj = [];\r\n\r\n      // Even if the original object is modified, the copied one isn't\r\n      res.a.length.should.equal(3);\r\n      res.a[0].should.equal('ee');\r\n      res.a[1].should.equal('ff');\r\n      res.a[2].should.equal(42);\r\n      res.date.getTime().should.equal(d.getTime());\r\n      res.subobj.a.should.equal('b');\r\n      res.subobj.b.should.equal('c');\r\n    });\r\n\r\n  });   // ==== End of 'Deep copying' ==== //\r\n  \r\n\r\n  describe('Modifying documents', function () {\r\n\r\n    it('Queries not containing any modifier just replace the document by the contents of the query but keep its _id', function () {\r\n      var obj = { some: 'thing', _id: 'keepit' }\r\n        , updateQuery = { replace: 'done', bloup: [ 1, 8] }\r\n        , t\r\n        ;\r\n\r\n      t = model.modify(obj, updateQuery);\r\n      t.replace.should.equal('done');\r\n      t.bloup.length.should.equal(2);\r\n      t.bloup[0].should.equal(1);\r\n      t.bloup[1].should.equal(8);\r\n\r\n      assert.isUndefined(t.some);\r\n      t._id.should.equal('keepit');\r\n    });\r\n\r\n    it('Throw an error if trying to change the _id field in a copy-type modification', function () {\r\n      var obj = { some: 'thing', _id: 'keepit' }\r\n        , updateQuery = { replace: 'done', bloup: [ 1, 8], _id: 'donttryit' }\r\n        ;\r\n\r\n      (function () {\r\n        model.modify(obj, updateQuery);\r\n      }).should.throw();\r\n\r\n      updateQuery._id = 'keepit';\r\n      model.modify(obj, updateQuery);   // No error thrown\r\n    });\r\n\r\n    it('Throw an error if trying to use modify in a mixed copy+modify way', function () {\r\n      var obj = { some: 'thing' }\r\n        , updateQuery = { replace: 'me', $modify: 'metoo' };\r\n\r\n      (function () {\r\n        model.modify(obj, updateQuery);\r\n      }).should.throw();\r\n    });\r\n\r\n    it('Throw an error if trying to use an inexistent modifier', function () {\r\n      var obj = { some: 'thing' }\r\n        , updateQuery = { $set: 'this exists', $modify: 'not this one' };\r\n\r\n      (function () {\r\n        model.modify(obj, updateQuery);\r\n      }).should.throw();\r\n    });\r\n\r\n    it('Throw an error if a modifier is used with a non-object argument', function () {\r\n      var obj = { some: 'thing' }\r\n        , updateQuery = { $set: 'this exists' };\r\n\r\n      (function () {\r\n        model.modify(obj, updateQuery);\r\n      }).should.throw();\r\n    });\r\n\r\n    describe('$set modifier', function () {\r\n      it('Can change already set fields without modfifying the underlying object', function () {\r\n        var obj = { some: 'thing', yup: 'yes', nay: 'noes' }\r\n          , updateQuery = { $set: { some: 'changed', nay: 'yes indeed' } }\r\n          , modified = model.modify(obj, updateQuery);\r\n\r\n        Object.keys(modified).length.should.equal(3);\r\n        modified.some.should.equal('changed');\r\n        modified.yup.should.equal('yes');\r\n        modified.nay.should.equal('yes indeed');\r\n\r\n        Object.keys(obj).length.should.equal(3);\r\n        obj.some.should.equal('thing');\r\n        obj.yup.should.equal('yes');\r\n        obj.nay.should.equal('noes');\r\n      });\r\n\r\n      it('Creates fields to set if they dont exist yet', function () {\r\n        var obj = { yup: 'yes' }\r\n          , updateQuery = { $set: { some: 'changed', nay: 'yes indeed' } }\r\n          , modified = model.modify(obj, updateQuery);\r\n\r\n        Object.keys(modified).length.should.equal(3);\r\n        modified.some.should.equal('changed');\r\n        modified.yup.should.equal('yes');\r\n        modified.nay.should.equal('yes indeed');\r\n      });\r\n\r\n      it('Can set sub-fields and create them if necessary', function () {\r\n        var obj = { yup: { subfield: 'bloup' } }\r\n          , updateQuery = { $set: { \"yup.subfield\": 'changed', \"yup.yop\": 'yes indeed', \"totally.doesnt.exist\": 'now it does' } }\r\n          , modified = model.modify(obj, updateQuery);\r\n\r\n        _.isEqual(modified, { yup: { subfield: 'changed', yop: 'yes indeed' }, totally: { doesnt: { exist: 'now it does' } } }).should.equal(true);\r\n      });\r\n    });   // End of '$set modifier'\r\n    \r\n    describe('$unset modifier', function () {\r\n    \r\n      it('Can delete a field, not throwing an error if the field doesnt exist', function () {\r\n        var obj, updateQuery, modified;\r\n      \r\n        obj = { yup: 'yes', other: 'also' }\r\n        updateQuery = { $unset: { yup: true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, { other: 'also' });\r\n\r\n        obj = { yup: 'yes', other: 'also' }\r\n        updateQuery = { $unset: { nope: true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, obj);\r\n        \r\n        obj = { yup: 'yes', other: 'also' }\r\n        updateQuery = { $unset: { nope: true, other: true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, { yup: 'yes' });\r\n      });\r\n      \r\n      it('Can unset sub-fields and entire nested documents', function () {\r\n        var obj, updateQuery, modified;\r\n      \r\n        obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }\r\n        updateQuery = { $unset: { nested: true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, { yup: 'yes' });\r\n      \r\n        obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }\r\n        updateQuery = { $unset: { 'nested.a': true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, { yup: 'yes', nested: { b: 'yeah' } });\r\n      \r\n        obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }\r\n        updateQuery = { $unset: { 'nested.a': true, 'nested.b': true } }\r\n        modified = model.modify(obj, updateQuery);\r\n        assert.deepEqual(modified, { yup: 'yes', nested: {} });\r\n      });\r\n      \r\n    });   // End of '$unset modifier'\r\n\r\n    describe('$inc modifier', function () {\r\n      it('Throw an error if you try to use it with a non-number or on a non number field', function () {\r\n        (function () {\r\n        var obj = { some: 'thing', yup: 'yes', nay: 2 }\r\n          , updateQuery = { $inc: { nay: 'notanumber' } }\r\n          , modified = model.modify(obj, updateQuery);\r\n        }).should.throw();\r\n\r\n        (function () {\r\n        var obj = { some: 'thing', yup: 'yes', nay: 'nope' }\r\n          , updateQuery = { $inc: { nay: 1 } }\r\n          , modified = model.modify(obj, updateQuery);\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Can increment number fields or create and initialize them if needed', function () {\r\n        var obj = { some: 'thing', nay: 40 }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $inc: { nay: 2 } });\r\n        _.isEqual(modified, { some: 'thing', nay: 42 }).should.equal(true);\r\n\r\n        // Incidentally, this tests that obj was not modified\r\n        modified = model.modify(obj, { $inc: { inexistent: -6 } });\r\n        _.isEqual(modified, { some: 'thing', nay: 40, inexistent: -6 }).should.equal(true);\r\n      });\r\n\r\n      it('Works recursively', function () {\r\n        var obj = { some: 'thing', nay: { nope: 40 } }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $inc: { \"nay.nope\": -2, \"blip.blop\": 123 } });\r\n        _.isEqual(modified, { some: 'thing', nay: { nope: 38 }, blip: { blop: 123 } }).should.equal(true);\r\n      });\r\n    });   // End of '$inc modifier'\r\n\r\n    describe('$push modifier', function () {\r\n\r\n      it('Can push an element to the end of an array', function () {\r\n        var obj = { arr: ['hello'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $push: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['hello', 'world'] });\r\n      });\r\n\r\n      it('Can push an element to a non-existent field and will create the array', function () {\r\n        var obj = {}\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $push: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['world'] });\r\n      });\r\n\r\n      it('Can push on nested fields', function () {\r\n        var obj = { arr: { nested: ['hello'] } }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $push: { \"arr.nested\": 'world' } });\r\n        assert.deepEqual(modified, { arr: { nested: ['hello', 'world'] } });\r\n\r\n        obj = { arr: { a: 2 }};\r\n        modified = model.modify(obj, { $push: { \"arr.nested\": 'world' } });\r\n        assert.deepEqual(modified, { arr: { a: 2, nested: ['world'] } });\r\n      });\r\n\r\n      it('Throw if we try to push to a non-array', function () {\r\n        var obj = { arr: 'hello' }\r\n          , modified;\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $push: { arr: 'world' } });\r\n        }).should.throw();\r\n\r\n        obj = { arr: { nested: 45 } };\r\n        (function () {\r\n          modified = model.modify(obj, { $push: { \"arr.nested\": 'world' } });\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Can use the $each modifier to add multiple values to an array at once', function () {\r\n        var obj = { arr: ['hello'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'] } } });\r\n        assert.deepEqual(modified, { arr: ['hello', 'world', 'earth', 'everything'] });\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $push: { arr: { $each: 45 } } });\r\n        }).should.throw();\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $push: { arr: { $each: ['world'], unauthorized: true } } });\r\n        }).should.throw();\r\n      });\r\n\r\n    });   // End of '$push modifier'\r\n\r\n    describe('$addToSet modifier', function () {\r\n\r\n      it('Can add an element to a set', function () {\r\n        var obj = { arr: ['hello'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $addToSet: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['hello', 'world'] });\r\n\r\n        obj = { arr: ['hello'] };\r\n        modified = model.modify(obj, { $addToSet: { arr: 'hello' } });\r\n        assert.deepEqual(modified, { arr: ['hello'] });\r\n      });\r\n\r\n      it('Can add an element to a non-existent set and will create the array', function () {\r\n        var obj = { arr: [] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $addToSet: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['world'] });\r\n      });\r\n\r\n      it('Throw if we try to addToSet to a non-array', function () {\r\n        var obj = { arr: 'hello' }\r\n          , modified;\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $addToSet: { arr: 'world' } });\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Use deep-equality to check whether we can add a value to a set', function () {\r\n        var obj = { arr: [ { b: 2 } ] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $addToSet: { arr: { b: 3 } } });\r\n        assert.deepEqual(modified, { arr: [{ b: 2 }, { b: 3 }] });\r\n\r\n        obj = { arr: [ { b: 2 } ] }\r\n        modified = model.modify(obj, { $addToSet: { arr: { b: 2 } } });\r\n        assert.deepEqual(modified, { arr: [{ b: 2 }] });\r\n      });\r\n\r\n      it('Can use the $each modifier to add multiple values to a set at once', function () {\r\n        var obj = { arr: ['hello'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $addToSet: { arr: { $each: ['world', 'earth', 'hello', 'earth'] } } });\r\n        assert.deepEqual(modified, { arr: ['hello', 'world', 'earth'] });\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $addToSet: { arr: { $each: 45 } } });\r\n        }).should.throw();\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $addToSet: { arr: { $each: ['world'], unauthorized: true } } });\r\n        }).should.throw();\r\n      });\r\n\r\n    });   // End of '$addToSet modifier'\r\n\r\n    describe('$pop modifier', function () {\r\n\r\n      it('Throw if called on a non array, a non defined field or a non integer', function () {\r\n        var obj = { arr: 'hello' }\r\n          , modified;\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $pop: { arr: 1 } });\r\n        }).should.throw();\r\n\r\n        obj = { bloup: 'nope' };\r\n        (function () {\r\n          modified = model.modify(obj, { $pop: { arr: 1 } });\r\n        }).should.throw();\r\n\r\n        obj = { arr: [1, 4, 8] };\r\n        (function () {\r\n          modified = model.modify(obj, { $pop: { arr: true } });\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Can remove the first and last element of an array', function () {\r\n        var obj\r\n          , modified;\r\n\r\n        obj = { arr: [1, 4, 8] };\r\n        modified = model.modify(obj, { $pop: { arr: 1 } });\r\n        assert.deepEqual(modified, { arr: [1, 4] });\r\n\r\n        obj = { arr: [1, 4, 8] };\r\n        modified = model.modify(obj, { $pop: { arr: -1 } });\r\n        assert.deepEqual(modified, { arr: [4, 8] });\r\n\r\n        // Empty arrays are not changed\r\n        obj = { arr: [] };\r\n        modified = model.modify(obj, { $pop: { arr: 1 } });\r\n        assert.deepEqual(modified, { arr: [] });\r\n        modified = model.modify(obj, { $pop: { arr: -1 } });\r\n        assert.deepEqual(modified, { arr: [] });\r\n      });\r\n\r\n    });   // End of '$pop modifier'\r\n\r\n    describe('$pull modifier', function () {\r\n\r\n      it('Can remove an element from a set', function () {\r\n        var obj = { arr: ['hello', 'world'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $pull: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['hello'] });\r\n\r\n        obj = { arr: ['hello'] };\r\n        modified = model.modify(obj, { $pull: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['hello'] });\r\n      });\r\n\r\n      it('Can remove multiple matching elements', function () {\r\n        var obj = { arr: ['hello', 'world', 'hello', 'world'] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $pull: { arr: 'world' } });\r\n        assert.deepEqual(modified, { arr: ['hello', 'hello'] });\r\n      });\r\n\r\n      it('Throw if we try to pull from a non-array', function () {\r\n        var obj = { arr: 'hello' }\r\n          , modified;\r\n\r\n        (function () {\r\n          modified = model.modify(obj, { $pull: { arr: 'world' } });\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Use deep-equality to check whether we can remove a value from a set', function () {\r\n        var obj = { arr: [{ b: 2 }, { b: 3 }] }\r\n          , modified;\r\n\r\n        modified = model.modify(obj, { $pull: { arr: { b: 3 } } });\r\n        assert.deepEqual(modified, { arr: [ { b: 2 } ] });\r\n\r\n        obj = { arr: [ { b: 2 } ] }\r\n        modified = model.modify(obj, { $pull: { arr: { b: 3 } } });\r\n        assert.deepEqual(modified, { arr: [{ b: 2 }] });\r\n      });\r\n      \r\n      it('Can use any kind of nedb query with $pull', function () {\r\n        var obj = { arr: [4, 7, 12, 2], other: 'yup' }\r\n          , modified\r\n          ;\r\n      \r\n        modified = model.modify(obj, { $pull: { arr: { $gte: 5 } } });\r\n        assert.deepEqual(modified, { arr: [4, 2], other: 'yup' });\r\n        \r\n        obj = { arr: [{ b: 4 }, { b: 7 }, { b: 1 }], other: 'yeah' };\r\n        modified = model.modify(obj, { $pull: { arr: { b: { $gte: 5} } } });\r\n        assert.deepEqual(modified, { arr: [{ b: 4 }, { b: 1 }], other: 'yeah' });\r\n      });\r\n\r\n    });   // End of '$pull modifier'\r\n\r\n  });   // ==== End of 'Modifying documents' ==== //\r\n\r\n\r\n  describe('Comparing things', function () {\r\n\r\n    it('undefined is the smallest', function () {\r\n      var otherStuff = [null, \"string\", \"\", -1, 0, 5.3, 12, true, false, new Date(12345), {}, { hello: 'world' }, [], ['quite', 5]];\r\n\r\n      model.compareThings(undefined, undefined).should.equal(0);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        model.compareThings(undefined, stuff).should.equal(-1);\r\n        model.compareThings(stuff, undefined).should.equal(1);\r\n      });\r\n    });\r\n\r\n    it('Then null', function () {\r\n      var otherStuff = [\"string\", \"\", -1, 0, 5.3, 12, true, false, new Date(12345), {}, { hello: 'world' }, [], ['quite', 5]];\r\n\r\n      model.compareThings(null, null).should.equal(0);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        model.compareThings(null, stuff).should.equal(-1);\r\n        model.compareThings(stuff, null).should.equal(1);\r\n      });\r\n    });\r\n\r\n    it('Then numbers', function () {\r\n      var otherStuff = [\"string\", \"\", true, false, new Date(4312), {}, { hello: 'world' }, [], ['quite', 5]]\r\n        , numbers = [-12, 0, 12, 5.7];\r\n\r\n      model.compareThings(-12, 0).should.equal(-1);\r\n      model.compareThings(0, -3).should.equal(1);\r\n      model.compareThings(5.7, 2).should.equal(1);\r\n      model.compareThings(5.7, 12.3).should.equal(-1);\r\n      model.compareThings(0, 0).should.equal(0);\r\n      model.compareThings(-2.6, -2.6).should.equal(0);\r\n      model.compareThings(5, 5).should.equal(0);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        numbers.forEach(function (number) {\r\n          model.compareThings(number, stuff).should.equal(-1);\r\n          model.compareThings(stuff, number).should.equal(1);\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Then strings', function () {\r\n      var otherStuff = [true, false, new Date(4321), {}, { hello: 'world' }, [], ['quite', 5]]\r\n        , strings = ['', 'string', 'hello world'];\r\n\r\n      model.compareThings('', 'hey').should.equal(-1);\r\n      model.compareThings('hey', '').should.equal(1);\r\n      model.compareThings('hey', 'hew').should.equal(1);\r\n      model.compareThings('hey', 'hey').should.equal(0);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        strings.forEach(function (string) {\r\n          model.compareThings(string, stuff).should.equal(-1);\r\n          model.compareThings(stuff, string).should.equal(1);\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Then booleans', function () {\r\n      var otherStuff = [new Date(4321), {}, { hello: 'world' }, [], ['quite', 5]]\r\n        , bools = [true, false];\r\n\r\n      model.compareThings(true, true).should.equal(0);\r\n      model.compareThings(false, false).should.equal(0);\r\n      model.compareThings(true, false).should.equal(1);\r\n      model.compareThings(false, true).should.equal(-1);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        bools.forEach(function (bool) {\r\n          model.compareThings(bool, stuff).should.equal(-1);\r\n          model.compareThings(stuff, bool).should.equal(1);\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Then dates', function () {\r\n      var otherStuff = [{}, { hello: 'world' }, [], ['quite', 5]]\r\n        , dates = [new Date(-123), new Date(), new Date(5555), new Date(0)]\r\n        , now = new Date();\r\n\r\n      model.compareThings(now, now).should.equal(0);\r\n      model.compareThings(new Date(54341), now).should.equal(-1);\r\n      model.compareThings(now, new Date(54341)).should.equal(1);\r\n      model.compareThings(new Date(0), new Date(-54341)).should.equal(1);\r\n      model.compareThings(new Date(123), new Date(4341)).should.equal(-1);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        dates.forEach(function (date) {\r\n          model.compareThings(date, stuff).should.equal(-1);\r\n          model.compareThings(stuff, date).should.equal(1);\r\n        });\r\n      });\r\n    });\r\n\r\n    it('Then arrays', function () {\r\n      var otherStuff = [{}, { hello: 'world' }]\r\n        , arrays = [[], ['yes'], ['hello', 5]]\r\n        ;\r\n\r\n      model.compareThings([], []).should.equal(0);\r\n      model.compareThings(['hello'], []).should.equal(1);\r\n      model.compareThings([], ['hello']).should.equal(-1);\r\n      model.compareThings(['hello'], ['hello', 'world']).should.equal(-1);\r\n      model.compareThings(['hello', 'earth'], ['hello', 'world']).should.equal(-1);\r\n      model.compareThings(['hello', 'zzz'], ['hello', 'world']).should.equal(1);\r\n      model.compareThings(['hello', 'world'], ['hello', 'world']).should.equal(0);\r\n\r\n      otherStuff.forEach(function (stuff) {\r\n        arrays.forEach(function (array) {\r\n          model.compareThings(array, stuff).should.equal(-1);\r\n          model.compareThings(stuff, array).should.equal(1);\r\n        });\r\n      });\r\n    });\r\n\r\n    it('And finally objects', function () {\r\n      model.compareThings({}, {}).should.equal(0);\r\n      model.compareThings({ a: 42 }, { a: 312}).should.equal(-1);\r\n      model.compareThings({ a: '42' }, { a: '312'}).should.equal(1);\r\n      model.compareThings({ a: 42, b: 312 }, { b: 312, a: 42 }).should.equal(0);\r\n      model.compareThings({ a: 42, b: 312, c: 54 }, { b: 313, a: 42 }).should.equal(-1);\r\n    });\r\n\r\n  });   // ==== End of 'Comparing things' ==== //\r\n\r\n\r\n  describe('Querying', function () {\r\n\r\n    describe('Comparing things', function () {\r\n\r\n      it('Two things of different types cannot be equal, two identical native things are equal', function () {\r\n        var toTest = [null, 'somestring', 42, true, new Date(72998322), { hello: 'world' }]\r\n          , toTestAgainst = [null, 'somestring', 42, true, new Date(72998322), { hello: 'world' }]   // Use another array so that we don't test pointer equality\r\n          , i, j\r\n          ;\r\n\r\n        for (i = 0; i < toTest.length; i += 1) {\r\n          for (j = 0; j < toTestAgainst.length; j += 1) {\r\n            model.areThingsEqual(toTest[i], toTestAgainst[j]).should.equal(i === j);\r\n          }\r\n        }\r\n      });\r\n\r\n      it('Can test native types null undefined string number boolean date equality', function () {\r\n        var toTest = [null, undefined, 'somestring', 42, true, new Date(72998322), { hello: 'world' }]\r\n          , toTestAgainst = [undefined, null, 'someotherstring', 5, false, new Date(111111), { hello: 'mars' }]\r\n          , i\r\n          ;\r\n\r\n        for (i = 0; i < toTest.length; i += 1) {\r\n          model.areThingsEqual(toTest[i], toTestAgainst[i]).should.equal(false);\r\n        }\r\n      });\r\n\r\n      it('If one side is an array or undefined, comparison fails', function () {\r\n        var toTestAgainst = [null, undefined, 'somestring', 42, true, new Date(72998322), { hello: 'world' }]\r\n          , i\r\n          ;\r\n\r\n        for (i = 0; i < toTestAgainst.length; i += 1) {\r\n          model.areThingsEqual([1, 2, 3], toTestAgainst[i]).should.equal(false);\r\n          model.areThingsEqual(toTestAgainst[i], []).should.equal(false);\r\n\r\n          model.areThingsEqual(undefined, toTestAgainst[i]).should.equal(false);\r\n          model.areThingsEqual(toTestAgainst[i], undefined).should.equal(false);\r\n        }\r\n      });\r\n\r\n      it('Can test objects equality', function () {\r\n        model.areThingsEqual({ hello: 'world' }, {}).should.equal(false);\r\n        model.areThingsEqual({ hello: 'world' }, { hello: 'mars' }).should.equal(false);\r\n        model.areThingsEqual({ hello: 'world' }, { hello: 'world', temperature: 42 }).should.equal(false);\r\n        model.areThingsEqual({ hello: 'world', other: { temperature: 42 }}, { hello: 'world', other: { temperature: 42 }}).should.equal(true);\r\n      });\r\n\r\n    });\r\n\r\n\r\n    describe('Getting a fields value in dot notation', function () {\r\n\r\n      it('Return first-level and nested values', function () {\r\n        model.getDotValue({ hello: 'world' }, 'hello').should.equal('world');\r\n        model.getDotValue({ hello: 'world', type: { planet: true, blue: true } }, 'type.planet').should.equal(true);\r\n      });\r\n\r\n      it('Return undefined if the field cannot be found in the object', function () {\r\n        assert.isUndefined(model.getDotValue({ hello: 'world' }, 'helloo'));\r\n        assert.isUndefined(model.getDotValue({ hello: 'world', type: { planet: true } }, 'type.plane'));\r\n      });\r\n      \r\n      it(\"Can navigate inside arrays with dot notation, and return the array of values in that case\", function () {\r\n        var dv;\r\n        \r\n        // Simple array of subdocuments\r\n        dv = model.getDotValue({ planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] }, 'planets.name');\r\n        assert.deepEqual(dv, ['Earth', 'Mars', 'Pluton']);\r\n        \r\n        // Nested array of subdocuments\r\n        dv = model.getDotValue({ nedb: true, data: { planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] } }, 'data.planets.number');\r\n        assert.deepEqual(dv, [3, 2, 9]);\r\n        \r\n        // Nested array in a subdocument of an array (yay, inception!)\r\n        // TODO: make sure MongoDB doesn't flatten the array (it wouldn't make sense)\r\n        dv = model.getDotValue({ nedb: true, data: { planets: [ { name: 'Earth', numbers: [ 1, 3 ] }, { name: 'Mars', numbers: [ 7 ] }, { name: 'Pluton', numbers: [ 9, 5, 1 ] } ] } }, 'data.planets.numbers');\r\n        assert.deepEqual(dv, [[ 1, 3 ], [ 7 ], [ 9, 5, 1 ]]);\r\n      });\r\n      \r\n      it(\"Can get a single value out of an array using its index\", function () {\r\n        var dv;\r\n        \r\n        // Simple index in dot notation\r\n        dv = model.getDotValue({ planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] }, 'planets.1');\r\n        assert.deepEqual(dv, { name: 'Mars', number: 2 });\r\n\r\n        // Out of bounds index\r\n        dv = model.getDotValue({ planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] }, 'planets.3');\r\n        assert.isUndefined(dv);\r\n\r\n        // Index in nested array\r\n        dv = model.getDotValue({ nedb: true, data: { planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] } }, 'data.planets.2');\r\n        assert.deepEqual(dv, { name: 'Pluton', number: 9 });\r\n        \r\n        // Dot notation with index in the middle\r\n        dv = model.getDotValue({ nedb: true, data: { planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] } }, 'data.planets.0.name');\r\n        dv.should.equal('Earth');\r\n      });\r\n\r\n    });\r\n\r\n\r\n    describe('Field equality', function () {\r\n\r\n      it('Can find documents with simple fields', function () {\r\n        model.match({ test: 'yeah' }, { test: 'yea' }).should.equal(false);\r\n        model.match({ test: 'yeah' }, { test: 'yeahh' }).should.equal(false);\r\n        model.match({ test: 'yeah' }, { test: 'yeah' }).should.equal(true);\r\n      });\r\n\r\n      it('Can find documents with the dot-notation', function () {\r\n        model.match({ test: { ooo: 'yeah' } }, { \"test.ooo\": 'yea' }).should.equal(false);\r\n        model.match({ test: { ooo: 'yeah' } }, { \"test.oo\": 'yeah' }).should.equal(false);\r\n        model.match({ test: { ooo: 'yeah' } }, { \"tst.ooo\": 'yeah' }).should.equal(false);\r\n        model.match({ test: { ooo: 'yeah' } }, { \"test.ooo\": 'yeah' }).should.equal(true);\r\n      });\r\n\r\n      it('Cannot find undefined', function () {\r\n        model.match({ test: undefined }, { test: undefined }).should.equal(false);\r\n        model.match({ test: { pp: undefined } }, { \"test.pp\": undefined }).should.equal(false);\r\n      });\r\n\r\n      it('Nested objects are deep-equality matched and not treated as sub-queries', function () {\r\n        model.match({ a: { b: 5 } }, { a: { b: 5 } }).should.equal(true);\r\n        model.match({ a: { b: 5, c: 3 } }, { a: { b: 5 } }).should.equal(false);\r\n\r\n        model.match({ a: { b: 5 } }, { a: { b: { $lt: 10 } } }).should.equal(false);\r\n        (function () { model.match({ a: { b: 5 } }, { a: { $or: [ { b: 10 }, { b: 5 } ] } }) }).should.throw();\r\n      });\r\n      \r\n      it(\"Can match for field equality inside an array with the dot notation\", function () {\r\n        model.match({ a: true, b: [ 'node', 'embedded', 'database' ] }, { 'b.1': 'node' }).should.equal(false);\r\n        model.match({ a: true, b: [ 'node', 'embedded', 'database' ] }, { 'b.1': 'embedded' }).should.equal(true);\r\n        model.match({ a: true, b: [ 'node', 'embedded', 'database' ] }, { 'b.1': 'database' }).should.equal(false);\r\n      })\r\n\r\n    });\r\n\r\n\r\n    describe('Regular expression matching', function () {\r\n\r\n      it('Matching a non-string to a regular expression always yields false', function () {\r\n        var d = new Date()\r\n          , r = new RegExp(d.getTime());\r\n\r\n        model.match({ test: true }, { test: /true/ }).should.equal(false);\r\n        model.match({ test: null }, { test: /null/ }).should.equal(false);\r\n        model.match({ test: 42 }, { test: /42/ }).should.equal(false);\r\n        model.match({ test: d }, { test: r }).should.equal(false);\r\n      });\r\n\r\n      it('Can match strings using basic querying', function () {\r\n        model.match({ test: 'true' }, { test: /true/ }).should.equal(true);\r\n        model.match({ test: 'babaaaar' }, { test: /aba+r/ }).should.equal(true);\r\n        model.match({ test: 'babaaaar' }, { test: /^aba+r/ }).should.equal(false);\r\n        model.match({ test: 'true' }, { test: /t[ru]e/ }).should.equal(false);\r\n      });\r\n\r\n      it('Can match strings using the $regex operator', function () {\r\n        model.match({ test: 'true' }, { test: { $regex: /true/ } }).should.equal(true);\r\n        model.match({ test: 'babaaaar' }, { test: { $regex: /aba+r/ } }).should.equal(true);\r\n        model.match({ test: 'babaaaar' }, { test: { $regex: /^aba+r/ } }).should.equal(false);\r\n        model.match({ test: 'true' }, { test: { $regex: /t[ru]e/ } }).should.equal(false);\r\n      });\r\n\r\n      it('Will throw if $regex operator is used with a non regex value', function () {\r\n        (function () {\r\n          model.match({ test: 'true' }, { test: { $regex: 42 } })\r\n        }).should.throw();\r\n\r\n        (function () {\r\n          model.match({ test: 'true' }, { test: { $regex: 'true' } })\r\n        }).should.throw();\r\n      });\r\n\r\n      it('Can use the $regex operator in cunjunction with other operators', function () {\r\n        model.match({ test: 'helLo' }, { test: { $regex: /ll/i, $nin: ['helL', 'helLop'] } }).should.equal(true);\r\n        model.match({ test: 'helLo' }, { test: { $regex: /ll/i, $nin: ['helLo', 'helLop'] } }).should.equal(false);\r\n      });\r\n\r\n      it('Can use dot-notation', function () {\r\n        model.match({ test: { nested: 'true' } }, { 'test.nested': /true/ }).should.equal(true);\r\n        model.match({ test: { nested: 'babaaaar' } }, { 'test.nested': /^aba+r/ }).should.equal(false);\r\n\r\n        model.match({ test: { nested: 'true' } }, { 'test.nested': { $regex: /true/ } }).should.equal(true);\r\n        model.match({ test: { nested: 'babaaaar' } }, { 'test.nested': { $regex: /^aba+r/ } }).should.equal(false);\r\n      });\r\n\r\n    });\r\n\r\n\r\n    describe('$lt', function () {\r\n\r\n      it('Cannot compare a field to an object, an array, null or a boolean, it will return false', function () {\r\n        model.match({ a: 5 }, { a: { $lt: { a: 6 } } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $lt: [6, 7] } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $lt: null } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $lt: true } }).should.equal(false);\r\n      });\r\n\r\n      it('Can compare numbers, with or without dot notation', function () {\r\n        model.match({ a: 5 }, { a: { $lt: 6 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $lt: 5 } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $lt: 4 } }).should.equal(false);\r\n\r\n        model.match({ a: { b: 5 } }, { \"a.b\": { $lt: 6 } }).should.equal(true);\r\n        model.match({ a: { b: 5 } }, { \"a.b\": { $lt: 3 } }).should.equal(false);\r\n      });\r\n\r\n      it('Can compare strings, with or without dot notation', function () {\r\n        model.match({ a: \"nedb\" }, { a: { $lt: \"nedc\" } }).should.equal(true);\r\n        model.match({ a: \"nedb\" }, { a: { $lt: \"neda\" } }).should.equal(false);\r\n\r\n        model.match({ a: { b: \"nedb\" } }, { \"a.b\": { $lt: \"nedc\" } }).should.equal(true);\r\n        model.match({ a: { b: \"nedb\" } }, { \"a.b\": { $lt: \"neda\" } }).should.equal(false);\r\n      });\r\n\r\n      it('If field is an array field, a match means a match on at least one element', function () {\r\n        model.match({ a: [5, 10] }, { a: { $lt: 4 } }).should.equal(false);\r\n        model.match({ a: [5, 10] }, { a: { $lt: 6 } }).should.equal(true);\r\n        model.match({ a: [5, 10] }, { a: { $lt: 11 } }).should.equal(true);\r\n      });\r\n\r\n      it('Works with dates too', function () {\r\n        model.match({ a: new Date(1000) }, { a: { $gte: new Date(1001) } }).should.equal(false);\r\n        model.match({ a: new Date(1000) }, { a: { $lt: new Date(1001) } }).should.equal(true);\r\n      });\r\n\r\n    });\r\n\r\n\r\n    // General behaviour is tested in the block about $lt. Here we just test operators work\r\n    describe('Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists', function () {\r\n\r\n      it('$lte', function () {\r\n        model.match({ a: 5 }, { a: { $lte: 6 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $lte: 5 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $lte: 4 } }).should.equal(false);\r\n      });\r\n\r\n      it('$gt', function () {\r\n        model.match({ a: 5 }, { a: { $gt: 6 } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $gt: 5 } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $gt: 4 } }).should.equal(true);\r\n      });\r\n\r\n      it('$gte', function () {\r\n        model.match({ a: 5 }, { a: { $gte: 6 } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $gte: 5 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $gte: 4 } }).should.equal(true);\r\n      });\r\n\r\n      it('$ne', function () {\r\n        model.match({ a: 5 }, { a: { $ne: 4 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $ne: 5 } }).should.equal(false);\r\n        model.match({ a: 5 }, { b: { $ne: 5 } }).should.equal(true);\r\n      });\r\n\r\n      it('$in', function () {\r\n        model.match({ a: 5 }, { a: { $in: [6, 8, 9] } }).should.equal(false);\r\n        model.match({ a: 6 }, { a: { $in: [6, 8, 9] } }).should.equal(true);\r\n        model.match({ a: 7 }, { a: { $in: [6, 8, 9] } }).should.equal(false);\r\n        model.match({ a: 8 }, { a: { $in: [6, 8, 9] } }).should.equal(true);\r\n        model.match({ a: 9 }, { a: { $in: [6, 8, 9] } }).should.equal(true);\r\n\r\n        (function () { model.match({ a: 5 }, { a: { $in: 5 } }); }).should.throw();\r\n      });\r\n\r\n      it('$nin', function () {\r\n        model.match({ a: 5 }, { a: { $nin: [6, 8, 9] } }).should.equal(true);\r\n        model.match({ a: 6 }, { a: { $nin: [6, 8, 9] } }).should.equal(false);\r\n        model.match({ a: 7 }, { a: { $nin: [6, 8, 9] } }).should.equal(true);\r\n        model.match({ a: 8 }, { a: { $nin: [6, 8, 9] } }).should.equal(false);\r\n        model.match({ a: 9 }, { a: { $nin: [6, 8, 9] } }).should.equal(false);\r\n\r\n        // Matches if field doesn't exist\r\n        model.match({ a: 9 }, { b: { $nin: [6, 8, 9] } }).should.equal(true);\r\n\r\n        (function () { model.match({ a: 5 }, { a: { $in: 5 } }); }).should.throw();\r\n      });\r\n\r\n      it('$exists', function () {\r\n        model.match({ a: 5 }, { a: { $exists: 1 } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $exists: true } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $exists: new Date() } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $exists: '' } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $exists: [] } }).should.equal(true);\r\n        model.match({ a: 5 }, { a: { $exists: {} } }).should.equal(true);\r\n\r\n        model.match({ a: 5 }, { a: { $exists: 0 } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $exists: false } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $exists: null } }).should.equal(false);\r\n        model.match({ a: 5 }, { a: { $exists: undefined } }).should.equal(false);\r\n\r\n        model.match({ a: 5 }, { b: { $exists: true } }).should.equal(false);\r\n\r\n        model.match({ a: 5 }, { b: { $exists: false } }).should.equal(true);\r\n      });\r\n\r\n    });\r\n\r\n    \r\n    describe('Query operator array $size', function () {\r\n\r\n        it('Can query on the size of an array field', function () {\r\n          // Non nested documents\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens\": { $size: 0 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens\": { $size: 1 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens\": { $size: 2 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens\": { $size: 3 } }).should.equal(true);\r\n            \r\n          // Nested documents\r\n          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { \"description.satellites\": { $size: 0 } }).should.equal(false);\r\n          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { \"description.satellites\": { $size: 1 } }).should.equal(false);\r\n          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { \"description.satellites\": { $size: 2 } }).should.equal(true);\r\n          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { \"description.satellites\": { $size: 3 } }).should.equal(false);\r\n\r\n          // Using a projected array\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.names\": { $size: 0 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.names\": { $size: 1 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.names\": { $size: 2 } }).should.equal(false);\r\n          model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.names\": { $size: 3 } }).should.equal(true);\r\n        });\r\n\r\n        it('$size operator works with empty arrays', function () {\r\n          model.match({ childrens: [] }, { \"childrens\": { $size: 0 } }).should.equal(true);\r\n          model.match({ childrens: [] }, { \"childrens\": { $size: 2 } }).should.equal(false);\r\n          model.match({ childrens: [] }, { \"childrens\": { $size: 3 } }).should.equal(false);\r\n        });\r\n\r\n        it('Should throw an error if a query operator is used without comparing to an integer', function () {\r\n          (function () { model.match({ a: [1, 5] }, { a: { $size: 1.4 } }); }).should.throw();\r\n          (function () { model.match({ a: [1, 5] }, { a: { $size: 'fdf' } }); }).should.throw();\r\n          (function () { model.match({ a: [1, 5] }, { a: { $size: { $lt: 5 } } }); }).should.throw();\r\n        });\r\n\r\n        it('Using $size operator on a non-array field should prevent match but not throw', function () {\r\n          model.match({ a: 5 }, { a: { $size: 1 } }).should.equal(false);\r\n        });\r\n        \r\n        it('Can use $size several times in the same matcher', function () {\r\n          model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { \"childrens\": { $size: 3, $size: 3 } }).should.equal(true);\r\n          model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { \"childrens\": { $size: 3, $size: 4 } }).should.equal(false);   // Of course this can never be true\r\n        });\r\n        \r\n    });\r\n    \r\n\r\n    describe('Logical operators $or, $and, $not', function () {\r\n\r\n      it('Any of the subqueries should match for an $or to match', function () {\r\n        model.match({ hello: 'world' }, { $or: [ { hello: 'pluton' }, { hello: 'world' } ] }).should.equal(true);\r\n        model.match({ hello: 'pluton' }, { $or: [ { hello: 'pluton' }, { hello: 'world' } ] }).should.equal(true);\r\n        model.match({ hello: 'nope' }, { $or: [ { hello: 'pluton' }, { hello: 'world' } ] }).should.equal(false);\r\n        model.match({ hello: 'world', age: 15 }, { $or: [ { hello: 'pluton' }, { age: { $lt: 20 } } ] }).should.equal(true);\r\n        model.match({ hello: 'world', age: 15 }, { $or: [ { hello: 'pluton' }, { age: { $lt: 10 } } ] }).should.equal(false);\r\n      });\r\n\r\n      it('All of the subqueries should match for an $and to match', function () {\r\n        model.match({ hello: 'world', age: 15 }, { $and: [ { age: 15 }, { hello: 'world' } ] }).should.equal(true);\r\n        model.match({ hello: 'world', age: 15 }, { $and: [ { age: 16 }, { hello: 'world' } ] }).should.equal(false);\r\n        model.match({ hello: 'world', age: 15 }, { $and: [ { hello: 'world' }, { age: { $lt: 20 } } ] }).should.equal(true);\r\n        model.match({ hello: 'world', age: 15 }, { $and: [ { hello: 'pluton' }, { age: { $lt: 20 } } ] }).should.equal(false);\r\n      });\r\n\r\n      it('Subquery should not match for a $not to match', function () {\r\n        model.match({ a: 5, b: 10 }, { a: 5 }).should.equal(true);\r\n        model.match({ a: 5, b: 10 }, { $not: { a: 5 } }).should.equal(false);\r\n      });\r\n\r\n      it('Logical operators are all top-level, only other logical operators can be above', function () {\r\n        (function () { model.match({ a: { b: 7 } }, { a: { $or: [ { b: 5 }, { b: 7 } ] } })}).should.throw();\r\n        model.match({ a: { b: 7 } }, { $or: [ { \"a.b\": 5 }, { \"a.b\": 7 } ] }).should.equal(true);\r\n      });\r\n\r\n      it('Logical operators can be combined as long as they are on top of the decision tree', function () {\r\n        model.match({ a: 5, b: 7, c: 12 }, { $or: [ { $and: [ { a: 5 }, { b: 8 } ] }, { $and: [{ a: 5 }, { c : { $lt: 40 } }] } ] }).should.equal(true);\r\n        model.match({ a: 5, b: 7, c: 12 }, { $or: [ { $and: [ { a: 5 }, { b: 8 } ] }, { $and: [{ a: 5 }, { c : { $lt: 10 } }] } ] }).should.equal(false);\r\n      });\r\n\r\n      it('Should throw an error if a logical operator is used without an array or if an unknown logical operator is used', function () {\r\n        (function () { model.match({ a: 5 }, { $or: { a: 5, a: 6 } }); }).should.throw();\r\n        (function () { model.match({ a: 5 }, { $and: { a: 5, a: 6 } }); }).should.throw();\r\n        (function () { model.match({ a: 5 }, { $unknown: [ { a: 5 } ] }); }).should.throw();\r\n      });\r\n\r\n    });\r\n\r\n\r\n    describe('Array fields', function () {\r\n\r\n      it('Field equality', function () {\r\n        model.match({ tags: ['node', 'js', 'db'] }, { tags: 'python' }).should.equal(false);\r\n        model.match({ tags: ['node', 'js', 'db'] }, { tagss: 'js' }).should.equal(false);\r\n        model.match({ tags: ['node', 'js', 'db'] }, { tags: 'js' }).should.equal(true);\r\n        model.match({ tags: ['node', 'js', 'db'] }, { tags: 'js', tags: 'node' }).should.equal(true);\r\n\r\n        // Mixed matching with array and non array\r\n        model.match({ tags: ['node', 'js', 'db'], nedb: true }, { tags: 'js', nedb: true }).should.equal(true);\r\n\r\n        // Nested matching\r\n        model.match({ number: 5, data: { tags: ['node', 'js', 'db'] } }, { \"data.tags\": 'js' }).should.equal(true);\r\n        model.match({ number: 5, data: { tags: ['node', 'js', 'db'] } }, { \"data.tags\": 'j' }).should.equal(false);\r\n      });\r\n\r\n      it('With one comparison operator', function () {\r\n        model.match({ ages: [3, 7, 12] }, { ages: { $lt: 2 } }).should.equal(false);\r\n        model.match({ ages: [3, 7, 12] }, { ages: { $lt: 3 } }).should.equal(false);\r\n        model.match({ ages: [3, 7, 12] }, { ages: { $lt: 4 } }).should.equal(true);\r\n        model.match({ ages: [3, 7, 12] }, { ages: { $lt: 8 } }).should.equal(true);\r\n        model.match({ ages: [3, 7, 12] }, { ages: { $lt: 13 } }).should.equal(true);\r\n      });\r\n\r\n      it('Works with arrays that are in subdocuments', function () {\r\n        model.match({ children: { ages: [3, 7, 12] } }, { \"children.ages\": { $lt: 2 } }).should.equal(false);\r\n        model.match({ children: { ages: [3, 7, 12] } }, { \"children.ages\": { $lt: 3 } }).should.equal(false);\r\n        model.match({ children: { ages: [3, 7, 12] } }, { \"children.ages\": { $lt: 4 } }).should.equal(true);\r\n        model.match({ children: { ages: [3, 7, 12] } }, { \"children.ages\": { $lt: 8 } }).should.equal(true);\r\n        model.match({ children: { ages: [3, 7, 12] } }, { \"children.ages\": { $lt: 13 } }).should.equal(true);\r\n      });\r\n\r\n      it('Can query inside arrays thanks to dot notation', function () {\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.age\": { $lt: 2 } }).should.equal(false);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.age\": { $lt: 3 } }).should.equal(false);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.age\": { $lt: 4 } }).should.equal(true);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.age\": { $lt: 8 } }).should.equal(true);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.age\": { $lt: 13 } }).should.equal(true);\r\n        \r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.name\": 'Louis' }).should.equal(false);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.name\": 'Louie' }).should.equal(true);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.name\": 'Lewi' }).should.equal(false);\r\n      });\r\n      \r\n      it('Can query for a specific element inside arrays thanks to dot notation', function () {\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.0.name\": 'Louie' }).should.equal(false);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.1.name\": 'Louie' }).should.equal(false);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.2.name\": 'Louie' }).should.equal(true);\r\n        model.match({ childrens: [ { name: \"Huey\", age: 3 }, { name: \"Dewey\", age: 7 }, { name: \"Louie\", age: 12 } ] }, { \"childrens.3.name\": 'Louie' }).should.equal(false);\r\n      });\r\n      \r\n      it('A single array-specific operator and the query is treated as array specific', function () {\r\n        (function () { model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { \"childrens\": { \"Fifi\": true, $size: 3 } })}).should.throw();\r\n      });\r\n      \r\n      it('Can mix queries on array fields and non array filds with array specific operators', function () {\r\n        model.match({ uncle: 'Donald', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 2 }, uncle: 'Donald' }).should.equal(false);\r\n        model.match({ uncle: 'Donald', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 3 }, uncle: 'Donald' }).should.equal(true);\r\n        model.match({ uncle: 'Donald', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 4 }, uncle: 'Donald' }).should.equal(false);\r\n\r\n        model.match({ uncle: 'Donals', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 3 }, uncle: 'Picsou' }).should.equal(false);\r\n        model.match({ uncle: 'Donald', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 3 }, uncle: 'Donald' }).should.equal(true);\r\n        model.match({ uncle: 'Donald', nephews: [ 'Riri', 'Fifi', 'Loulou' ] }, { nephews: { $size: 3 }, uncle: 'Daisy' }).should.equal(false);\r\n      });\r\n      \r\n    });\r\n\r\n  });   // ==== End of 'Querying' ==== //\r\n\r\n});\r\n","var should = require('chai').should()\r\n  , assert = require('chai').assert\r\n  , testDb = 'workspace/test.db'\r\n  , fs = require('fs')\r\n  , path = require('path')\r\n  , _ = require('underscore')\r\n  , async = require('async')\r\n  , model = require('../lib/model')\r\n  , customUtils = require('../lib/customUtils')\r\n  , Datastore = require('../lib/datastore')\r\n  , Persistence = require('../lib/persistence')\r\n  , child_process = require('child_process')\r\n  ;\r\n\r\n\r\ndescribe('Persistence', function () {\r\n  var d;\r\n\r\n  beforeEach(function (done) {\r\n    d = new Datastore({ filename: testDb });\r\n    d.filename.should.equal(testDb);\r\n    d.inMemoryOnly.should.equal(false);\r\n\r\n    async.waterfall([\r\n      function (cb) {\r\n        Persistence.ensureDirectoryExists(path.dirname(testDb), function () {\r\n          fs.exists(testDb, function (exists) {\r\n            if (exists) {\r\n              fs.unlink(testDb, cb);\r\n            } else { return cb(); }\r\n          });\r\n        });\r\n      }\r\n    , function (cb) {\r\n        d.loadDatabase(function (err) {\r\n          assert.isNull(err);\r\n          d.getAllData().length.should.equal(0);\r\n          return cb();\r\n        });\r\n      }\r\n    ], done);\r\n  });\r\n\r\n  it('Every line represents a document', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ _id: \"2\", hello: 'world' }) + '\\n' +\r\n                  model.serialize({ _id: \"3\", nested: { today: now } })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(3);\r\n    _.isEqual(treatedData[0], { _id: \"1\", a: 2, ages: [1, 5, 12] }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"2\", hello: 'world' }).should.equal(true);\r\n    _.isEqual(treatedData[2], { _id: \"3\", nested: { today: now } }).should.equal(true);\r\n  });\r\n\r\n  it('Badly formatted lines have no impact on the treated data', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  'garbage\\n' +\r\n                  model.serialize({ _id: \"3\", nested: { today: now } })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"1\", a: 2, ages: [1, 5, 12] }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"3\", nested: { today: now } }).should.equal(true);\r\n  });\r\n\r\n  it('Well formatted lines that have no _id are not included in the data', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ _id: \"2\", hello: 'world' }) + '\\n' +\r\n                  model.serialize({ nested: { today: now } })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"1\", a: 2, ages: [1, 5, 12] }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"2\", hello: 'world' }).should.equal(true);\r\n  });\r\n\r\n  it('If two lines concern the same doc (= same _id), the last one is the good version', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ _id: \"2\", hello: 'world' }) + '\\n' +\r\n                  model.serialize({ _id: \"1\", nested: { today: now } })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"1\", nested: { today: now } }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"2\", hello: 'world' }).should.equal(true);\r\n  });\r\n\r\n  it('If a doc contains $$deleted: true, that means we need to remove it from the data', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ _id: \"2\", hello: 'world' }) + '\\n' +\r\n                  model.serialize({ _id: \"1\", $$deleted: true }) + '\\n' +\r\n                  model.serialize({ _id: \"3\", today: now })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"2\", hello: 'world' }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"3\", today: now }).should.equal(true);\r\n  });\r\n\r\n  it('If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ _id: \"2\", $$deleted: true }) + '\\n' +\r\n                  model.serialize({ _id: \"3\", today: now })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      ;\r\n\r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"1\", a: 2, ages: [1, 5, 12] }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"3\", today: now }).should.equal(true);\r\n  });\r\n  \r\n  it('If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options', function () {\r\n    var now = new Date()\r\n      , rawData = model.serialize({ _id: \"1\", a: 2, ages: [1, 5, 12] }) + '\\n' +\r\n                  model.serialize({ $$indexCreated: { fieldName: \"test\", unique: true } }) + '\\n' +\r\n                  model.serialize({ _id: \"3\", today: now })\r\n      , treatedData = Persistence.treatRawData(rawData).data\r\n      , indexes = Persistence.treatRawData(rawData).indexes\r\n      ;\r\n\r\n    Object.keys(indexes).length.should.equal(1);\r\n    assert.deepEqual(indexes.test, { fieldName: \"test\", unique: true });\r\n      \r\n    treatedData.sort(function (a, b) { return a._id - b._id; });\r\n    treatedData.length.should.equal(2);\r\n    _.isEqual(treatedData[0], { _id: \"1\", a: 2, ages: [1, 5, 12] }).should.equal(true);\r\n    _.isEqual(treatedData[1], { _id: \"3\", today: now }).should.equal(true);\r\n  });  \r\n\r\n  it('Compact database on load', function (done) {\r\n    d.insert({ a: 2 }, function () {\r\n      d.insert({ a: 4 }, function () {\r\n        d.remove({ a: 2 }, {}, function () {\r\n          // Here, the underlying file is 3 lines long for only one document\r\n          var data = fs.readFileSync(d.filename, 'utf8').split('\\n')\r\n            , filledCount = 0;\r\n\r\n          data.forEach(function (item) { if (item.length > 0) { filledCount += 1; } });\r\n          filledCount.should.equal(3);\r\n\r\n          d.loadDatabase(function (err) {\r\n            assert.isNull(err);\r\n\r\n            // Now, the file has been compacted and is only 1 line long\r\n            var data = fs.readFileSync(d.filename, 'utf8').split('\\n')\r\n              , filledCount = 0;\r\n\r\n            data.forEach(function (item) { if (item.length > 0) { filledCount += 1; } });\r\n            filledCount.should.equal(1);\r\n\r\n            done();\r\n          });\r\n        })\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Calling loadDatabase after the data was modified doesnt change its contents', function (done) {\r\n    d.loadDatabase(function () {\r\n      d.insert({ a: 1 }, function (err) {\r\n        assert.isNull(err);\r\n        d.insert({ a: 2 }, function (err) {\r\n          var data = d.getAllData()\r\n            , doc1 = _.find(data, function (doc) { return doc.a === 1; })\r\n            , doc2 = _.find(data, function (doc) { return doc.a === 2; })\r\n            ;\r\n          assert.isNull(err);\r\n          data.length.should.equal(2);\r\n          doc1.a.should.equal(1);\r\n          doc2.a.should.equal(2);\r\n\r\n          d.loadDatabase(function (err) {\r\n            var data = d.getAllData()\r\n              , doc1 = _.find(data, function (doc) { return doc.a === 1; })\r\n              , doc2 = _.find(data, function (doc) { return doc.a === 2; })\r\n              ;\r\n            assert.isNull(err);\r\n            data.length.should.equal(2);\r\n            doc1.a.should.equal(1);\r\n            doc2.a.should.equal(2);\r\n\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Calling loadDatabase after the datafile was removed will reset the database', function (done) {\r\n    d.loadDatabase(function () {\r\n      d.insert({ a: 1 }, function (err) {\r\n        assert.isNull(err);\r\n        d.insert({ a: 2 }, function (err) {\r\n          var data = d.getAllData()\r\n            , doc1 = _.find(data, function (doc) { return doc.a === 1; })\r\n            , doc2 = _.find(data, function (doc) { return doc.a === 2; })\r\n            ;\r\n          assert.isNull(err);\r\n          data.length.should.equal(2);\r\n          doc1.a.should.equal(1);\r\n          doc2.a.should.equal(2);\r\n\r\n          fs.unlink(testDb, function (err) {\r\n            assert.isNull(err);\r\n            d.loadDatabase(function (err) {\r\n              assert.isNull(err);\r\n              d.getAllData().length.should.equal(0);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('Calling loadDatabase after the datafile was modified loads the new data', function (done) {\r\n    d.loadDatabase(function () {\r\n      d.insert({ a: 1 }, function (err) {\r\n        assert.isNull(err);\r\n        d.insert({ a: 2 }, function (err) {\r\n          var data = d.getAllData()\r\n            , doc1 = _.find(data, function (doc) { return doc.a === 1; })\r\n            , doc2 = _.find(data, function (doc) { return doc.a === 2; })\r\n            ;\r\n          assert.isNull(err);\r\n          data.length.should.equal(2);\r\n          doc1.a.should.equal(1);\r\n          doc2.a.should.equal(2);\r\n\r\n          fs.writeFile(testDb, '{\"a\":3,\"_id\":\"aaa\"}', 'utf8', function (err) {\r\n            assert.isNull(err);\r\n            d.loadDatabase(function (err) {\r\n              var data = d.getAllData()\r\n              , doc1 = _.find(data, function (doc) { return doc.a === 1; })\r\n              , doc2 = _.find(data, function (doc) { return doc.a === 2; })\r\n              , doc3 = _.find(data, function (doc) { return doc.a === 3; })\r\n              ;\r\n              assert.isNull(err);\r\n              data.length.should.equal(1);\r\n              doc3.a.should.equal(3);\r\n              assert.isUndefined(doc1);\r\n              assert.isUndefined(doc2);\r\n\r\n              done();\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n  \r\n  \r\n  describe('Prevent dataloss when persisting data', function () {\r\n\r\n    it('Creating a datastore with in memory as true and a bad filename wont cause an error', function () {\r\n      new Datastore({ filename: 'workspace/bad.db~', inMemoryOnly: true });\r\n    })\r\n    \r\n    it('Creating a persistent datastore with a bad filename will cause an error', function () {\r\n      (function () { new Datastore({ filename: 'workspace/bad.db~' }); }).should.throw();\r\n    })  \r\n  \r\n    it('If no file exists, ensureDatafileIntegrity creates an empty datafile', function (done) {\r\n      var p = new Persistence({ db: { inMemoryOnly: false, filename: 'workspace/it.db' } });\r\n    \r\n      if (fs.existsSync('workspace/it.db')) { fs.unlinkSync('workspace/it.db'); }\r\n      if (fs.existsSync('workspace/it.db~~')) { fs.unlinkSync('workspace/it.db~~'); }\r\n      \r\n      fs.existsSync('workspace/it.db').should.equal(false);\r\n      fs.existsSync('workspace/it.db~~').should.equal(false);      \r\n      \r\n      p.ensureDatafileIntegrity(function (err) {\r\n        assert.isNull(err);\r\n        \r\n        fs.existsSync('workspace/it.db').should.equal(true);\r\n        fs.existsSync('workspace/it.db~~').should.equal(false);\r\n        \r\n        fs.readFileSync('workspace/it.db', 'utf8').should.equal('');\r\n        \r\n        done();\r\n      });\r\n    });\r\n  \r\n    it('If only datafile exists, ensureDatafileIntegrity will use it', function (done) {\r\n      var p = new Persistence({ db: { inMemoryOnly: false, filename: 'workspace/it.db' } });\r\n    \r\n      if (fs.existsSync('workspace/it.db')) { fs.unlinkSync('workspace/it.db'); }\r\n      if (fs.existsSync('workspace/it.db~~')) { fs.unlinkSync('workspace/it.db~~'); }\r\n      \r\n      fs.writeFileSync('workspace/it.db', 'something', 'utf8');\r\n\r\n      fs.existsSync('workspace/it.db').should.equal(true);\r\n      fs.existsSync('workspace/it.db~~').should.equal(false);      \r\n      \r\n      p.ensureDatafileIntegrity(function (err) {\r\n        assert.isNull(err);\r\n\r\n        fs.existsSync('workspace/it.db').should.equal(true);\r\n        fs.existsSync('workspace/it.db~~').should.equal(false);\r\n        \r\n        fs.readFileSync('workspace/it.db', 'utf8').should.equal('something');\r\n        \r\n        done();\r\n      });\r\n    });\r\n    \r\n    it('If old datafile exists and datafile doesnt, ensureDatafileIntegrity will use it', function (done) {\r\n      var p = new Persistence({ db: { inMemoryOnly: false, filename: 'workspace/it.db' } });\r\n    \r\n      if (fs.existsSync('workspace/it.db')) { fs.unlinkSync('workspace/it.db'); }\r\n      if (fs.existsSync('workspace/it.db~~')) { fs.unlinkSync('workspace/it.db~~'); }\r\n      \r\n      fs.writeFileSync('workspace/it.db~~', 'something', 'utf8');\r\n      \r\n      fs.existsSync('workspace/it.db').should.equal(false);\r\n      fs.existsSync('workspace/it.db~~').should.equal(true);      \r\n      \r\n      p.ensureDatafileIntegrity(function (err) {\r\n        assert.isNull(err);\r\n        \r\n        fs.existsSync('workspace/it.db').should.equal(true);\r\n        fs.existsSync('workspace/it.db~~').should.equal(false);\r\n        \r\n        fs.readFileSync('workspace/it.db', 'utf8').should.equal('something');\r\n        \r\n        done();\r\n      });\r\n    });\r\n    \r\n    it('If both old and current datafiles exist, ensureDatafileIntegrity will use the datafile, it means step 4 of persistence failed', function (done) {\r\n      var theDb = new Datastore({ filename: 'workspace/it.db' });\r\n    \r\n      if (fs.existsSync('workspace/it.db')) { fs.unlinkSync('workspace/it.db'); }\r\n      if (fs.existsSync('workspace/it.db~~')) { fs.unlinkSync('workspace/it.db~~'); }\r\n      \r\n      fs.writeFileSync('workspace/it.db', '{\"_id\":\"0\",\"hello\":\"world\"}', 'utf8');\r\n      fs.writeFileSync('workspace/it.db~~', '{\"_id\":\"0\",\"hello\":\"other\"}', 'utf8');\r\n      \r\n      fs.existsSync('workspace/it.db').should.equal(true);\r\n      fs.existsSync('workspace/it.db~~').should.equal(true);      \r\n      \r\n      theDb.persistence.ensureDatafileIntegrity(function (err) {\r\n        assert.isNull(err);\r\n        \r\n        fs.existsSync('workspace/it.db').should.equal(true);\r\n        fs.existsSync('workspace/it.db~~').should.equal(true);\r\n        \r\n        fs.readFileSync('workspace/it.db', 'utf8').should.equal('{\"_id\":\"0\",\"hello\":\"world\"}');\r\n        \r\n        theDb.loadDatabase(function (err) {\r\n          assert.isNull(err);\r\n          theDb.find({}, function (err, docs) {\r\n            assert.isNull(err);\r\n            docs.length.should.equal(1);\r\n            docs[0].hello.should.equal(\"world\");\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  \r\n    it('persistCachedDatabase should update the contents of the datafile and leave a clean state', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(1);\r\n          \r\n          if (fs.existsSync(testDb)) { fs.unlinkSync(testDb); }\r\n          if (fs.existsSync(testDb + '~')) { fs.unlinkSync(testDb + '~'); }\r\n          if (fs.existsSync(testDb + '~~')) { fs.unlinkSync(testDb + '~~'); }\r\n          fs.existsSync(testDb).should.equal(false);\r\n          \r\n          fs.writeFileSync(testDb + '~', 'something', 'utf8');\r\n          fs.writeFileSync(testDb + '~~', 'something else', 'utf8');\r\n          fs.existsSync(testDb + '~').should.equal(true);\r\n          fs.existsSync(testDb + '~~').should.equal(true);\r\n          \r\n          d.persistence.persistCachedDatabase(function (err) {\r\n            var contents = fs.readFileSync(testDb, 'utf8');\r\n            assert.isNull(err);\r\n            fs.existsSync(testDb).should.equal(true);\r\n            fs.existsSync(testDb + '~').should.equal(false);            \r\n            fs.existsSync(testDb + '~~').should.equal(false);            \r\n            if (!contents.match(/^{\"hello\":\"world\",\"_id\":\"[0-9a-zA-Z]{16}\"}\\n$/)) {\r\n              throw \"Datafile contents not as expected\";\r\n            }\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('After a persistCachedDatabase, there should be no temp or old filename', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(1);\r\n          \r\n          if (fs.existsSync(testDb)) { fs.unlinkSync(testDb); }\r\n          if (fs.existsSync(testDb + '~')) { fs.unlinkSync(testDb + '~'); }\r\n          if (fs.existsSync(testDb + '~~')) { fs.unlinkSync(testDb + '~~'); }\r\n          fs.existsSync(testDb).should.equal(false);\r\n          \r\n          fs.writeFileSync(testDb + '~', 'bloup', 'utf8');\r\n          fs.writeFileSync(testDb + '~~', 'blap', 'utf8');\r\n          fs.existsSync(testDb + '~').should.equal(true);\r\n          fs.existsSync(testDb + '~~').should.equal(true);\r\n          \r\n          d.persistence.persistCachedDatabase(function (err) {\r\n            var contents = fs.readFileSync(testDb, 'utf8');\r\n            assert.isNull(err);\r\n            fs.existsSync(testDb).should.equal(true);\r\n            fs.existsSync(testDb + '~').should.equal(false);            \r\n            fs.existsSync(testDb + '~~').should.equal(false);            \r\n            if (!contents.match(/^{\"hello\":\"world\",\"_id\":\"[0-9a-zA-Z]{16}\"}\\n$/)) {\r\n              throw \"Datafile contents not as expected\";\r\n            }\r\n            done();\r\n          });\r\n        });\r\n      });    \r\n    });\r\n    \r\n    it('persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp or old datafile', function (done) {\r\n      d.insert({ hello: 'world' }, function () {\r\n        d.find({}, function (err, docs) {\r\n          docs.length.should.equal(1);\r\n          \r\n          if (fs.existsSync(testDb)) { fs.unlinkSync(testDb); }\r\n          fs.writeFileSync(testDb + '~', 'blabla', 'utf8');\r\n          fs.writeFileSync(testDb + '~~', 'bloblo', 'utf8');\r\n          fs.existsSync(testDb).should.equal(false);\r\n          fs.existsSync(testDb + '~').should.equal(true);\r\n          fs.existsSync(testDb + '~~').should.equal(true);\r\n          \r\n          d.persistence.persistCachedDatabase(function (err) {\r\n            var contents = fs.readFileSync(testDb, 'utf8');\r\n            assert.isNull(err);\r\n            fs.existsSync(testDb).should.equal(true);\r\n            fs.existsSync(testDb + '~').should.equal(false);            \r\n            fs.existsSync(testDb + '~~').should.equal(false);            \r\n            if (!contents.match(/^{\"hello\":\"world\",\"_id\":\"[0-9a-zA-Z]{16}\"}\\n$/)) {\r\n              throw \"Datafile contents not as expected\";\r\n            }\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n    \r\n    it('persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp or old datafile', function (done) {\r\n      var dbFile = 'workspace/test2.db', theDb;\r\n    \r\n      if (fs.existsSync(dbFile)) { fs.unlinkSync(dbFile); }\r\n      if (fs.existsSync(dbFile + '~')) { fs.unlinkSync(dbFile + '~'); }\r\n      if (fs.existsSync(dbFile + '~~')) { fs.unlinkSync(dbFile + '~~'); }\r\n      \r\n      theDb = new Datastore({ filename: dbFile });\r\n      \r\n      theDb.loadDatabase(function (err) {\r\n        var contents = fs.readFileSync(dbFile, 'utf8');\r\n        assert.isNull(err);\r\n        fs.existsSync(dbFile).should.equal(true);\r\n        fs.existsSync(dbFile + '~').should.equal(false);            \r\n        fs.existsSync(dbFile + '~~').should.equal(false);            \r\n        if (contents != \"\") {\r\n          throw \"Datafile contents not as expected\";\r\n        }\r\n        done();\r\n      });\r\n    });\r\n\r\n    it('Persistence works as expected when everything goes fine', function (done) {\r\n      var dbFile = 'workspace/test2.db', theDb, theDb2, doc1, doc2;\r\n      \r\n      async.waterfall([\r\n        async.apply(customUtils.ensureFileDoesntExist, dbFile)\r\n      , async.apply(customUtils.ensureFileDoesntExist, dbFile + '~')\r\n      , async.apply(customUtils.ensureFileDoesntExist, dbFile + '~~')\r\n      , function (cb) {\r\n        theDb = new Datastore({ filename: dbFile });\r\n        theDb.loadDatabase(cb);\r\n      }\r\n      , function (cb) {\r\n        theDb.find({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(0);\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {\r\n        theDb.insert({ a: 'hello' }, function (err, _doc1) {\r\n          assert.isNull(err);\r\n          doc1 = _doc1;\r\n          theDb.insert({ a: 'world' }, function (err, _doc2) {\r\n            assert.isNull(err);\r\n            doc2 = _doc2;\r\n            return cb();\r\n          });\r\n        });\r\n      }\r\n      , function (cb) {\r\n        theDb.find({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(2);\r\n          _.find(docs, function (item) { return item._id === doc1._id }).a.should.equal('hello');\r\n          _.find(docs, function (item) { return item._id === doc2._id }).a.should.equal('world');\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {\r\n        theDb.loadDatabase(cb);\r\n      }\r\n      , function (cb) {   // No change\r\n        theDb.find({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(2);\r\n          _.find(docs, function (item) { return item._id === doc1._id }).a.should.equal('hello');\r\n          _.find(docs, function (item) { return item._id === doc2._id }).a.should.equal('world');\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {\r\n        fs.existsSync(dbFile).should.equal(true);\r\n        fs.existsSync(dbFile + '~').should.equal(false);\r\n        fs.existsSync(dbFile + '~~').should.equal(false);\r\n        return cb();\r\n      }\r\n      , function (cb) {\r\n        theDb2 = new Datastore({ filename: dbFile });\r\n        theDb2.loadDatabase(cb);\r\n      }  \r\n      , function (cb) {   // No change in second db\r\n        theDb2.find({}, function (err, docs) {\r\n          assert.isNull(err);\r\n          docs.length.should.equal(2);\r\n          _.find(docs, function (item) { return item._id === doc1._id }).a.should.equal('hello');\r\n          _.find(docs, function (item) { return item._id === doc2._id }).a.should.equal('world');\r\n          return cb();\r\n        });\r\n      }\r\n      , function (cb) {\r\n        fs.existsSync(dbFile).should.equal(true);\r\n        fs.existsSync(dbFile + '~').should.equal(false);\r\n        fs.existsSync(dbFile + '~~').should.equal(false);\r\n        return cb();\r\n      } \r\n      ], done);\r\n    });\r\n    \r\n  \r\n    // This test is a bit complicated since it depends on the time I/O actions take to execute\r\n    // That depends on the machine and the load on the machine when the tests are run\r\n    // It is timed for my machine with nothing else running but may not work as expected on others (it will not fail but may not be a proof)\r\n    // Every new version of NeDB passes it on my machine before rtelease\r\n    it('If system crashes during a loadDatabase, the former version is not lost', function (done) {\r\n      var cp, N = 150000, toWrite = \"\", i;\r\n      \r\n      // Ensuring the state is clean\r\n      if (fs.existsSync('workspace/lac.db')) { fs.unlinkSync('workspace/lac.db'); }\r\n      if (fs.existsSync('workspace/lac.db~')) { fs.unlinkSync('workspace/lac.db~'); }\r\n\r\n      // Creating a db file with 150k records (a bit long to load)\r\n      for (i = 0; i < N; i += 1) {\r\n        toWrite += model.serialize({ _id: customUtils.uid(16), hello: 'world' }) + '\\n';\r\n      }        \r\n      fs.writeFileSync('workspace/lac.db', toWrite, 'utf8');\r\n      \r\n      // Loading it in a separate process that we will crash before finishing the loadDatabase\r\n      cp = child_process.fork('test_lac/loadAndCrash.test')\r\n      \r\n      // Kill the child process when we're at step 3 of persistCachedDatabase (during write to datafile)\r\n      setTimeout(function() {\r\n        cp.kill('SIGINT');\r\n        \r\n        // If the timing is correct, only the temp datafile contains data\r\n        // The datafile was in the middle of being written and is empty\r\n        \r\n        // Let the process crash be finished then load database without a crash, and test we didn't lose data\r\n        setTimeout(function () {\r\n          var db = new Datastore({ filename: 'workspace/lac.db' });\r\n          db.loadDatabase(function (err) {\r\n            assert.isNull(err);\r\n            \r\n            db.count({}, function (err, n) {\r\n              // Data has not been lost\r\n              assert.isNull(err);\r\n              n.should.equal(150000);\r\n              \r\n              // State is clean, the temp datafile has been erased and the datafile contains all the data\r\n              fs.existsSync('workspace/lac.db').should.equal(true);\r\n              fs.existsSync('workspace/lac.db~').should.equal(false);\r\n              \r\n              done();\r\n            });\r\n          });\r\n        }, 100);        \r\n      }, 2000);\r\n    });\r\n  \r\n  });   // ==== End of 'Prevent dataloss when persisting data' ====\r\n\r\n});\r\n","var Nedb = require('../lib/datastore.js')\r\n  , db = new Nedb({ filename: 'workspace/lac.db' })\r\n  ;\r\n\r\ndb.loadDatabase();","try {\n  var nodeuuid = require('../uuid');\n} catch (e) {\n  console.error('node-uuid require failed - skipping tests');\n}\n\ntry {\n  var uuid = require('uuid');\n} catch (e) {\n  console.error('uuid require failed - skipping tests');\n}\n\ntry {\n  var uuidjs = require('uuid-js');\n} catch (e) {\n  console.error('uuid-js require failed - skipping tests');\n}\n\nvar N = 5e5;\n\nfunction rate(msg, t) {\n  console.log(msg + ': ' +\n    (N / (Date.now() - t) * 1e3 | 0) +\n    ' uuids/second');\n}\n\nconsole.log('# v4');\n\n// node-uuid - string form\nif (nodeuuid) {\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v4();\n  rate('nodeuuid.v4() - using node.js crypto RNG', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v4({rng: nodeuuid.mathRNG});\n  rate('nodeuuid.v4() - using Math.random() RNG', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v4('binary');\n  rate('nodeuuid.v4(\\'binary\\')', t);\n\n  var buffer = new nodeuuid.BufferClass(16);\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v4('binary', buffer);\n  rate('nodeuuid.v4(\\'binary\\', buffer)', t);\n}\n\n// libuuid - string form\nif (uuid) {\n  for (var i = 0, t = Date.now(); i < N; i++) uuid();\n  rate('uuid()', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) uuid('binary');\n  rate('uuid(\\'binary\\')', t);\n}\n\n// uuid-js - string form\nif (uuidjs) {\n  for (var i = 0, t = Date.now(); i < N; i++) uuidjs.create(4);\n  rate('uuidjs.create(4)', t);\n}\n\n// 140byte.es\nfor (var i = 0, t = Date.now(); i < N; i++) 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,function(s,r){r=Math.random()*16|0;return (s=='x'?r:r&0x3|0x8).toString(16)});\nrate('140byte.es_v4', t);\n\nconsole.log('');\nconsole.log('# v1');\n\n// node-uuid - v1 string form\nif (nodeuuid) {\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v1();\n  rate('nodeuuid.v1()', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v1('binary');\n  rate('nodeuuid.v1(\\'binary\\')', t);\n\n  var buffer = new nodeuuid.BufferClass(16);\n  for (var i = 0, t = Date.now(); i < N; i++) nodeuuid.v1('binary', buffer);\n  rate('nodeuuid.v1(\\'binary\\', buffer)', t);\n}\n\n// uuid-js - v1 string form\nif (uuidjs) {\n  for (var i = 0, t = Date.now(); i < N; i++) uuidjs.create(1);\n  rate('uuidjs.create(1)', t);\n}\n","var assert = require('assert'),\n    nodeuuid = require('../'),\n    uuidjs = require('uuid-js'),\n    util = require('util'),\n    exec = require('child_process').exec,\n    os = require('os');\n\n// On Mac Os X / macports there's only the ossp-uuid package that provides uuid\n// On Linux there's uuid-runtime which provides uuidgen\nvar uuidCmd = os.type() === 'Darwin' ? 'uuid -1' : 'uuidgen -t';\n\nfunction compare(ids) {\n  console.log(ids);\n  for (var i = 0; i < ids.length; i++) {\n    var id = ids[i].split('-');\n    id = [id[2], id[1], id[0]].join('');\n    ids[i] = id;\n  }\n  var sorted = ([].concat(ids)).sort();\n\n  if (sorted.toString() !== ids.toString()) {\n    console.log('Warning: sorted !== ids');\n  } else {\n    console.log('everything in order!');\n  }\n}\n\n// Test time order of v1 uuids\nvar ids = [];\nwhile (ids.length < 10e3) ids.push(nodeuuid.v1());\n\nvar max = 10;\nconsole.log('node-uuid:');\nids = [];\nfor (var i = 0; i < max; i++) ids.push(nodeuuid.v1());\ncompare(ids);\n\nconsole.log('');\nconsole.log('uuidjs:');\nids = [];\nfor (var i = 0; i < max; i++) ids.push(uuidjs.create(1).toString());\ncompare(ids);\n\nconsole.log('');\nconsole.log('libuuid:');\nids = [];\nvar count = 0;\nvar last = function() {\n  compare(ids);\n}\nvar cb = function(err, stdout, stderr) {\n  ids.push(stdout.substring(0, stdout.length-1));\n  count++;\n  if (count < max) {\n    return next();\n  }\n  last();\n};\nvar next = function() {\n  exec(uuidCmd, cb);\n};\nnext();\n","var assert = require('assert');\n\nvar uuid = require('../');\n\nvar log = console.log;\n\nvar generators = {\n  v1: uuid.v1,\n  v4: uuid.v4\n};\n\nvar UUID_FORMAT = {\n  v1: /[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,\n  v4: /[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i\n};\n\nvar N = 1e4;\n\n// Get %'age an actual value differs from the ideal value\nfunction divergence(actual, ideal) {\n  return Math.round(100*100*(actual - ideal)/ideal)/100;\n}\n\nfunction rate(msg, t) {\n  log(msg + ': ' + (N / (Date.now() - t) * 1e3 | 0) + ' uuids\\/second');\n}\n\nfor (var version in generators) {\n  var counts = {}, max = 0;\n  var generator = generators[version];\n  var format = UUID_FORMAT[version];\n\n  log('\\nSanity check ' + N + ' ' + version + ' uuids');\n  for (var i = 0, ok = 0; i < N; i++) {\n    id = generator();\n    if (!format.test(id)) {\n      throw Error(id + ' is not a valid UUID string');\n    }\n\n    if (id != uuid.unparse(uuid.parse(id))) {\n      assert(fail, id + ' is not a valid id');\n    }\n\n    // Count digits for our randomness check\n    if (version == 'v4') {\n      var digits = id.replace(/-/g, '').split('');\n      for (var j = digits.length-1; j >= 0; j--) {\n        var c = digits[j];\n        max = Math.max(max, counts[c] = (counts[c] || 0) + 1);\n      }\n    }\n  }\n\n  // Check randomness for v4 UUIDs\n  if (version == 'v4') {\n    // Limit that we get worried about randomness. (Purely empirical choice, this!)\n    var limit = 2*100*Math.sqrt(1/N);\n\n    log('\\nChecking v4 randomness.  Distribution of Hex Digits (% deviation from ideal)');\n\n    for (var i = 0; i < 16; i++) {\n      var c = i.toString(16);\n      var bar = '', n = counts[c], p = Math.round(n/max*100|0);\n\n      // 1-3,5-8, and D-F: 1:16 odds over 30 digits\n      var ideal = N*30/16;\n      if (i == 4) {\n        // 4: 1:1 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1 + 30/16);\n      } else if (i >= 8 && i <= 11) {\n        // 8-B: 1:4 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1/4 + 30/16);\n      } else {\n        // Otherwise: 1:16 odds on 30 digits\n        ideal = N*30/16;\n      }\n      var d = divergence(n, ideal);\n\n      // Draw bar using UTF squares (just for grins)\n      var s = n/max*50 | 0;\n      while (s--) bar += '=';\n\n      assert(Math.abs(d) < limit, c + ' |' + bar + '| ' + counts[c] + ' (' + d + '% < ' + limit + '%)');\n    }\n  }\n}\n\n// Perf tests\nfor (var version in generators) {\n  log('\\nPerformance testing ' + version + ' UUIDs');\n  var generator = generators[version];\n  var buf = new uuid.BufferClass(16);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator();\n  rate('uuid.' + version + '()', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary');\n  rate('uuid.' + version + '(\\'binary\\')', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary', buf);\n  rate('uuid.' + version + '(\\'binary\\', buffer)', t);\n}\n","\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n","var rb = require('crypto').randomBytes;\nmodule.exports = function() {\n  return rb(16);\n};\n","var assert = require('assert');\n\nvar uuid = require('../');\n\n// Verify ordering of v1 ids created with explicit times\nvar TIME = 1321644961388; // 2011-11-18 11:36:01.388-08:00\n\nfunction compare(name, ids) {\n  test(name, function() {\n    // avoid .map for older browsers\n    for (var i=0 ; i<ids.length ; ++i) {\n      ids[i] = ids[i].split('-').reverse().join('-');\n    }\n    ids = ids.sort();\n    var sorted = ([].concat(ids)).sort();\n\n    assert(sorted.toString() == ids.toString(), name + ' have expected order');\n  });\n}\n\n// Verify ordering of v1 ids created using default behavior\ncompare('uuids with current time', [\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1()\n]);\n\n// Verify ordering of v1 ids created with explicit times\ncompare('uuids with time option', [\n  uuid.v1({msecs: TIME - 10*3600*1000}),\n  uuid.v1({msecs: TIME - 1}),\n  uuid.v1({msecs: TIME}),\n  uuid.v1({msecs: TIME + 1}),\n  uuid.v1({msecs: TIME + 28*24*3600*1000})\n]);\n\ntest('msec', function() {\n  assert(\n    uuid.v1({msecs: TIME}) != uuid.v1({msecs: TIME}),\n    'IDs created at same msec are different'\n  );\n});\n\ntest('exception thrown when > 10k ids created in 1ms', function() {\n  // Verify throw if too many ids created\n  var thrown = false;\n  try {\n    uuid.v1({msecs: TIME, nsecs: 10000});\n  } catch (e) {\n    thrown = true;\n  }\n  assert(thrown, 'Exception thrown when > 10K ids created in 1 ms');\n});\n\ntest('clock regression by msec', function() {\n  // Verify clock regression bumps clockseq\n  var uidt = uuid.v1({msecs: TIME});\n  var uidtb = uuid.v1({msecs: TIME - 1});\n  assert(\n    parseInt(uidtb.split('-')[3], 16) - parseInt(uidt.split('-')[3], 16) === 1,\n    'Clock regression by msec increments the clockseq'\n  );\n});\n\ntest('clock regression by nsec', function() {\n  // Verify clock regression bumps clockseq\n  var uidtn = uuid.v1({msecs: TIME, nsecs: 10});\n  var uidtnb = uuid.v1({msecs: TIME, nsecs: 9});\n  assert(\n    parseInt(uidtnb.split('-')[3], 16) - parseInt(uidtn.split('-')[3], 16) === 1,\n    'Clock regression by nsec increments the clockseq'\n  );\n});\n\ntest('explicit options product expected id', function() {\n  // Verify explicit options produce expected id\n  var id = uuid.v1({\n    msecs: 1321651533573,\n    nsecs: 5432,\n    clockseq: 0x385c,\n    node: [ 0x61, 0xcd, 0x3c, 0xbb, 0x32, 0x10 ]\n  });\n  assert(id == 'd9428888-122b-11e1-b85c-61cd3cbb3210', 'Explicit options produce expected id');\n});\n\ntest('ids spanning 1ms boundary are 100ns apart', function() {\n  // Verify adjacent ids across a msec boundary are 1 time unit apart\n  var u0 = uuid.v1({msecs: TIME, nsecs: 9999});\n  var u1 = uuid.v1({msecs: TIME + 1, nsecs: 0});\n\n  var before = u0.split('-')[0], after = u1.split('-')[0];\n  var dt = parseInt(after, 16) - parseInt(before, 16);\n  assert(dt === 1, 'Ids spanning 1ms boundary are 100ns apart');\n});\n\ntest('parse/unparse', function() {\n  var id = '00112233445566778899aabbccddeeff';\n  assert(uuid.unparse(uuid.parse(id.substr(0,10))) ==\n    '00112233-4400-0000-0000-000000000000', 'Short parse');\n  assert(uuid.unparse(uuid.parse('(this is the uuid -> ' + id + id)) ==\n    '00112233-4455-6677-8899-aabbccddeeff', 'Dirty parse');\n});\n\n","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Buffer class to use\nvar BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new BufferClass(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\nuuid.BufferClass = BufferClass;\n\nmodule.exports = uuid;\n","'use strict'\r\n\r\n### Controllers ###\r\n\r\nangular.module('app.controllers', [])\r\n\r\n.controller('AppCtrl', [\r\n  '$scope'\r\n  '$location'\r\n  '$resource'\r\n  '$rootScope'\r\n\r\n($scope, $location, $resource, $rootScope) ->\r\n\r\n  $scope.beginMycroftConnection = ->\r\n    $scope.conn = Mycroft.new();\r\n\r\n  # Uses the url to determine if the selected\r\n  # menu item should have the class active.\r\n  $scope.$location = $location\r\n  $scope.$watch('$location.path()', (path) ->\r\n    $scope.activeNavId = path || '/'\r\n  )\r\n\r\n  # getClass compares the current url with the id.\r\n  # If the current url starts with the id it returns 'active'\r\n  # otherwise it will return '' an empty string. E.g.\r\n  #\r\n  #   # current url = '/products/1'\r\n  #   getClass('/products') # returns 'active'\r\n  #   getClass('/orders') # returns ''\r\n  #\r\n  $scope.getClass = (id) ->\r\n    if $scope.activeNavId.substring(0, id.length) == id\r\n      return 'active'\r\n    else\r\n      return ''\r\n    \r\n    \r\n  $scope.targets = [\r\n    name: \"Front Speakers\"\r\n    type: \"speakers\"\r\n  ,\r\n    name: \"Main Screen\"\r\n    type: \"video-player\"\r\n  ]\r\n  \r\n  $scope.startStream = ->\r\n    targets = []\r\n    for item in $scope.targets\r\n      if item.selected \r\n        targets.push(item.name)\r\n])\r\n\r\n.controller('screen', [\r\n  '$scope'\r\n\r\n($scope) ->\r\n  $scope.onePlusOne = 2\r\n])\r\n\r\n.controller('youtube', [\r\n  '$scope'\r\n\r\n($scope) ->\r\n  $scope\r\n])\r\n\r\n.controller('file', [\r\n  '$scope'\r\n\r\n($scope) ->\r\n        \r\n\r\n  holder = document.getElementById('fileDialog')\r\n  holder.ondragover = ->\r\n    @className = 'hover'\r\n    false\r\n    \r\n  holder.ondragend = ->\r\n    @className = ''\r\n    false\r\n    \r\n  holder.ondrop = (e) ->\r\n    e.preventDefault();\r\n    holder.files = e.dataTransfer.files\r\n    false\r\n])\r\n\r\nwindow.ondragover = (e) -> \r\n  e.preventDefault()\r\n  false\r\n\r\nwindow.ondrop = (e) ->\r\n  e.preventDefault()\r\n  false","DataStore = exports? and exports or @DataStore = {}\r\n\r\n# which kind of database do you want?\r\n# possible alternatives: \r\n# - \"simple\" => this will use the browser's localStorage mechanism. Simple, but synchronous/blocking !!\r\n# - \"relational\" => this will use the browser-internal sqlite implementation, \"Web SQL Database\"\r\n# - \"document\" => Use MongoDB's little brother: https://github.com/louischatriot/nedb\r\nDataStore.create = (type) -> switch type\r\n  when \"simple\" then createSimpleStore()\r\n  # when \"keyvalue\" then createKeyValueStore()\r\n  when \"relational\" then createRelationalStore()\r\n  when \"document\" then createDocumentStore()\r\n  # when \"triple\" then createTripleStore()\r\n  else return undefined\r\n\r\n# thin wrapper over localStorage\r\ncreateSimpleStore = ->\r\n  get: (key) -> JSON.parse localStorage.getItem JSON.stringify key\r\n  set: (key, value) -> localStorage.setItem JSON.stringify(key), JSON.stringify(value)\r\n  delete: (key) -> localStorage.removeItem JSON.stringify key\r\n  count: -> localStorage.length\r\n  clear: -> localStorage.clear()\r\n\r\ncreateRelationalStore = ->\r\n  db = openDatabase \"nwsqldb\", \"1.0\", \"embedded sql database\", 1024 * 1024 * 256\r\n  store = {\r\n    run: (query, fn) -> db.transaction (tx) -> tx.executeSql query, [], (tx, result) -> \r\n      fn? (result.rows.item(i) for i in [0 ... result.rows.length])\r\n  }\r\n  return store\r\n\r\ncreateDocumentStore = ->\r\n  try \r\n    NeDB = require \"nedb\"\r\n    datapath = require('nw.gui').App.dataPath + \"/nedb\"\r\n    store = {\r\n      collection: (name) -> new NeDB({ filename: \"/#{name}\", autoload: true });\r\n    }\r\n    return store\r\n  catch e\r\n    if e.code is \"MODULE_NOT_FOUND\" \r\n      console.error \"NeDB not found. Try `npm install nedb --save` inside of `/app/assets`.\" \r\n    else \r\n      console.error e \r\n"]}